# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
  query: Query
  mutation: Mutation
}

"An object with a globally unique `ID`."
interface Node {
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
}

"The output of our create `GameAssignment` mutation."
type CreateGameAssignmentPayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "Reads a single `Game` that is related to this `GameAssignment`."
  game: Game
  "The `GameAssignment` that was created by this mutation."
  gameAssignment: GameAssignment
  "An edge for our `GameAssignment`. May be used by Relay 1."
  gameAssignmentEdge(
    #The method to use when ordering `GameAssignment`.
    orderBy: [GameAssignmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): GameAssignmentsEdge
  "Reads a single `Membership` that is related to this `GameAssignment`."
  member: Membership
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our create `GameChoice` mutation."
type CreateGameChoicePayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "Reads a single `Game` that is related to this `GameChoice`."
  game: Game
  "The `GameChoice` that was created by this mutation."
  gameChoice: GameChoice
  "An edge for our `GameChoice`. May be used by Relay 1."
  gameChoiceEdge(
    #The method to use when ordering `GameChoice`.
    orderBy: [GameChoicesOrderBy!] = [PRIMARY_KEY_ASC]
  ): GameChoicesEdge
  "Reads a single `Membership` that is related to this `GameChoice`."
  member: Membership
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "Reads a single `Slot` that is related to this `GameChoice`."
  slot: Slot
}

"The output of our create `Game` mutation."
type CreateGamePayload {
  "Reads a single `User` that is related to this `Game`."
  author: User
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `Game` that was created by this mutation."
  game: Game
  "An edge for our `Game`. May be used by Relay 1."
  gameEdge(
    #The method to use when ordering `Game`.
    orderBy: [GamesOrderBy!] = [PRIMARY_KEY_ASC]
  ): GamesEdge
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "Reads a single `Room` that is related to this `Game`."
  room: Room
  "Reads a single `Slot` that is related to this `Game`."
  slot: Slot
}

"The output of our create `GameSubmission` mutation."
type CreateGameSubmissionPayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `GameSubmission` that was created by this mutation."
  gameSubmission: GameSubmission
  "An edge for our `GameSubmission`. May be used by Relay 1."
  gameSubmissionEdge(
    #The method to use when ordering `GameSubmission`.
    orderBy: [GameSubmissionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): GameSubmissionsEdge
  "Reads a single `Membership` that is related to this `GameSubmission`."
  member: Membership
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our create `HotelRoomDetail` mutation."
type CreateHotelRoomDetailPayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `HotelRoomDetail` that was created by this mutation."
  hotelRoomDetail: HotelRoomDetail
  "An edge for our `HotelRoomDetail`. May be used by Relay 1."
  hotelRoomDetailEdge(
    #The method to use when ordering `HotelRoomDetail`.
    orderBy: [HotelRoomDetailsOrderBy!] = [PRIMARY_KEY_ASC]
  ): HotelRoomDetailsEdge
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our create `HotelRoom` mutation."
type CreateHotelRoomPayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `HotelRoom` that was created by this mutation."
  hotelRoom: HotelRoom
  "An edge for our `HotelRoom`. May be used by Relay 1."
  hotelRoomEdge(
    #The method to use when ordering `HotelRoom`.
    orderBy: [HotelRoomsOrderBy!] = [PRIMARY_KEY_ASC]
  ): HotelRoomsEdge
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our create `Lookup` mutation."
type CreateLookupPayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `Lookup` that was created by this mutation."
  lookup: Lookup
  "An edge for our `Lookup`. May be used by Relay 1."
  lookupEdge(
    #The method to use when ordering `Lookup`.
    orderBy: [LookupsOrderBy!] = [PRIMARY_KEY_ASC]
  ): LookupsEdge
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our create `LookupValue` mutation."
type CreateLookupValuePayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "Reads a single `Lookup` that is related to this `LookupValue`."
  lookup: Lookup
  "The `LookupValue` that was created by this mutation."
  lookupValue: LookupValue
  "An edge for our `LookupValue`. May be used by Relay 1."
  lookupValueEdge(
    #The method to use when ordering `LookupValue`.
    orderBy: [LookupValuesOrderBy!] = [PRIMARY_KEY_ASC]
  ): LookupValuesEdge
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our create `MemberHotelRoomAssignment` mutation."
type CreateMemberHotelRoomAssignmentPayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "Reads a single `HotelRoomDetail` that is related to this `MemberHotelRoomAssignment`."
  hotelRoom: HotelRoomDetail
  "Reads a single `Membership` that is related to this `MemberHotelRoomAssignment`."
  member: Membership
  "The `MemberHotelRoomAssignment` that was created by this mutation."
  memberHotelRoomAssignment: MemberHotelRoomAssignment
  "An edge for our `MemberHotelRoomAssignment`. May be used by Relay 1."
  memberHotelRoomAssignmentEdge(
    #The method to use when ordering `MemberHotelRoomAssignment`.
    orderBy: [MemberHotelRoomAssignmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): MemberHotelRoomAssignmentsEdge
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our create `Membership` mutation."
type CreateMembershipPayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "Reads a single `HotelRoom` that is related to this `Membership`."
  hotelRoom: HotelRoom
  "The `Membership` that was created by this mutation."
  membership: Membership
  "An edge for our `Membership`. May be used by Relay 1."
  membershipEdge(
    #The method to use when ordering `Membership`.
    orderBy: [MembershipsOrderBy!] = [PRIMARY_KEY_ASC]
  ): MembershipsEdge
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "Reads a single `User` that is related to this `Membership`."
  user: User
}

"The output of our create `Profile` mutation."
type CreateProfilePayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `Profile` that was created by this mutation."
  profile: Profile
  "An edge for our `Profile`. May be used by Relay 1."
  profileEdge(
    #The method to use when ordering `Profile`.
    orderBy: [ProfilesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProfilesEdge
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our create `RegistrationCode` mutation."
type CreateRegistrationCodePayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `RegistrationCode` that was created by this mutation."
  registrationCode: RegistrationCode
  "An edge for our `RegistrationCode`. May be used by Relay 1."
  registrationCodeEdge(
    #The method to use when ordering `RegistrationCode`.
    orderBy: [RegistrationCodesOrderBy!] = [PRIMARY_KEY_ASC]
  ): RegistrationCodesEdge
}

"The output of our create `Role` mutation."
type CreateRolePayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `Role` that was created by this mutation."
  role: Role
  "An edge for our `Role`. May be used by Relay 1."
  roleEdge(
    #The method to use when ordering `Role`.
    orderBy: [RolesOrderBy!] = [PRIMARY_KEY_ASC]
  ): RolesEdge
}

"The output of our create `Room` mutation."
type CreateRoomPayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `Room` that was created by this mutation."
  room: Room
  "An edge for our `Room`. May be used by Relay 1."
  roomEdge(
    #The method to use when ordering `Room`.
    orderBy: [RoomsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RoomsEdge
}

"The output of our create `Setting` mutation."
type CreateSettingPayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `Setting` that was created by this mutation."
  setting: Setting
  "An edge for our `Setting`. May be used by Relay 1."
  settingEdge(
    #The method to use when ordering `Setting`.
    orderBy: [SettingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SettingsEdge
}

"The output of our create `ShirtOrderItem` mutation."
type CreateShirtOrderItemPayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "Reads a single `ShirtOrder` that is related to this `ShirtOrderItem`."
  order: ShirtOrder
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `ShirtOrderItem` that was created by this mutation."
  shirtOrderItem: ShirtOrderItem
  "An edge for our `ShirtOrderItem`. May be used by Relay 1."
  shirtOrderItemEdge(
    #The method to use when ordering `ShirtOrderItem`.
    orderBy: [ShirtOrderItemsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ShirtOrderItemsEdge
}

"The output of our create `ShirtOrder` mutation."
type CreateShirtOrderPayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `ShirtOrder` that was created by this mutation."
  shirtOrder: ShirtOrder
  "An edge for our `ShirtOrder`. May be used by Relay 1."
  shirtOrderEdge(
    #The method to use when ordering `ShirtOrder`.
    orderBy: [ShirtOrdersOrderBy!] = [PRIMARY_KEY_ASC]
  ): ShirtOrdersEdge
  "Reads a single `User` that is related to this `ShirtOrder`."
  user: User
}

"The output of our create `Slot` mutation."
type CreateSlotPayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `Slot` that was created by this mutation."
  slot: Slot
  "An edge for our `Slot`. May be used by Relay 1."
  slotEdge(
    #The method to use when ordering `Slot`.
    orderBy: [SlotsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SlotsEdge
}

"The output of our create `Token` mutation."
type CreateTokenPayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `Token` that was created by this mutation."
  token: Token
  "An edge for our `Token`. May be used by Relay 1."
  tokenEdge(
    #The method to use when ordering `Token`.
    orderBy: [TokensOrderBy!] = [PRIMARY_KEY_ASC]
  ): TokensEdge
  "Reads a single `User` that is related to this `Token`."
  user: User
}

"The output of our create `User` mutation."
type CreateUserPayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "Reads a single `Profile` that is related to this `User`."
  profile: Profile
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `User` that was created by this mutation."
  user: User
  "An edge for our `User`. May be used by Relay 1."
  userEdge(
    #The method to use when ordering `User`.
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

"The output of our create `UserRole` mutation."
type CreateUserRolePayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "Reads a single `Role` that is related to this `UserRole`."
  role: Role
  "Reads a single `User` that is related to this `UserRole`."
  user: User
  "The `UserRole` that was created by this mutation."
  userRole: UserRole
  "An edge for our `UserRole`. May be used by Relay 1."
  userRoleEdge(
    #The method to use when ordering `UserRole`.
    orderBy: [UserRolesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserRolesEdge
}

"The output of our delete `GameAssignment` mutation."
type DeleteGameAssignmentPayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  deletedGameAssignmentNodeId: ID
  "Reads a single `Game` that is related to this `GameAssignment`."
  game: Game
  "The `GameAssignment` that was deleted by this mutation."
  gameAssignment: GameAssignment
  "An edge for our `GameAssignment`. May be used by Relay 1."
  gameAssignmentEdge(
    #The method to use when ordering `GameAssignment`.
    orderBy: [GameAssignmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): GameAssignmentsEdge
  "Reads a single `Membership` that is related to this `GameAssignment`."
  member: Membership
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our delete `GameChoice` mutation."
type DeleteGameChoicePayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  deletedGameChoiceNodeId: ID
  "Reads a single `Game` that is related to this `GameChoice`."
  game: Game
  "The `GameChoice` that was deleted by this mutation."
  gameChoice: GameChoice
  "An edge for our `GameChoice`. May be used by Relay 1."
  gameChoiceEdge(
    #The method to use when ordering `GameChoice`.
    orderBy: [GameChoicesOrderBy!] = [PRIMARY_KEY_ASC]
  ): GameChoicesEdge
  "Reads a single `Membership` that is related to this `GameChoice`."
  member: Membership
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "Reads a single `Slot` that is related to this `GameChoice`."
  slot: Slot
}

"The output of our delete `Game` mutation."
type DeleteGamePayload {
  "Reads a single `User` that is related to this `Game`."
  author: User
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  deletedGameNodeId: ID
  "The `Game` that was deleted by this mutation."
  game: Game
  "An edge for our `Game`. May be used by Relay 1."
  gameEdge(
    #The method to use when ordering `Game`.
    orderBy: [GamesOrderBy!] = [PRIMARY_KEY_ASC]
  ): GamesEdge
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "Reads a single `Room` that is related to this `Game`."
  room: Room
  "Reads a single `Slot` that is related to this `Game`."
  slot: Slot
}

"The output of our delete `GameSubmission` mutation."
type DeleteGameSubmissionPayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  deletedGameSubmissionNodeId: ID
  "The `GameSubmission` that was deleted by this mutation."
  gameSubmission: GameSubmission
  "An edge for our `GameSubmission`. May be used by Relay 1."
  gameSubmissionEdge(
    #The method to use when ordering `GameSubmission`.
    orderBy: [GameSubmissionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): GameSubmissionsEdge
  "Reads a single `Membership` that is related to this `GameSubmission`."
  member: Membership
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our delete `HotelRoomDetail` mutation."
type DeleteHotelRoomDetailPayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  deletedHotelRoomDetailNodeId: ID
  "The `HotelRoomDetail` that was deleted by this mutation."
  hotelRoomDetail: HotelRoomDetail
  "An edge for our `HotelRoomDetail`. May be used by Relay 1."
  hotelRoomDetailEdge(
    #The method to use when ordering `HotelRoomDetail`.
    orderBy: [HotelRoomDetailsOrderBy!] = [PRIMARY_KEY_ASC]
  ): HotelRoomDetailsEdge
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our delete `HotelRoom` mutation."
type DeleteHotelRoomPayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  deletedHotelRoomNodeId: ID
  "The `HotelRoom` that was deleted by this mutation."
  hotelRoom: HotelRoom
  "An edge for our `HotelRoom`. May be used by Relay 1."
  hotelRoomEdge(
    #The method to use when ordering `HotelRoom`.
    orderBy: [HotelRoomsOrderBy!] = [PRIMARY_KEY_ASC]
  ): HotelRoomsEdge
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our delete `Lookup` mutation."
type DeleteLookupPayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  deletedLookupNodeId: ID
  "The `Lookup` that was deleted by this mutation."
  lookup: Lookup
  "An edge for our `Lookup`. May be used by Relay 1."
  lookupEdge(
    #The method to use when ordering `Lookup`.
    orderBy: [LookupsOrderBy!] = [PRIMARY_KEY_ASC]
  ): LookupsEdge
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our delete `LookupValue` mutation."
type DeleteLookupValuePayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  deletedLookupValueNodeId: ID
  "Reads a single `Lookup` that is related to this `LookupValue`."
  lookup: Lookup
  "The `LookupValue` that was deleted by this mutation."
  lookupValue: LookupValue
  "An edge for our `LookupValue`. May be used by Relay 1."
  lookupValueEdge(
    #The method to use when ordering `LookupValue`.
    orderBy: [LookupValuesOrderBy!] = [PRIMARY_KEY_ASC]
  ): LookupValuesEdge
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our delete `MemberHotelRoomAssignment` mutation."
type DeleteMemberHotelRoomAssignmentPayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  deletedMemberHotelRoomAssignmentNodeId: ID
  "Reads a single `HotelRoomDetail` that is related to this `MemberHotelRoomAssignment`."
  hotelRoom: HotelRoomDetail
  "Reads a single `Membership` that is related to this `MemberHotelRoomAssignment`."
  member: Membership
  "The `MemberHotelRoomAssignment` that was deleted by this mutation."
  memberHotelRoomAssignment: MemberHotelRoomAssignment
  "An edge for our `MemberHotelRoomAssignment`. May be used by Relay 1."
  memberHotelRoomAssignmentEdge(
    #The method to use when ordering `MemberHotelRoomAssignment`.
    orderBy: [MemberHotelRoomAssignmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): MemberHotelRoomAssignmentsEdge
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our delete `Membership` mutation."
type DeleteMembershipPayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  deletedMembershipNodeId: ID
  "Reads a single `HotelRoom` that is related to this `Membership`."
  hotelRoom: HotelRoom
  "The `Membership` that was deleted by this mutation."
  membership: Membership
  "An edge for our `Membership`. May be used by Relay 1."
  membershipEdge(
    #The method to use when ordering `Membership`.
    orderBy: [MembershipsOrderBy!] = [PRIMARY_KEY_ASC]
  ): MembershipsEdge
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "Reads a single `User` that is related to this `Membership`."
  user: User
}

"The output of our delete `Profile` mutation."
type DeleteProfilePayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  deletedProfileNodeId: ID
  "The `Profile` that was deleted by this mutation."
  profile: Profile
  "An edge for our `Profile`. May be used by Relay 1."
  profileEdge(
    #The method to use when ordering `Profile`.
    orderBy: [ProfilesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProfilesEdge
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our delete `RegistrationCode` mutation."
type DeleteRegistrationCodePayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  deletedRegistrationCodeNodeId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `RegistrationCode` that was deleted by this mutation."
  registrationCode: RegistrationCode
  "An edge for our `RegistrationCode`. May be used by Relay 1."
  registrationCodeEdge(
    #The method to use when ordering `RegistrationCode`.
    orderBy: [RegistrationCodesOrderBy!] = [PRIMARY_KEY_ASC]
  ): RegistrationCodesEdge
}

"The output of our delete `Role` mutation."
type DeleteRolePayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  deletedRoleNodeId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `Role` that was deleted by this mutation."
  role: Role
  "An edge for our `Role`. May be used by Relay 1."
  roleEdge(
    #The method to use when ordering `Role`.
    orderBy: [RolesOrderBy!] = [PRIMARY_KEY_ASC]
  ): RolesEdge
}

"The output of our delete `Room` mutation."
type DeleteRoomPayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  deletedRoomNodeId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `Room` that was deleted by this mutation."
  room: Room
  "An edge for our `Room`. May be used by Relay 1."
  roomEdge(
    #The method to use when ordering `Room`.
    orderBy: [RoomsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RoomsEdge
}

"The output of our delete `Setting` mutation."
type DeleteSettingPayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  deletedSettingNodeId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `Setting` that was deleted by this mutation."
  setting: Setting
  "An edge for our `Setting`. May be used by Relay 1."
  settingEdge(
    #The method to use when ordering `Setting`.
    orderBy: [SettingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SettingsEdge
}

"The output of our delete `ShirtOrderItem` mutation."
type DeleteShirtOrderItemPayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  deletedShirtOrderItemNodeId: ID
  "Reads a single `ShirtOrder` that is related to this `ShirtOrderItem`."
  order: ShirtOrder
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `ShirtOrderItem` that was deleted by this mutation."
  shirtOrderItem: ShirtOrderItem
  "An edge for our `ShirtOrderItem`. May be used by Relay 1."
  shirtOrderItemEdge(
    #The method to use when ordering `ShirtOrderItem`.
    orderBy: [ShirtOrderItemsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ShirtOrderItemsEdge
}

"The output of our delete `ShirtOrder` mutation."
type DeleteShirtOrderPayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  deletedShirtOrderNodeId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `ShirtOrder` that was deleted by this mutation."
  shirtOrder: ShirtOrder
  "An edge for our `ShirtOrder`. May be used by Relay 1."
  shirtOrderEdge(
    #The method to use when ordering `ShirtOrder`.
    orderBy: [ShirtOrdersOrderBy!] = [PRIMARY_KEY_ASC]
  ): ShirtOrdersEdge
  "Reads a single `User` that is related to this `ShirtOrder`."
  user: User
}

"The output of our delete `Slot` mutation."
type DeleteSlotPayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  deletedSlotNodeId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `Slot` that was deleted by this mutation."
  slot: Slot
  "An edge for our `Slot`. May be used by Relay 1."
  slotEdge(
    #The method to use when ordering `Slot`.
    orderBy: [SlotsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SlotsEdge
}

"The output of our delete `Token` mutation."
type DeleteTokenPayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  deletedTokenNodeId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `Token` that was deleted by this mutation."
  token: Token
  "An edge for our `Token`. May be used by Relay 1."
  tokenEdge(
    #The method to use when ordering `Token`.
    orderBy: [TokensOrderBy!] = [PRIMARY_KEY_ASC]
  ): TokensEdge
  "Reads a single `User` that is related to this `Token`."
  user: User
}

"The output of our delete `User` mutation."
type DeleteUserPayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  deletedUserNodeId: ID
  "Reads a single `Profile` that is related to this `User`."
  profile: Profile
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `User` that was deleted by this mutation."
  user: User
  "An edge for our `User`. May be used by Relay 1."
  userEdge(
    #The method to use when ordering `User`.
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

"The output of our delete `UserRole` mutation."
type DeleteUserRolePayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  deletedUserRoleNodeId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "Reads a single `Role` that is related to this `UserRole`."
  role: Role
  "Reads a single `User` that is related to this `UserRole`."
  user: User
  "The `UserRole` that was deleted by this mutation."
  userRole: UserRole
  "An edge for our `UserRole`. May be used by Relay 1."
  userRoleEdge(
    #The method to use when ordering `UserRole`.
    orderBy: [UserRolesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserRolesEdge
}

"The output of our `fTruncateTables` mutation."
type FTruncateTablesPayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

type Game implements Node {
  "Reads a single `User` that is related to this `Game`."
  author: User
  authorId: Int
  charInstructions: String!
  description: String!
  estimatedLength: String!
  "Reads and enables pagination through a set of `GameAssignment`."
  gameAssignments(
    #Read all values in the set after (below) this cursor.
    after: Cursor
    #Read all values in the set before (above) this cursor.
    before: Cursor
    #A condition to be used in determining which values should be returned by the collection.
    condition: GameAssignmentCondition
    #A filter to be used in determining which values should be returned by the collection.
    filter: GameAssignmentFilter
    #Only read the first `n` values of the set.
    first: Int
    #Only read the last `n` values of the set.
    last: Int
    #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
    offset: Int
    #The method to use when ordering `GameAssignment`.
    orderBy: [GameAssignmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): GameAssignmentsConnection!
  "Reads and enables pagination through a set of `GameChoice`."
  gameChoices(
    #Read all values in the set after (below) this cursor.
    after: Cursor
    #Read all values in the set before (above) this cursor.
    before: Cursor
    #A condition to be used in determining which values should be returned by the collection.
    condition: GameChoiceCondition
    #A filter to be used in determining which values should be returned by the collection.
    filter: GameChoiceFilter
    #Only read the first `n` values of the set.
    first: Int
    #Only read the last `n` values of the set.
    last: Int
    #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
    offset: Int
    #The method to use when ordering `GameChoice`.
    orderBy: [GameChoicesOrderBy!] = [PRIMARY_KEY_ASC]
  ): GameChoicesConnection!
  gameContactEmail: String!
  genre: String!
  gmNames: String
  id: Int!
  lateFinish: Boolean
  lateStart: String
  message: String!
  name: String!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  playerMax: Int!
  playerMin: Int!
  playerPreference: String!
  playersContactGm: Boolean!
  returningPlayers: String!
  "Reads a single `Room` that is related to this `Game`."
  room: Room
  roomId: Int
  setting: String!
  shortName: String
  "Reads a single `Slot` that is related to this `Game`."
  slot: Slot
  slotConflicts: String!
  slotId: Int
  slotPreference: Int!
  teenFriendly: Boolean!
  type: String!
  year: Int!
}

type GameAssignment implements Node {
  "Reads a single `Game` that is related to this `GameAssignment`."
  game: Game
  gameId: Int!
  gm: Int!
  "Reads a single `Membership` that is related to this `GameAssignment`."
  member: Membership
  memberId: Int!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  year: Int!
}

"A connection to a list of `GameAssignment` values."
type GameAssignmentsConnection {
  "A list of edges which contains the `GameAssignment` and cursor to aid in pagination."
  edges: [GameAssignmentsEdge!]!
  "A list of `GameAssignment` objects."
  nodes: [GameAssignment]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `GameAssignment` you could get from the connection."
  totalCount: Int!
}

"A `GameAssignment` edge in the connection."
type GameAssignmentsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `GameAssignment` at the end of the edge."
  node: GameAssignment
}

type GameChoice implements Node {
  "Reads a single `Game` that is related to this `GameChoice`."
  game: Game
  gameId: Int
  id: Int!
  "Reads a single `Membership` that is related to this `GameChoice`."
  member: Membership
  memberId: Int!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  rank: Int!
  returningPlayer: Boolean!
  "Reads a single `Slot` that is related to this `GameChoice`."
  slot: Slot
  slotId: Int!
  year: Int!
}

"A connection to a list of `GameChoice` values."
type GameChoicesConnection {
  "A list of edges which contains the `GameChoice` and cursor to aid in pagination."
  edges: [GameChoicesEdge!]!
  "A list of `GameChoice` objects."
  nodes: [GameChoice]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `GameChoice` you could get from the connection."
  totalCount: Int!
}

"A `GameChoice` edge in the connection."
type GameChoicesEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `GameChoice` at the end of the edge."
  node: GameChoice
}

type GameSubmission implements Node {
  id: Int!
  "Reads a single `Membership` that is related to this `GameSubmission`."
  member: Membership
  memberId: Int!
  message: String!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  year: Int!
}

"A connection to a list of `GameSubmission` values."
type GameSubmissionsConnection {
  "A list of edges which contains the `GameSubmission` and cursor to aid in pagination."
  edges: [GameSubmissionsEdge!]!
  "A list of `GameSubmission` objects."
  nodes: [GameSubmission]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `GameSubmission` you could get from the connection."
  totalCount: Int!
}

"A `GameSubmission` edge in the connection."
type GameSubmissionsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `GameSubmission` at the end of the edge."
  node: GameSubmission
}

"A connection to a list of `Game` values."
type GamesConnection {
  "A list of edges which contains the `Game` and cursor to aid in pagination."
  edges: [GamesEdge!]!
  "A list of `Game` objects."
  nodes: [Game]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `Game` you could get from the connection."
  totalCount: Int!
}

"A `Game` edge in the connection."
type GamesEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `Game` at the end of the edge."
  node: Game
}

type HotelRoom implements Node {
  bathroomType: String!
  description: String!
  gamingRoom: Boolean!
  id: Int!
  "Reads and enables pagination through a set of `Membership`."
  memberships(
    #Read all values in the set after (below) this cursor.
    after: Cursor
    #Read all values in the set before (above) this cursor.
    before: Cursor
    #A condition to be used in determining which values should be returned by the collection.
    condition: MembershipCondition
    #A filter to be used in determining which values should be returned by the collection.
    filter: MembershipFilter
    #Only read the first `n` values of the set.
    first: Int
    #Only read the last `n` values of the set.
    last: Int
    #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
    offset: Int
    #The method to use when ordering `Membership`.
    orderBy: [MembershipsOrderBy!] = [PRIMARY_KEY_ASC]
  ): MembershipsConnection!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  occupancy: String!
  quantity: Int!
  rate: String!
  type: String!
}

type HotelRoomDetail implements Node {
  bathroomType: String!
  comment: String!
  enabled: Boolean!
  formattedRoomType: String!
  gamingRoom: Boolean!
  id: BigInt!
  internalRoomType: String!
  "Reads and enables pagination through a set of `MemberHotelRoomAssignment`."
  memberHotelRoomAssignmentsByHotelRoomId(
    #Read all values in the set after (below) this cursor.
    after: Cursor
    #Read all values in the set before (above) this cursor.
    before: Cursor
    #A condition to be used in determining which values should be returned by the collection.
    condition: MemberHotelRoomAssignmentCondition
    #A filter to be used in determining which values should be returned by the collection.
    filter: MemberHotelRoomAssignmentFilter
    #Only read the first `n` values of the set.
    first: Int
    #Only read the last `n` values of the set.
    last: Int
    #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
    offset: Int
    #The method to use when ordering `MemberHotelRoomAssignment`.
    orderBy: [MemberHotelRoomAssignmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): MemberHotelRoomAssignmentsConnection!
  name: String!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  reserved: Boolean!
  reservedFor: String!
  roomType: String!
  version: BigInt!
}

"A connection to a list of `HotelRoomDetail` values."
type HotelRoomDetailsConnection {
  "A list of edges which contains the `HotelRoomDetail` and cursor to aid in pagination."
  edges: [HotelRoomDetailsEdge!]!
  "A list of `HotelRoomDetail` objects."
  nodes: [HotelRoomDetail]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `HotelRoomDetail` you could get from the connection."
  totalCount: Int!
}

"A `HotelRoomDetail` edge in the connection."
type HotelRoomDetailsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `HotelRoomDetail` at the end of the edge."
  node: HotelRoomDetail
}

"A connection to a list of `HotelRoom` values."
type HotelRoomsConnection {
  "A list of edges which contains the `HotelRoom` and cursor to aid in pagination."
  edges: [HotelRoomsEdge!]!
  "A list of `HotelRoom` objects."
  nodes: [HotelRoom]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `HotelRoom` you could get from the connection."
  totalCount: Int!
}

"A `HotelRoom` edge in the connection."
type HotelRoomsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `HotelRoom` at the end of the edge."
  node: HotelRoom
}

type Lookup implements Node {
  codeMaximum: String
  codeMinimum: String
  codeScale: Int
  codeType: String!
  id: Int!
  internationalize: Boolean!
  "Reads and enables pagination through a set of `LookupValue`."
  lookupValues(
    #Read all values in the set after (below) this cursor.
    after: Cursor
    #Read all values in the set before (above) this cursor.
    before: Cursor
    #A condition to be used in determining which values should be returned by the collection.
    condition: LookupValueCondition
    #A filter to be used in determining which values should be returned by the collection.
    filter: LookupValueFilter
    #Only read the first `n` values of the set.
    first: Int
    #Only read the last `n` values of the set.
    last: Int
    #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
    offset: Int
    #The method to use when ordering `LookupValue`.
    orderBy: [LookupValuesOrderBy!] = [PRIMARY_KEY_ASC]
  ): LookupValuesConnection!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  ordering: String!
  realm: String!
  valueMaximum: String
  valueMinimum: String
  valueScale: Int
  valueType: String!
}

type LookupValue implements Node {
  code: String!
  id: Int!
  "Reads a single `Lookup` that is related to this `LookupValue`."
  lookup: Lookup
  lookupId: Int!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  numericSequencer: BigFloat!
  sequencer: Int!
  stringSequencer: String!
  value: String!
}

"A connection to a list of `LookupValue` values."
type LookupValuesConnection {
  "A list of edges which contains the `LookupValue` and cursor to aid in pagination."
  edges: [LookupValuesEdge!]!
  "A list of `LookupValue` objects."
  nodes: [LookupValue]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `LookupValue` you could get from the connection."
  totalCount: Int!
}

"A `LookupValue` edge in the connection."
type LookupValuesEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `LookupValue` at the end of the edge."
  node: LookupValue
}

"A connection to a list of `Lookup` values."
type LookupsConnection {
  "A list of edges which contains the `Lookup` and cursor to aid in pagination."
  edges: [LookupsEdge!]!
  "A list of `Lookup` objects."
  nodes: [Lookup]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `Lookup` you could get from the connection."
  totalCount: Int!
}

"A `Lookup` edge in the connection."
type LookupsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `Lookup` at the end of the edge."
  node: Lookup
}

type MemberHotelRoomAssignment implements Node {
  "Reads a single `HotelRoomDetail` that is related to this `MemberHotelRoomAssignment`."
  hotelRoom: HotelRoomDetail
  hotelRoomId: BigInt!
  "Reads a single `Membership` that is related to this `MemberHotelRoomAssignment`."
  member: Membership
  memberId: BigInt!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  roomOwner: Boolean!
  year: Int!
}

"A connection to a list of `MemberHotelRoomAssignment` values."
type MemberHotelRoomAssignmentsConnection {
  "A list of edges which contains the `MemberHotelRoomAssignment` and cursor to aid in pagination."
  edges: [MemberHotelRoomAssignmentsEdge!]!
  "A list of `MemberHotelRoomAssignment` objects."
  nodes: [MemberHotelRoomAssignment]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `MemberHotelRoomAssignment` you could get from the connection."
  totalCount: Int!
}

"A `MemberHotelRoomAssignment` edge in the connection."
type MemberHotelRoomAssignmentsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `MemberHotelRoomAssignment` at the end of the edge."
  node: MemberHotelRoomAssignment
}

type Membership implements Node {
  amountOwed: Float!
  amountPaid: Float!
  arrivalDate: Datetime!
  attendance: String!
  attending: Boolean!
  departureDate: Datetime!
  "Reads and enables pagination through a set of `GameAssignment`."
  gameAssignmentsByMemberId(
    #Read all values in the set after (below) this cursor.
    after: Cursor
    #Read all values in the set before (above) this cursor.
    before: Cursor
    #A condition to be used in determining which values should be returned by the collection.
    condition: GameAssignmentCondition
    #A filter to be used in determining which values should be returned by the collection.
    filter: GameAssignmentFilter
    #Only read the first `n` values of the set.
    first: Int
    #Only read the last `n` values of the set.
    last: Int
    #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
    offset: Int
    #The method to use when ordering `GameAssignment`.
    orderBy: [GameAssignmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): GameAssignmentsConnection!
  "Reads and enables pagination through a set of `GameChoice`."
  gameChoicesByMemberId(
    #Read all values in the set after (below) this cursor.
    after: Cursor
    #Read all values in the set before (above) this cursor.
    before: Cursor
    #A condition to be used in determining which values should be returned by the collection.
    condition: GameChoiceCondition
    #A filter to be used in determining which values should be returned by the collection.
    filter: GameChoiceFilter
    #Only read the first `n` values of the set.
    first: Int
    #Only read the last `n` values of the set.
    last: Int
    #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
    offset: Int
    #The method to use when ordering `GameChoice`.
    orderBy: [GameChoicesOrderBy!] = [PRIMARY_KEY_ASC]
  ): GameChoicesConnection!
  "Reads and enables pagination through a set of `GameSubmission`."
  gameSubmissionsByMemberId(
    #Read all values in the set after (below) this cursor.
    after: Cursor
    #Read all values in the set before (above) this cursor.
    before: Cursor
    #A condition to be used in determining which values should be returned by the collection.
    condition: GameSubmissionCondition
    #A filter to be used in determining which values should be returned by the collection.
    filter: GameSubmissionFilter
    #Only read the first `n` values of the set.
    first: Int
    #Only read the last `n` values of the set.
    last: Int
    #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
    offset: Int
    #The method to use when ordering `GameSubmission`.
    orderBy: [GameSubmissionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): GameSubmissionsConnection!
  "Reads a single `HotelRoom` that is related to this `Membership`."
  hotelRoom: HotelRoom
  hotelRoomId: Int!
  id: Int!
  interestLevel: String!
  "Reads and enables pagination through a set of `MemberHotelRoomAssignment`."
  memberHotelRoomAssignmentsByMemberId(
    #Read all values in the set after (below) this cursor.
    after: Cursor
    #Read all values in the set before (above) this cursor.
    before: Cursor
    #A condition to be used in determining which values should be returned by the collection.
    condition: MemberHotelRoomAssignmentCondition
    #A filter to be used in determining which values should be returned by the collection.
    filter: MemberHotelRoomAssignmentFilter
    #Only read the first `n` values of the set.
    first: Int
    #Only read the last `n` values of the set.
    last: Int
    #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
    offset: Int
    #The method to use when ordering `MemberHotelRoomAssignment`.
    orderBy: [MemberHotelRoomAssignmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): MemberHotelRoomAssignmentsConnection!
  message: String!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  offerSubsidy: Boolean!
  requestOldPrice: Boolean!
  roomPreferenceAndNotes: String!
  roomingPreferences: String!
  roomingWith: String!
  "Reads a single `User` that is related to this `Membership`."
  user: User
  userId: Int!
  volunteer: Boolean!
  year: Int!
}

"A connection to a list of `Membership` values."
type MembershipsConnection {
  "A list of edges which contains the `Membership` and cursor to aid in pagination."
  edges: [MembershipsEdge!]!
  "A list of `Membership` objects."
  nodes: [Membership]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `Membership` you could get from the connection."
  totalCount: Int!
}

"A `Membership` edge in the connection."
type MembershipsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `Membership` at the end of the edge."
  node: Membership
}

"The root mutation type which contains root level fields which mutate data."
type Mutation {
  "Creates a single `Game`."
  createGame(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: CreateGameInput!
  ): CreateGamePayload
  "Creates a single `GameAssignment`."
  createGameAssignment(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: CreateGameAssignmentInput!
  ): CreateGameAssignmentPayload
  "Creates a single `GameChoice`."
  createGameChoice(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: CreateGameChoiceInput!
  ): CreateGameChoicePayload
  "Creates a single `GameSubmission`."
  createGameSubmission(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: CreateGameSubmissionInput!
  ): CreateGameSubmissionPayload
  "Creates a single `HotelRoom`."
  createHotelRoom(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: CreateHotelRoomInput!
  ): CreateHotelRoomPayload
  "Creates a single `HotelRoomDetail`."
  createHotelRoomDetail(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: CreateHotelRoomDetailInput!
  ): CreateHotelRoomDetailPayload
  "Creates a single `Lookup`."
  createLookup(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: CreateLookupInput!
  ): CreateLookupPayload
  "Creates a single `LookupValue`."
  createLookupValue(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: CreateLookupValueInput!
  ): CreateLookupValuePayload
  "Creates a single `MemberHotelRoomAssignment`."
  createMemberHotelRoomAssignment(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: CreateMemberHotelRoomAssignmentInput!
  ): CreateMemberHotelRoomAssignmentPayload
  "Creates a single `Membership`."
  createMembership(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: CreateMembershipInput!
  ): CreateMembershipPayload
  "Creates a single `Profile`."
  createProfile(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: CreateProfileInput!
  ): CreateProfilePayload
  "Creates a single `RegistrationCode`."
  createRegistrationCode(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: CreateRegistrationCodeInput!
  ): CreateRegistrationCodePayload
  "Creates a single `Role`."
  createRole(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: CreateRoleInput!
  ): CreateRolePayload
  "Creates a single `Room`."
  createRoom(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: CreateRoomInput!
  ): CreateRoomPayload
  "Creates a single `Setting`."
  createSetting(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: CreateSettingInput!
  ): CreateSettingPayload
  "Creates a single `ShirtOrder`."
  createShirtOrder(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: CreateShirtOrderInput!
  ): CreateShirtOrderPayload
  "Creates a single `ShirtOrderItem`."
  createShirtOrderItem(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: CreateShirtOrderItemInput!
  ): CreateShirtOrderItemPayload
  "Creates a single `Slot`."
  createSlot(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: CreateSlotInput!
  ): CreateSlotPayload
  "Creates a single `Token`."
  createToken(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: CreateTokenInput!
  ): CreateTokenPayload
  "Creates a single `User`."
  createUser(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: CreateUserInput!
  ): CreateUserPayload
  "Creates a single `UserRole`."
  createUserRole(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: CreateUserRoleInput!
  ): CreateUserRolePayload
  "Deletes a single `Game` using a unique key."
  deleteGame(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteGameInput!
  ): DeleteGamePayload
  "Deletes a single `GameAssignment` using a unique key."
  deleteGameAssignment(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteGameAssignmentInput!
  ): DeleteGameAssignmentPayload
  "Deletes a single `GameAssignment` using its globally unique id."
  deleteGameAssignmentByNodeId(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteGameAssignmentByNodeIdInput!
  ): DeleteGameAssignmentPayload
  "Deletes a single `Game` using its globally unique id."
  deleteGameByNodeId(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteGameByNodeIdInput!
  ): DeleteGamePayload
  "Deletes a single `GameChoice` using a unique key."
  deleteGameChoice(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteGameChoiceInput!
  ): DeleteGameChoicePayload
  "Deletes a single `GameChoice` using its globally unique id."
  deleteGameChoiceByNodeId(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteGameChoiceByNodeIdInput!
  ): DeleteGameChoicePayload
  "Deletes a single `GameSubmission` using a unique key."
  deleteGameSubmission(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteGameSubmissionInput!
  ): DeleteGameSubmissionPayload
  "Deletes a single `GameSubmission` using its globally unique id."
  deleteGameSubmissionByNodeId(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteGameSubmissionByNodeIdInput!
  ): DeleteGameSubmissionPayload
  "Deletes a single `HotelRoom` using a unique key."
  deleteHotelRoom(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteHotelRoomInput!
  ): DeleteHotelRoomPayload
  "Deletes a single `HotelRoom` using its globally unique id."
  deleteHotelRoomByNodeId(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteHotelRoomByNodeIdInput!
  ): DeleteHotelRoomPayload
  "Deletes a single `HotelRoomDetail` using a unique key."
  deleteHotelRoomDetail(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteHotelRoomDetailInput!
  ): DeleteHotelRoomDetailPayload
  "Deletes a single `HotelRoomDetail` using its globally unique id."
  deleteHotelRoomDetailByNodeId(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteHotelRoomDetailByNodeIdInput!
  ): DeleteHotelRoomDetailPayload
  "Deletes a single `Lookup` using a unique key."
  deleteLookup(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteLookupInput!
  ): DeleteLookupPayload
  "Deletes a single `Lookup` using its globally unique id."
  deleteLookupByNodeId(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteLookupByNodeIdInput!
  ): DeleteLookupPayload
  "Deletes a single `Lookup` using a unique key."
  deleteLookupByRealm(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteLookupByRealmInput!
  ): DeleteLookupPayload
  "Deletes a single `LookupValue` using a unique key."
  deleteLookupValue(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteLookupValueInput!
  ): DeleteLookupValuePayload
  "Deletes a single `LookupValue` using a unique key."
  deleteLookupValueByLookupIdAndCode(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteLookupValueByLookupIdAndCodeInput!
  ): DeleteLookupValuePayload
  "Deletes a single `LookupValue` using its globally unique id."
  deleteLookupValueByNodeId(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteLookupValueByNodeIdInput!
  ): DeleteLookupValuePayload
  "Deletes a single `MemberHotelRoomAssignment` using a unique key."
  deleteMemberHotelRoomAssignment(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteMemberHotelRoomAssignmentInput!
  ): DeleteMemberHotelRoomAssignmentPayload
  "Deletes a single `MemberHotelRoomAssignment` using its globally unique id."
  deleteMemberHotelRoomAssignmentByNodeId(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteMemberHotelRoomAssignmentByNodeIdInput!
  ): DeleteMemberHotelRoomAssignmentPayload
  "Deletes a single `Membership` using a unique key."
  deleteMembership(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteMembershipInput!
  ): DeleteMembershipPayload
  "Deletes a single `Membership` using its globally unique id."
  deleteMembershipByNodeId(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteMembershipByNodeIdInput!
  ): DeleteMembershipPayload
  "Deletes a single `Profile` using a unique key."
  deleteProfile(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteProfileInput!
  ): DeleteProfilePayload
  "Deletes a single `Profile` using a unique key."
  deleteProfileByEmail(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteProfileByEmailInput!
  ): DeleteProfilePayload
  "Deletes a single `Profile` using its globally unique id."
  deleteProfileByNodeId(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteProfileByNodeIdInput!
  ): DeleteProfilePayload
  "Deletes a single `RegistrationCode` using a unique key."
  deleteRegistrationCode(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteRegistrationCodeInput!
  ): DeleteRegistrationCodePayload
  "Deletes a single `RegistrationCode` using its globally unique id."
  deleteRegistrationCodeByNodeId(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteRegistrationCodeByNodeIdInput!
  ): DeleteRegistrationCodePayload
  "Deletes a single `Role` using a unique key."
  deleteRole(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteRoleInput!
  ): DeleteRolePayload
  "Deletes a single `Role` using a unique key."
  deleteRoleByAuthority(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteRoleByAuthorityInput!
  ): DeleteRolePayload
  "Deletes a single `Role` using its globally unique id."
  deleteRoleByNodeId(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteRoleByNodeIdInput!
  ): DeleteRolePayload
  "Deletes a single `Room` using a unique key."
  deleteRoom(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteRoomInput!
  ): DeleteRoomPayload
  "Deletes a single `Room` using its globally unique id."
  deleteRoomByNodeId(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteRoomByNodeIdInput!
  ): DeleteRoomPayload
  "Deletes a single `Setting` using a unique key."
  deleteSetting(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteSettingInput!
  ): DeleteSettingPayload
  "Deletes a single `Setting` using its globally unique id."
  deleteSettingByNodeId(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteSettingByNodeIdInput!
  ): DeleteSettingPayload
  "Deletes a single `ShirtOrder` using a unique key."
  deleteShirtOrder(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteShirtOrderInput!
  ): DeleteShirtOrderPayload
  "Deletes a single `ShirtOrder` using its globally unique id."
  deleteShirtOrderByNodeId(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteShirtOrderByNodeIdInput!
  ): DeleteShirtOrderPayload
  "Deletes a single `ShirtOrderItem` using a unique key."
  deleteShirtOrderItem(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteShirtOrderItemInput!
  ): DeleteShirtOrderItemPayload
  "Deletes a single `ShirtOrderItem` using its globally unique id."
  deleteShirtOrderItemByNodeId(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteShirtOrderItemByNodeIdInput!
  ): DeleteShirtOrderItemPayload
  "Deletes a single `Slot` using a unique key."
  deleteSlot(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteSlotInput!
  ): DeleteSlotPayload
  "Deletes a single `Slot` using its globally unique id."
  deleteSlotByNodeId(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteSlotByNodeIdInput!
  ): DeleteSlotPayload
  "Deletes a single `Token` using a unique key."
  deleteToken(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteTokenInput!
  ): DeleteTokenPayload
  "Deletes a single `Token` using its globally unique id."
  deleteTokenByNodeId(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteTokenByNodeIdInput!
  ): DeleteTokenPayload
  "Deletes a single `User` using a unique key."
  deleteUser(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteUserInput!
  ): DeleteUserPayload
  "Deletes a single `User` using its globally unique id."
  deleteUserByNodeId(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteUserByNodeIdInput!
  ): DeleteUserPayload
  "Deletes a single `User` using a unique key."
  deleteUserByUsername(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteUserByUsernameInput!
  ): DeleteUserPayload
  "Deletes a single `UserRole` using a unique key."
  deleteUserRole(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteUserRoleInput!
  ): DeleteUserRolePayload
  "Deletes a single `UserRole` using its globally unique id."
  deleteUserRoleByNodeId(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: DeleteUserRoleByNodeIdInput!
  ): DeleteUserRolePayload
  fTruncateTables(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: FTruncateTablesInput!
  ): FTruncateTablesPayload
  "Updates a single `Game` using a unique key and a patch."
  updateGame(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateGameInput!
  ): UpdateGamePayload
  "Updates a single `GameAssignment` using a unique key and a patch."
  updateGameAssignment(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateGameAssignmentInput!
  ): UpdateGameAssignmentPayload
  "Updates a single `GameAssignment` using its globally unique id and a patch."
  updateGameAssignmentByNodeId(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateGameAssignmentByNodeIdInput!
  ): UpdateGameAssignmentPayload
  "Updates a single `Game` using its globally unique id and a patch."
  updateGameByNodeId(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateGameByNodeIdInput!
  ): UpdateGamePayload
  "Updates a single `GameChoice` using a unique key and a patch."
  updateGameChoice(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateGameChoiceInput!
  ): UpdateGameChoicePayload
  "Updates a single `GameChoice` using its globally unique id and a patch."
  updateGameChoiceByNodeId(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateGameChoiceByNodeIdInput!
  ): UpdateGameChoicePayload
  "Updates a single `GameSubmission` using a unique key and a patch."
  updateGameSubmission(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateGameSubmissionInput!
  ): UpdateGameSubmissionPayload
  "Updates a single `GameSubmission` using its globally unique id and a patch."
  updateGameSubmissionByNodeId(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateGameSubmissionByNodeIdInput!
  ): UpdateGameSubmissionPayload
  "Updates a single `HotelRoom` using a unique key and a patch."
  updateHotelRoom(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateHotelRoomInput!
  ): UpdateHotelRoomPayload
  "Updates a single `HotelRoom` using its globally unique id and a patch."
  updateHotelRoomByNodeId(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateHotelRoomByNodeIdInput!
  ): UpdateHotelRoomPayload
  "Updates a single `HotelRoomDetail` using a unique key and a patch."
  updateHotelRoomDetail(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateHotelRoomDetailInput!
  ): UpdateHotelRoomDetailPayload
  "Updates a single `HotelRoomDetail` using its globally unique id and a patch."
  updateHotelRoomDetailByNodeId(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateHotelRoomDetailByNodeIdInput!
  ): UpdateHotelRoomDetailPayload
  "Updates a single `Lookup` using a unique key and a patch."
  updateLookup(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateLookupInput!
  ): UpdateLookupPayload
  "Updates a single `Lookup` using its globally unique id and a patch."
  updateLookupByNodeId(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateLookupByNodeIdInput!
  ): UpdateLookupPayload
  "Updates a single `Lookup` using a unique key and a patch."
  updateLookupByRealm(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateLookupByRealmInput!
  ): UpdateLookupPayload
  "Updates a single `LookupValue` using a unique key and a patch."
  updateLookupValue(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateLookupValueInput!
  ): UpdateLookupValuePayload
  "Updates a single `LookupValue` using a unique key and a patch."
  updateLookupValueByLookupIdAndCode(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateLookupValueByLookupIdAndCodeInput!
  ): UpdateLookupValuePayload
  "Updates a single `LookupValue` using its globally unique id and a patch."
  updateLookupValueByNodeId(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateLookupValueByNodeIdInput!
  ): UpdateLookupValuePayload
  "Updates a single `MemberHotelRoomAssignment` using a unique key and a patch."
  updateMemberHotelRoomAssignment(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateMemberHotelRoomAssignmentInput!
  ): UpdateMemberHotelRoomAssignmentPayload
  "Updates a single `MemberHotelRoomAssignment` using its globally unique id and a patch."
  updateMemberHotelRoomAssignmentByNodeId(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateMemberHotelRoomAssignmentByNodeIdInput!
  ): UpdateMemberHotelRoomAssignmentPayload
  "Updates a single `Membership` using a unique key and a patch."
  updateMembership(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateMembershipInput!
  ): UpdateMembershipPayload
  "Updates a single `Membership` using its globally unique id and a patch."
  updateMembershipByNodeId(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateMembershipByNodeIdInput!
  ): UpdateMembershipPayload
  "Updates a single `Profile` using a unique key and a patch."
  updateProfile(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateProfileInput!
  ): UpdateProfilePayload
  "Updates a single `Profile` using a unique key and a patch."
  updateProfileByEmail(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateProfileByEmailInput!
  ): UpdateProfilePayload
  "Updates a single `Profile` using its globally unique id and a patch."
  updateProfileByNodeId(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateProfileByNodeIdInput!
  ): UpdateProfilePayload
  "Updates a single `RegistrationCode` using a unique key and a patch."
  updateRegistrationCode(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateRegistrationCodeInput!
  ): UpdateRegistrationCodePayload
  "Updates a single `RegistrationCode` using its globally unique id and a patch."
  updateRegistrationCodeByNodeId(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateRegistrationCodeByNodeIdInput!
  ): UpdateRegistrationCodePayload
  "Updates a single `Role` using a unique key and a patch."
  updateRole(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateRoleInput!
  ): UpdateRolePayload
  "Updates a single `Role` using a unique key and a patch."
  updateRoleByAuthority(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateRoleByAuthorityInput!
  ): UpdateRolePayload
  "Updates a single `Role` using its globally unique id and a patch."
  updateRoleByNodeId(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateRoleByNodeIdInput!
  ): UpdateRolePayload
  "Updates a single `Room` using a unique key and a patch."
  updateRoom(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateRoomInput!
  ): UpdateRoomPayload
  "Updates a single `Room` using its globally unique id and a patch."
  updateRoomByNodeId(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateRoomByNodeIdInput!
  ): UpdateRoomPayload
  "Updates a single `Setting` using a unique key and a patch."
  updateSetting(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateSettingInput!
  ): UpdateSettingPayload
  "Updates a single `Setting` using its globally unique id and a patch."
  updateSettingByNodeId(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateSettingByNodeIdInput!
  ): UpdateSettingPayload
  "Updates a single `ShirtOrder` using a unique key and a patch."
  updateShirtOrder(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateShirtOrderInput!
  ): UpdateShirtOrderPayload
  "Updates a single `ShirtOrder` using its globally unique id and a patch."
  updateShirtOrderByNodeId(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateShirtOrderByNodeIdInput!
  ): UpdateShirtOrderPayload
  "Updates a single `ShirtOrderItem` using a unique key and a patch."
  updateShirtOrderItem(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateShirtOrderItemInput!
  ): UpdateShirtOrderItemPayload
  "Updates a single `ShirtOrderItem` using its globally unique id and a patch."
  updateShirtOrderItemByNodeId(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateShirtOrderItemByNodeIdInput!
  ): UpdateShirtOrderItemPayload
  "Updates a single `Slot` using a unique key and a patch."
  updateSlot(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateSlotInput!
  ): UpdateSlotPayload
  "Updates a single `Slot` using its globally unique id and a patch."
  updateSlotByNodeId(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateSlotByNodeIdInput!
  ): UpdateSlotPayload
  "Updates a single `Token` using a unique key and a patch."
  updateToken(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateTokenInput!
  ): UpdateTokenPayload
  "Updates a single `Token` using its globally unique id and a patch."
  updateTokenByNodeId(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateTokenByNodeIdInput!
  ): UpdateTokenPayload
  "Updates a single `User` using a unique key and a patch."
  updateUser(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateUserInput!
  ): UpdateUserPayload
  "Updates a single `User` using its globally unique id and a patch."
  updateUserByNodeId(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateUserByNodeIdInput!
  ): UpdateUserPayload
  "Updates a single `User` using a unique key and a patch."
  updateUserByUsername(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateUserByUsernameInput!
  ): UpdateUserPayload
  "Updates a single `UserRole` using a unique key and a patch."
  updateUserRole(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateUserRoleInput!
  ): UpdateUserRolePayload
  "Updates a single `UserRole` using its globally unique id and a patch."
  updateUserRoleByNodeId(
    #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    input: UpdateUserRoleByNodeIdInput!
  ): UpdateUserRolePayload
}

"Information about pagination in a connection."
type PageInfo {
  "When paginating forwards, the cursor to continue."
  endCursor: Cursor
  "When paginating forwards, are there more items?"
  hasNextPage: Boolean!
  "When paginating backwards, are there more items?"
  hasPreviousPage: Boolean!
  "When paginating backwards, the cursor to continue."
  startCursor: Cursor
}

type Profile implements Node {
  email: String!
  fullName: String!
  id: Int!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  phoneNumber: String
  snailMailAddress: String
  "Reads and enables pagination through a set of `User`."
  users(
    #Read all values in the set after (below) this cursor.
    after: Cursor
    #Read all values in the set before (above) this cursor.
    before: Cursor
    #A condition to be used in determining which values should be returned by the collection.
    condition: UserCondition
    #A filter to be used in determining which values should be returned by the collection.
    filter: UserFilter
    #Only read the first `n` values of the set.
    first: Int
    #Only read the last `n` values of the set.
    last: Int
    #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
    offset: Int
    #The method to use when ordering `User`.
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersConnection!
}

"A connection to a list of `Profile` values."
type ProfilesConnection {
  "A list of edges which contains the `Profile` and cursor to aid in pagination."
  edges: [ProfilesEdge!]!
  "A list of `Profile` objects."
  nodes: [Profile]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `Profile` you could get from the connection."
  totalCount: Int!
}

"A `Profile` edge in the connection."
type ProfilesEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `Profile` at the end of the edge."
  node: Profile
}

"The root query type which gives access points into the data universe."
type Query implements Node {
  game(id: Int!): Game
  gameAssignment(gameId: Int!, gm: Int!, memberId: Int!): GameAssignment
  "Reads a single `GameAssignment` using its globally unique `ID`."
  gameAssignmentByNodeId(
    #The globally unique `ID` to be used in selecting a single `GameAssignment`.
    nodeId: ID!
  ): GameAssignment
  "Reads and enables pagination through a set of `GameAssignment`."
  gameAssignments(
    #Read all values in the set after (below) this cursor.
    after: Cursor
    #Read all values in the set before (above) this cursor.
    before: Cursor
    #A condition to be used in determining which values should be returned by the collection.
    condition: GameAssignmentCondition
    #A filter to be used in determining which values should be returned by the collection.
    filter: GameAssignmentFilter
    #Only read the first `n` values of the set.
    first: Int
    #Only read the last `n` values of the set.
    last: Int
    #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
    offset: Int
    #The method to use when ordering `GameAssignment`.
    orderBy: [GameAssignmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): GameAssignmentsConnection
  "Reads a single `Game` using its globally unique `ID`."
  gameByNodeId(
    #The globally unique `ID` to be used in selecting a single `Game`.
    nodeId: ID!
  ): Game
  gameChoice(id: Int!): GameChoice
  "Reads a single `GameChoice` using its globally unique `ID`."
  gameChoiceByNodeId(
    #The globally unique `ID` to be used in selecting a single `GameChoice`.
    nodeId: ID!
  ): GameChoice
  "Reads and enables pagination through a set of `GameChoice`."
  gameChoices(
    #Read all values in the set after (below) this cursor.
    after: Cursor
    #Read all values in the set before (above) this cursor.
    before: Cursor
    #A condition to be used in determining which values should be returned by the collection.
    condition: GameChoiceCondition
    #A filter to be used in determining which values should be returned by the collection.
    filter: GameChoiceFilter
    #Only read the first `n` values of the set.
    first: Int
    #Only read the last `n` values of the set.
    last: Int
    #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
    offset: Int
    #The method to use when ordering `GameChoice`.
    orderBy: [GameChoicesOrderBy!] = [PRIMARY_KEY_ASC]
  ): GameChoicesConnection
  gameSubmission(id: Int!): GameSubmission
  "Reads a single `GameSubmission` using its globally unique `ID`."
  gameSubmissionByNodeId(
    #The globally unique `ID` to be used in selecting a single `GameSubmission`.
    nodeId: ID!
  ): GameSubmission
  "Reads and enables pagination through a set of `GameSubmission`."
  gameSubmissions(
    #Read all values in the set after (below) this cursor.
    after: Cursor
    #Read all values in the set before (above) this cursor.
    before: Cursor
    #A condition to be used in determining which values should be returned by the collection.
    condition: GameSubmissionCondition
    #A filter to be used in determining which values should be returned by the collection.
    filter: GameSubmissionFilter
    #Only read the first `n` values of the set.
    first: Int
    #Only read the last `n` values of the set.
    last: Int
    #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
    offset: Int
    #The method to use when ordering `GameSubmission`.
    orderBy: [GameSubmissionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): GameSubmissionsConnection
  "Reads and enables pagination through a set of `Game`."
  games(
    #Read all values in the set after (below) this cursor.
    after: Cursor
    #Read all values in the set before (above) this cursor.
    before: Cursor
    #A condition to be used in determining which values should be returned by the collection.
    condition: GameCondition
    #A filter to be used in determining which values should be returned by the collection.
    filter: GameFilter
    #Only read the first `n` values of the set.
    first: Int
    #Only read the last `n` values of the set.
    last: Int
    #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
    offset: Int
    #The method to use when ordering `Game`.
    orderBy: [GamesOrderBy!] = [PRIMARY_KEY_ASC]
  ): GamesConnection
  hotelRoom(id: Int!): HotelRoom
  "Reads a single `HotelRoom` using its globally unique `ID`."
  hotelRoomByNodeId(
    #The globally unique `ID` to be used in selecting a single `HotelRoom`.
    nodeId: ID!
  ): HotelRoom
  hotelRoomDetail(id: BigInt!): HotelRoomDetail
  "Reads a single `HotelRoomDetail` using its globally unique `ID`."
  hotelRoomDetailByNodeId(
    #The globally unique `ID` to be used in selecting a single `HotelRoomDetail`.
    nodeId: ID!
  ): HotelRoomDetail
  "Reads and enables pagination through a set of `HotelRoomDetail`."
  hotelRoomDetails(
    #Read all values in the set after (below) this cursor.
    after: Cursor
    #Read all values in the set before (above) this cursor.
    before: Cursor
    #A condition to be used in determining which values should be returned by the collection.
    condition: HotelRoomDetailCondition
    #A filter to be used in determining which values should be returned by the collection.
    filter: HotelRoomDetailFilter
    #Only read the first `n` values of the set.
    first: Int
    #Only read the last `n` values of the set.
    last: Int
    #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
    offset: Int
    #The method to use when ordering `HotelRoomDetail`.
    orderBy: [HotelRoomDetailsOrderBy!] = [PRIMARY_KEY_ASC]
  ): HotelRoomDetailsConnection
  "Reads and enables pagination through a set of `HotelRoom`."
  hotelRooms(
    #Read all values in the set after (below) this cursor.
    after: Cursor
    #Read all values in the set before (above) this cursor.
    before: Cursor
    #A condition to be used in determining which values should be returned by the collection.
    condition: HotelRoomCondition
    #A filter to be used in determining which values should be returned by the collection.
    filter: HotelRoomFilter
    #Only read the first `n` values of the set.
    first: Int
    #Only read the last `n` values of the set.
    last: Int
    #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
    offset: Int
    #The method to use when ordering `HotelRoom`.
    orderBy: [HotelRoomsOrderBy!] = [PRIMARY_KEY_ASC]
  ): HotelRoomsConnection
  lookup(id: Int!): Lookup
  "Reads a single `Lookup` using its globally unique `ID`."
  lookupByNodeId(
    #The globally unique `ID` to be used in selecting a single `Lookup`.
    nodeId: ID!
  ): Lookup
  lookupByRealm(realm: String!): Lookup
  lookupValue(id: Int!): LookupValue
  lookupValueByLookupIdAndCode(code: String!, lookupId: Int!): LookupValue
  "Reads a single `LookupValue` using its globally unique `ID`."
  lookupValueByNodeId(
    #The globally unique `ID` to be used in selecting a single `LookupValue`.
    nodeId: ID!
  ): LookupValue
  "Reads and enables pagination through a set of `LookupValue`."
  lookupValues(
    #Read all values in the set after (below) this cursor.
    after: Cursor
    #Read all values in the set before (above) this cursor.
    before: Cursor
    #A condition to be used in determining which values should be returned by the collection.
    condition: LookupValueCondition
    #A filter to be used in determining which values should be returned by the collection.
    filter: LookupValueFilter
    #Only read the first `n` values of the set.
    first: Int
    #Only read the last `n` values of the set.
    last: Int
    #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
    offset: Int
    #The method to use when ordering `LookupValue`.
    orderBy: [LookupValuesOrderBy!] = [PRIMARY_KEY_ASC]
  ): LookupValuesConnection
  "Reads and enables pagination through a set of `Lookup`."
  lookups(
    #Read all values in the set after (below) this cursor.
    after: Cursor
    #Read all values in the set before (above) this cursor.
    before: Cursor
    #A condition to be used in determining which values should be returned by the collection.
    condition: LookupCondition
    #A filter to be used in determining which values should be returned by the collection.
    filter: LookupFilter
    #Only read the first `n` values of the set.
    first: Int
    #Only read the last `n` values of the set.
    last: Int
    #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
    offset: Int
    #The method to use when ordering `Lookup`.
    orderBy: [LookupsOrderBy!] = [PRIMARY_KEY_ASC]
  ): LookupsConnection
  memberHotelRoomAssignment(hotelRoomId: BigInt!, memberId: BigInt!): MemberHotelRoomAssignment
  "Reads a single `MemberHotelRoomAssignment` using its globally unique `ID`."
  memberHotelRoomAssignmentByNodeId(
    #The globally unique `ID` to be used in selecting a single `MemberHotelRoomAssignment`.
    nodeId: ID!
  ): MemberHotelRoomAssignment
  "Reads and enables pagination through a set of `MemberHotelRoomAssignment`."
  memberHotelRoomAssignments(
    #Read all values in the set after (below) this cursor.
    after: Cursor
    #Read all values in the set before (above) this cursor.
    before: Cursor
    #A condition to be used in determining which values should be returned by the collection.
    condition: MemberHotelRoomAssignmentCondition
    #A filter to be used in determining which values should be returned by the collection.
    filter: MemberHotelRoomAssignmentFilter
    #Only read the first `n` values of the set.
    first: Int
    #Only read the last `n` values of the set.
    last: Int
    #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
    offset: Int
    #The method to use when ordering `MemberHotelRoomAssignment`.
    orderBy: [MemberHotelRoomAssignmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): MemberHotelRoomAssignmentsConnection
  membership(id: Int!): Membership
  "Reads a single `Membership` using its globally unique `ID`."
  membershipByNodeId(
    #The globally unique `ID` to be used in selecting a single `Membership`.
    nodeId: ID!
  ): Membership
  "Reads and enables pagination through a set of `Membership`."
  memberships(
    #Read all values in the set after (below) this cursor.
    after: Cursor
    #Read all values in the set before (above) this cursor.
    before: Cursor
    #A condition to be used in determining which values should be returned by the collection.
    condition: MembershipCondition
    #A filter to be used in determining which values should be returned by the collection.
    filter: MembershipFilter
    #Only read the first `n` values of the set.
    first: Int
    #Only read the last `n` values of the set.
    last: Int
    #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
    offset: Int
    #The method to use when ordering `Membership`.
    orderBy: [MembershipsOrderBy!] = [PRIMARY_KEY_ASC]
  ): MembershipsConnection
  "Fetches an object given its globally unique `ID`."
  node(
    #The globally unique `ID`.
    nodeId: ID!
  ): Node
  "The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`."
  nodeId: ID!
  profile(id: Int!): Profile
  profileByEmail(email: String!): Profile
  "Reads a single `Profile` using its globally unique `ID`."
  profileByNodeId(
    #The globally unique `ID` to be used in selecting a single `Profile`.
    nodeId: ID!
  ): Profile
  "Reads and enables pagination through a set of `Profile`."
  profiles(
    #Read all values in the set after (below) this cursor.
    after: Cursor
    #Read all values in the set before (above) this cursor.
    before: Cursor
    #A condition to be used in determining which values should be returned by the collection.
    condition: ProfileCondition
    #A filter to be used in determining which values should be returned by the collection.
    filter: ProfileFilter
    #Only read the first `n` values of the set.
    first: Int
    #Only read the last `n` values of the set.
    last: Int
    #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
    offset: Int
    #The method to use when ordering `Profile`.
    orderBy: [ProfilesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProfilesConnection
  "Exposes the root query type nested one level down. This is helpful for Relay 1 which can only query top level fields if they are in a particular form."
  query: Query!
  registrationCode(id: Int!): RegistrationCode
  "Reads a single `RegistrationCode` using its globally unique `ID`."
  registrationCodeByNodeId(
    #The globally unique `ID` to be used in selecting a single `RegistrationCode`.
    nodeId: ID!
  ): RegistrationCode
  "Reads and enables pagination through a set of `RegistrationCode`."
  registrationCodes(
    #Read all values in the set after (below) this cursor.
    after: Cursor
    #Read all values in the set before (above) this cursor.
    before: Cursor
    #A condition to be used in determining which values should be returned by the collection.
    condition: RegistrationCodeCondition
    #A filter to be used in determining which values should be returned by the collection.
    filter: RegistrationCodeFilter
    #Only read the first `n` values of the set.
    first: Int
    #Only read the last `n` values of the set.
    last: Int
    #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
    offset: Int
    #The method to use when ordering `RegistrationCode`.
    orderBy: [RegistrationCodesOrderBy!] = [PRIMARY_KEY_ASC]
  ): RegistrationCodesConnection
  role(id: Int!): Role
  roleByAuthority(authority: String!): Role
  "Reads a single `Role` using its globally unique `ID`."
  roleByNodeId(
    #The globally unique `ID` to be used in selecting a single `Role`.
    nodeId: ID!
  ): Role
  "Reads and enables pagination through a set of `Role`."
  roles(
    #Read all values in the set after (below) this cursor.
    after: Cursor
    #Read all values in the set before (above) this cursor.
    before: Cursor
    #A condition to be used in determining which values should be returned by the collection.
    condition: RoleCondition
    #A filter to be used in determining which values should be returned by the collection.
    filter: RoleFilter
    #Only read the first `n` values of the set.
    first: Int
    #Only read the last `n` values of the set.
    last: Int
    #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
    offset: Int
    #The method to use when ordering `Role`.
    orderBy: [RolesOrderBy!] = [PRIMARY_KEY_ASC]
  ): RolesConnection
  room(id: Int!): Room
  "Reads a single `Room` using its globally unique `ID`."
  roomByNodeId(
    #The globally unique `ID` to be used in selecting a single `Room`.
    nodeId: ID!
  ): Room
  "Reads and enables pagination through a set of `Room`."
  rooms(
    #Read all values in the set after (below) this cursor.
    after: Cursor
    #Read all values in the set before (above) this cursor.
    before: Cursor
    #A condition to be used in determining which values should be returned by the collection.
    condition: RoomCondition
    #A filter to be used in determining which values should be returned by the collection.
    filter: RoomFilter
    #Only read the first `n` values of the set.
    first: Int
    #Only read the last `n` values of the set.
    last: Int
    #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
    offset: Int
    #The method to use when ordering `Room`.
    orderBy: [RoomsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RoomsConnection
  setting(id: Int!): Setting
  "Reads a single `Setting` using its globally unique `ID`."
  settingByNodeId(
    #The globally unique `ID` to be used in selecting a single `Setting`.
    nodeId: ID!
  ): Setting
  "Reads and enables pagination through a set of `Setting`."
  settings(
    #Read all values in the set after (below) this cursor.
    after: Cursor
    #Read all values in the set before (above) this cursor.
    before: Cursor
    #A condition to be used in determining which values should be returned by the collection.
    condition: SettingCondition
    #A filter to be used in determining which values should be returned by the collection.
    filter: SettingFilter
    #Only read the first `n` values of the set.
    first: Int
    #Only read the last `n` values of the set.
    last: Int
    #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
    offset: Int
    #The method to use when ordering `Setting`.
    orderBy: [SettingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SettingsConnection
  shirtOrder(id: Int!): ShirtOrder
  "Reads a single `ShirtOrder` using its globally unique `ID`."
  shirtOrderByNodeId(
    #The globally unique `ID` to be used in selecting a single `ShirtOrder`.
    nodeId: ID!
  ): ShirtOrder
  shirtOrderItem(id: Int!): ShirtOrderItem
  "Reads a single `ShirtOrderItem` using its globally unique `ID`."
  shirtOrderItemByNodeId(
    #The globally unique `ID` to be used in selecting a single `ShirtOrderItem`.
    nodeId: ID!
  ): ShirtOrderItem
  "Reads and enables pagination through a set of `ShirtOrderItem`."
  shirtOrderItems(
    #Read all values in the set after (below) this cursor.
    after: Cursor
    #Read all values in the set before (above) this cursor.
    before: Cursor
    #A condition to be used in determining which values should be returned by the collection.
    condition: ShirtOrderItemCondition
    #A filter to be used in determining which values should be returned by the collection.
    filter: ShirtOrderItemFilter
    #Only read the first `n` values of the set.
    first: Int
    #Only read the last `n` values of the set.
    last: Int
    #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
    offset: Int
    #The method to use when ordering `ShirtOrderItem`.
    orderBy: [ShirtOrderItemsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ShirtOrderItemsConnection
  "Reads and enables pagination through a set of `ShirtOrder`."
  shirtOrders(
    #Read all values in the set after (below) this cursor.
    after: Cursor
    #Read all values in the set before (above) this cursor.
    before: Cursor
    #A condition to be used in determining which values should be returned by the collection.
    condition: ShirtOrderCondition
    #A filter to be used in determining which values should be returned by the collection.
    filter: ShirtOrderFilter
    #Only read the first `n` values of the set.
    first: Int
    #Only read the last `n` values of the set.
    last: Int
    #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
    offset: Int
    #The method to use when ordering `ShirtOrder`.
    orderBy: [ShirtOrdersOrderBy!] = [PRIMARY_KEY_ASC]
  ): ShirtOrdersConnection
  slot(id: Int!): Slot
  "Reads a single `Slot` using its globally unique `ID`."
  slotByNodeId(
    #The globally unique `ID` to be used in selecting a single `Slot`.
    nodeId: ID!
  ): Slot
  "Reads and enables pagination through a set of `Slot`."
  slots(
    #Read all values in the set after (below) this cursor.
    after: Cursor
    #Read all values in the set before (above) this cursor.
    before: Cursor
    #A condition to be used in determining which values should be returned by the collection.
    condition: SlotCondition
    #A filter to be used in determining which values should be returned by the collection.
    filter: SlotFilter
    #Only read the first `n` values of the set.
    first: Int
    #Only read the last `n` values of the set.
    last: Int
    #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
    offset: Int
    #The method to use when ordering `Slot`.
    orderBy: [SlotsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SlotsConnection
  token(id: Int!): Token
  "Reads a single `Token` using its globally unique `ID`."
  tokenByNodeId(
    #The globally unique `ID` to be used in selecting a single `Token`.
    nodeId: ID!
  ): Token
  "Reads and enables pagination through a set of `Token`."
  tokens(
    #Read all values in the set after (below) this cursor.
    after: Cursor
    #Read all values in the set before (above) this cursor.
    before: Cursor
    #A condition to be used in determining which values should be returned by the collection.
    condition: TokenCondition
    #A filter to be used in determining which values should be returned by the collection.
    filter: TokenFilter
    #Only read the first `n` values of the set.
    first: Int
    #Only read the last `n` values of the set.
    last: Int
    #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
    offset: Int
    #The method to use when ordering `Token`.
    orderBy: [TokensOrderBy!] = [PRIMARY_KEY_ASC]
  ): TokensConnection
  user(id: Int!): User
  "Reads a single `User` using its globally unique `ID`."
  userByNodeId(
    #The globally unique `ID` to be used in selecting a single `User`.
    nodeId: ID!
  ): User
  userByUsername(username: String!): User
  userRole(roleId: Int!, userId: Int!): UserRole
  "Reads a single `UserRole` using its globally unique `ID`."
  userRoleByNodeId(
    #The globally unique `ID` to be used in selecting a single `UserRole`.
    nodeId: ID!
  ): UserRole
  "Reads and enables pagination through a set of `UserRole`."
  userRoles(
    #Read all values in the set after (below) this cursor.
    after: Cursor
    #Read all values in the set before (above) this cursor.
    before: Cursor
    #A condition to be used in determining which values should be returned by the collection.
    condition: UserRoleCondition
    #A filter to be used in determining which values should be returned by the collection.
    filter: UserRoleFilter
    #Only read the first `n` values of the set.
    first: Int
    #Only read the last `n` values of the set.
    last: Int
    #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
    offset: Int
    #The method to use when ordering `UserRole`.
    orderBy: [UserRolesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserRolesConnection
  "Reads and enables pagination through a set of `User`."
  users(
    #Read all values in the set after (below) this cursor.
    after: Cursor
    #Read all values in the set before (above) this cursor.
    before: Cursor
    #A condition to be used in determining which values should be returned by the collection.
    condition: UserCondition
    #A filter to be used in determining which values should be returned by the collection.
    filter: UserFilter
    #Only read the first `n` values of the set.
    first: Int
    #Only read the last `n` values of the set.
    last: Int
    #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
    offset: Int
    #The method to use when ordering `User`.
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersConnection
}

type RegistrationCode implements Node {
  id: Int!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  token: String!
  username: String!
}

"A connection to a list of `RegistrationCode` values."
type RegistrationCodesConnection {
  "A list of edges which contains the `RegistrationCode` and cursor to aid in pagination."
  edges: [RegistrationCodesEdge!]!
  "A list of `RegistrationCode` objects."
  nodes: [RegistrationCode]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `RegistrationCode` you could get from the connection."
  totalCount: Int!
}

"A `RegistrationCode` edge in the connection."
type RegistrationCodesEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `RegistrationCode` at the end of the edge."
  node: RegistrationCode
}

type Role implements Node {
  authority: String!
  id: Int!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  "Reads and enables pagination through a set of `UserRole`."
  userRoles(
    #Read all values in the set after (below) this cursor.
    after: Cursor
    #Read all values in the set before (above) this cursor.
    before: Cursor
    #A condition to be used in determining which values should be returned by the collection.
    condition: UserRoleCondition
    #A filter to be used in determining which values should be returned by the collection.
    filter: UserRoleFilter
    #Only read the first `n` values of the set.
    first: Int
    #Only read the last `n` values of the set.
    last: Int
    #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
    offset: Int
    #The method to use when ordering `UserRole`.
    orderBy: [UserRolesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserRolesConnection!
}

"A connection to a list of `Role` values."
type RolesConnection {
  "A list of edges which contains the `Role` and cursor to aid in pagination."
  edges: [RolesEdge!]!
  "A list of `Role` objects."
  nodes: [Role]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `Role` you could get from the connection."
  totalCount: Int!
}

"A `Role` edge in the connection."
type RolesEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `Role` at the end of the edge."
  node: Role
}

type Room implements Node {
  description: String!
  "Reads and enables pagination through a set of `Game`."
  games(
    #Read all values in the set after (below) this cursor.
    after: Cursor
    #Read all values in the set before (above) this cursor.
    before: Cursor
    #A condition to be used in determining which values should be returned by the collection.
    condition: GameCondition
    #A filter to be used in determining which values should be returned by the collection.
    filter: GameFilter
    #Only read the first `n` values of the set.
    first: Int
    #Only read the last `n` values of the set.
    last: Int
    #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
    offset: Int
    #The method to use when ordering `Game`.
    orderBy: [GamesOrderBy!] = [PRIMARY_KEY_ASC]
  ): GamesConnection!
  id: Int!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  size: Int!
  type: String!
  updated: Boolean!
}

"A connection to a list of `Room` values."
type RoomsConnection {
  "A list of edges which contains the `Room` and cursor to aid in pagination."
  edges: [RoomsEdge!]!
  "A list of `Room` objects."
  nodes: [Room]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `Room` you could get from the connection."
  totalCount: Int!
}

"A `Room` edge in the connection."
type RoomsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `Room` at the end of the edge."
  node: Room
}

type Setting implements Node {
  code: String!
  id: Int!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  type: String!
  value: String!
}

"A connection to a list of `Setting` values."
type SettingsConnection {
  "A list of edges which contains the `Setting` and cursor to aid in pagination."
  edges: [SettingsEdge!]!
  "A list of `Setting` objects."
  nodes: [Setting]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `Setting` you could get from the connection."
  totalCount: Int!
}

"A `Setting` edge in the connection."
type SettingsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `Setting` at the end of the edge."
  node: Setting
}

type ShirtOrder implements Node {
  deliveryMethod: String!
  id: Int!
  message: String!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  "Reads and enables pagination through a set of `ShirtOrderItem`."
  shirtOrderItemsByOrderId(
    #Read all values in the set after (below) this cursor.
    after: Cursor
    #Read all values in the set before (above) this cursor.
    before: Cursor
    #A condition to be used in determining which values should be returned by the collection.
    condition: ShirtOrderItemCondition
    #A filter to be used in determining which values should be returned by the collection.
    filter: ShirtOrderItemFilter
    #Only read the first `n` values of the set.
    first: Int
    #Only read the last `n` values of the set.
    last: Int
    #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
    offset: Int
    #The method to use when ordering `ShirtOrderItem`.
    orderBy: [ShirtOrderItemsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ShirtOrderItemsConnection!
  "Reads a single `User` that is related to this `ShirtOrder`."
  user: User
  userId: Int!
  year: Int!
}

type ShirtOrderItem implements Node {
  id: Int!
  itemsIdx: Int
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  "Reads a single `ShirtOrder` that is related to this `ShirtOrderItem`."
  order: ShirtOrder
  orderId: Int!
  quantity: Int!
  size: String!
  style: String!
}

"A connection to a list of `ShirtOrderItem` values."
type ShirtOrderItemsConnection {
  "A list of edges which contains the `ShirtOrderItem` and cursor to aid in pagination."
  edges: [ShirtOrderItemsEdge!]!
  "A list of `ShirtOrderItem` objects."
  nodes: [ShirtOrderItem]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `ShirtOrderItem` you could get from the connection."
  totalCount: Int!
}

"A `ShirtOrderItem` edge in the connection."
type ShirtOrderItemsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `ShirtOrderItem` at the end of the edge."
  node: ShirtOrderItem
}

"A connection to a list of `ShirtOrder` values."
type ShirtOrdersConnection {
  "A list of edges which contains the `ShirtOrder` and cursor to aid in pagination."
  edges: [ShirtOrdersEdge!]!
  "A list of `ShirtOrder` objects."
  nodes: [ShirtOrder]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `ShirtOrder` you could get from the connection."
  totalCount: Int!
}

"A `ShirtOrder` edge in the connection."
type ShirtOrdersEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `ShirtOrder` at the end of the edge."
  node: ShirtOrder
}

type Slot implements Node {
  day: String!
  formattedDate: String!
  "Reads and enables pagination through a set of `GameChoice`."
  gameChoices(
    #Read all values in the set after (below) this cursor.
    after: Cursor
    #Read all values in the set before (above) this cursor.
    before: Cursor
    #A condition to be used in determining which values should be returned by the collection.
    condition: GameChoiceCondition
    #A filter to be used in determining which values should be returned by the collection.
    filter: GameChoiceFilter
    #Only read the first `n` values of the set.
    first: Int
    #Only read the last `n` values of the set.
    last: Int
    #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
    offset: Int
    #The method to use when ordering `GameChoice`.
    orderBy: [GameChoicesOrderBy!] = [PRIMARY_KEY_ASC]
  ): GameChoicesConnection!
  "Reads and enables pagination through a set of `Game`."
  games(
    #Read all values in the set after (below) this cursor.
    after: Cursor
    #Read all values in the set before (above) this cursor.
    before: Cursor
    #A condition to be used in determining which values should be returned by the collection.
    condition: GameCondition
    #A filter to be used in determining which values should be returned by the collection.
    filter: GameFilter
    #Only read the first `n` values of the set.
    first: Int
    #Only read the last `n` values of the set.
    last: Int
    #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
    offset: Int
    #The method to use when ordering `Game`.
    orderBy: [GamesOrderBy!] = [PRIMARY_KEY_ASC]
  ): GamesConnection!
  id: Int!
  length: String!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  slot: Int!
  time: String!
}

"A connection to a list of `Slot` values."
type SlotsConnection {
  "A list of edges which contains the `Slot` and cursor to aid in pagination."
  edges: [SlotsEdge!]!
  "A list of `Slot` objects."
  nodes: [Slot]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `Slot` you could get from the connection."
  totalCount: Int!
}

"A `Slot` edge in the connection."
type SlotsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `Slot` at the end of the edge."
  node: Slot
}

type Token implements Node {
  active: Boolean
  cuid: String
  id: Int!
  lastUsed: Datetime
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  "Reads a single `User` that is related to this `Token`."
  user: User
  userId: Int!
}

"A connection to a list of `Token` values."
type TokensConnection {
  "A list of edges which contains the `Token` and cursor to aid in pagination."
  edges: [TokensEdge!]!
  "A list of `Token` objects."
  nodes: [Token]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `Token` you could get from the connection."
  totalCount: Int!
}

"A `Token` edge in the connection."
type TokensEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `Token` at the end of the edge."
  node: Token
}

"The output of our update `GameAssignment` mutation."
type UpdateGameAssignmentPayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "Reads a single `Game` that is related to this `GameAssignment`."
  game: Game
  "The `GameAssignment` that was updated by this mutation."
  gameAssignment: GameAssignment
  "An edge for our `GameAssignment`. May be used by Relay 1."
  gameAssignmentEdge(
    #The method to use when ordering `GameAssignment`.
    orderBy: [GameAssignmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): GameAssignmentsEdge
  "Reads a single `Membership` that is related to this `GameAssignment`."
  member: Membership
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our update `GameChoice` mutation."
type UpdateGameChoicePayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "Reads a single `Game` that is related to this `GameChoice`."
  game: Game
  "The `GameChoice` that was updated by this mutation."
  gameChoice: GameChoice
  "An edge for our `GameChoice`. May be used by Relay 1."
  gameChoiceEdge(
    #The method to use when ordering `GameChoice`.
    orderBy: [GameChoicesOrderBy!] = [PRIMARY_KEY_ASC]
  ): GameChoicesEdge
  "Reads a single `Membership` that is related to this `GameChoice`."
  member: Membership
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "Reads a single `Slot` that is related to this `GameChoice`."
  slot: Slot
}

"The output of our update `Game` mutation."
type UpdateGamePayload {
  "Reads a single `User` that is related to this `Game`."
  author: User
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `Game` that was updated by this mutation."
  game: Game
  "An edge for our `Game`. May be used by Relay 1."
  gameEdge(
    #The method to use when ordering `Game`.
    orderBy: [GamesOrderBy!] = [PRIMARY_KEY_ASC]
  ): GamesEdge
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "Reads a single `Room` that is related to this `Game`."
  room: Room
  "Reads a single `Slot` that is related to this `Game`."
  slot: Slot
}

"The output of our update `GameSubmission` mutation."
type UpdateGameSubmissionPayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `GameSubmission` that was updated by this mutation."
  gameSubmission: GameSubmission
  "An edge for our `GameSubmission`. May be used by Relay 1."
  gameSubmissionEdge(
    #The method to use when ordering `GameSubmission`.
    orderBy: [GameSubmissionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): GameSubmissionsEdge
  "Reads a single `Membership` that is related to this `GameSubmission`."
  member: Membership
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our update `HotelRoomDetail` mutation."
type UpdateHotelRoomDetailPayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `HotelRoomDetail` that was updated by this mutation."
  hotelRoomDetail: HotelRoomDetail
  "An edge for our `HotelRoomDetail`. May be used by Relay 1."
  hotelRoomDetailEdge(
    #The method to use when ordering `HotelRoomDetail`.
    orderBy: [HotelRoomDetailsOrderBy!] = [PRIMARY_KEY_ASC]
  ): HotelRoomDetailsEdge
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our update `HotelRoom` mutation."
type UpdateHotelRoomPayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `HotelRoom` that was updated by this mutation."
  hotelRoom: HotelRoom
  "An edge for our `HotelRoom`. May be used by Relay 1."
  hotelRoomEdge(
    #The method to use when ordering `HotelRoom`.
    orderBy: [HotelRoomsOrderBy!] = [PRIMARY_KEY_ASC]
  ): HotelRoomsEdge
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our update `Lookup` mutation."
type UpdateLookupPayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `Lookup` that was updated by this mutation."
  lookup: Lookup
  "An edge for our `Lookup`. May be used by Relay 1."
  lookupEdge(
    #The method to use when ordering `Lookup`.
    orderBy: [LookupsOrderBy!] = [PRIMARY_KEY_ASC]
  ): LookupsEdge
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our update `LookupValue` mutation."
type UpdateLookupValuePayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "Reads a single `Lookup` that is related to this `LookupValue`."
  lookup: Lookup
  "The `LookupValue` that was updated by this mutation."
  lookupValue: LookupValue
  "An edge for our `LookupValue`. May be used by Relay 1."
  lookupValueEdge(
    #The method to use when ordering `LookupValue`.
    orderBy: [LookupValuesOrderBy!] = [PRIMARY_KEY_ASC]
  ): LookupValuesEdge
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our update `MemberHotelRoomAssignment` mutation."
type UpdateMemberHotelRoomAssignmentPayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "Reads a single `HotelRoomDetail` that is related to this `MemberHotelRoomAssignment`."
  hotelRoom: HotelRoomDetail
  "Reads a single `Membership` that is related to this `MemberHotelRoomAssignment`."
  member: Membership
  "The `MemberHotelRoomAssignment` that was updated by this mutation."
  memberHotelRoomAssignment: MemberHotelRoomAssignment
  "An edge for our `MemberHotelRoomAssignment`. May be used by Relay 1."
  memberHotelRoomAssignmentEdge(
    #The method to use when ordering `MemberHotelRoomAssignment`.
    orderBy: [MemberHotelRoomAssignmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): MemberHotelRoomAssignmentsEdge
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our update `Membership` mutation."
type UpdateMembershipPayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "Reads a single `HotelRoom` that is related to this `Membership`."
  hotelRoom: HotelRoom
  "The `Membership` that was updated by this mutation."
  membership: Membership
  "An edge for our `Membership`. May be used by Relay 1."
  membershipEdge(
    #The method to use when ordering `Membership`.
    orderBy: [MembershipsOrderBy!] = [PRIMARY_KEY_ASC]
  ): MembershipsEdge
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "Reads a single `User` that is related to this `Membership`."
  user: User
}

"The output of our update `Profile` mutation."
type UpdateProfilePayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "The `Profile` that was updated by this mutation."
  profile: Profile
  "An edge for our `Profile`. May be used by Relay 1."
  profileEdge(
    #The method to use when ordering `Profile`.
    orderBy: [ProfilesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProfilesEdge
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our update `RegistrationCode` mutation."
type UpdateRegistrationCodePayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `RegistrationCode` that was updated by this mutation."
  registrationCode: RegistrationCode
  "An edge for our `RegistrationCode`. May be used by Relay 1."
  registrationCodeEdge(
    #The method to use when ordering `RegistrationCode`.
    orderBy: [RegistrationCodesOrderBy!] = [PRIMARY_KEY_ASC]
  ): RegistrationCodesEdge
}

"The output of our update `Role` mutation."
type UpdateRolePayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `Role` that was updated by this mutation."
  role: Role
  "An edge for our `Role`. May be used by Relay 1."
  roleEdge(
    #The method to use when ordering `Role`.
    orderBy: [RolesOrderBy!] = [PRIMARY_KEY_ASC]
  ): RolesEdge
}

"The output of our update `Room` mutation."
type UpdateRoomPayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `Room` that was updated by this mutation."
  room: Room
  "An edge for our `Room`. May be used by Relay 1."
  roomEdge(
    #The method to use when ordering `Room`.
    orderBy: [RoomsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RoomsEdge
}

"The output of our update `Setting` mutation."
type UpdateSettingPayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `Setting` that was updated by this mutation."
  setting: Setting
  "An edge for our `Setting`. May be used by Relay 1."
  settingEdge(
    #The method to use when ordering `Setting`.
    orderBy: [SettingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SettingsEdge
}

"The output of our update `ShirtOrderItem` mutation."
type UpdateShirtOrderItemPayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "Reads a single `ShirtOrder` that is related to this `ShirtOrderItem`."
  order: ShirtOrder
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `ShirtOrderItem` that was updated by this mutation."
  shirtOrderItem: ShirtOrderItem
  "An edge for our `ShirtOrderItem`. May be used by Relay 1."
  shirtOrderItemEdge(
    #The method to use when ordering `ShirtOrderItem`.
    orderBy: [ShirtOrderItemsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ShirtOrderItemsEdge
}

"The output of our update `ShirtOrder` mutation."
type UpdateShirtOrderPayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `ShirtOrder` that was updated by this mutation."
  shirtOrder: ShirtOrder
  "An edge for our `ShirtOrder`. May be used by Relay 1."
  shirtOrderEdge(
    #The method to use when ordering `ShirtOrder`.
    orderBy: [ShirtOrdersOrderBy!] = [PRIMARY_KEY_ASC]
  ): ShirtOrdersEdge
  "Reads a single `User` that is related to this `ShirtOrder`."
  user: User
}

"The output of our update `Slot` mutation."
type UpdateSlotPayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `Slot` that was updated by this mutation."
  slot: Slot
  "An edge for our `Slot`. May be used by Relay 1."
  slotEdge(
    #The method to use when ordering `Slot`.
    orderBy: [SlotsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SlotsEdge
}

"The output of our update `Token` mutation."
type UpdateTokenPayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `Token` that was updated by this mutation."
  token: Token
  "An edge for our `Token`. May be used by Relay 1."
  tokenEdge(
    #The method to use when ordering `Token`.
    orderBy: [TokensOrderBy!] = [PRIMARY_KEY_ASC]
  ): TokensEdge
  "Reads a single `User` that is related to this `Token`."
  user: User
}

"The output of our update `User` mutation."
type UpdateUserPayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "Reads a single `Profile` that is related to this `User`."
  profile: Profile
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `User` that was updated by this mutation."
  user: User
  "An edge for our `User`. May be used by Relay 1."
  userEdge(
    #The method to use when ordering `User`.
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

"The output of our update `UserRole` mutation."
type UpdateUserRolePayload {
  "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "Reads a single `Role` that is related to this `UserRole`."
  role: Role
  "Reads a single `User` that is related to this `UserRole`."
  user: User
  "The `UserRole` that was updated by this mutation."
  userRole: UserRole
  "An edge for our `UserRole`. May be used by Relay 1."
  userRoleEdge(
    #The method to use when ordering `UserRole`.
    orderBy: [UserRolesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserRolesEdge
}

type User implements Node {
  accountLocked: Boolean!
  "Reads and enables pagination through a set of `Game`."
  authoredGames(
    #Read all values in the set after (below) this cursor.
    after: Cursor
    #Read all values in the set before (above) this cursor.
    before: Cursor
    #A condition to be used in determining which values should be returned by the collection.
    condition: GameCondition
    #A filter to be used in determining which values should be returned by the collection.
    filter: GameFilter
    #Only read the first `n` values of the set.
    first: Int
    #Only read the last `n` values of the set.
    last: Int
    #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
    offset: Int
    #The method to use when ordering `Game`.
    orderBy: [GamesOrderBy!] = [PRIMARY_KEY_ASC]
  ): GamesConnection!
  enabled: Boolean!
  id: Int!
  "Reads and enables pagination through a set of `Membership`."
  memberships(
    #Read all values in the set after (below) this cursor.
    after: Cursor
    #Read all values in the set before (above) this cursor.
    before: Cursor
    #A condition to be used in determining which values should be returned by the collection.
    condition: MembershipCondition
    #A filter to be used in determining which values should be returned by the collection.
    filter: MembershipFilter
    #Only read the first `n` values of the set.
    first: Int
    #Only read the last `n` values of the set.
    last: Int
    #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
    offset: Int
    #The method to use when ordering `Membership`.
    orderBy: [MembershipsOrderBy!] = [PRIMARY_KEY_ASC]
  ): MembershipsConnection!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  password: String!
  "Reads a single `Profile` that is related to this `User`."
  profile: Profile
  profileId: Int!
  "Reads and enables pagination through a set of `ShirtOrder`."
  shirtOrders(
    #Read all values in the set after (below) this cursor.
    after: Cursor
    #Read all values in the set before (above) this cursor.
    before: Cursor
    #A condition to be used in determining which values should be returned by the collection.
    condition: ShirtOrderCondition
    #A filter to be used in determining which values should be returned by the collection.
    filter: ShirtOrderFilter
    #Only read the first `n` values of the set.
    first: Int
    #Only read the last `n` values of the set.
    last: Int
    #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
    offset: Int
    #The method to use when ordering `ShirtOrder`.
    orderBy: [ShirtOrdersOrderBy!] = [PRIMARY_KEY_ASC]
  ): ShirtOrdersConnection!
  "Reads and enables pagination through a set of `Token`."
  tokens(
    #Read all values in the set after (below) this cursor.
    after: Cursor
    #Read all values in the set before (above) this cursor.
    before: Cursor
    #A condition to be used in determining which values should be returned by the collection.
    condition: TokenCondition
    #A filter to be used in determining which values should be returned by the collection.
    filter: TokenFilter
    #Only read the first `n` values of the set.
    first: Int
    #Only read the last `n` values of the set.
    last: Int
    #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
    offset: Int
    #The method to use when ordering `Token`.
    orderBy: [TokensOrderBy!] = [PRIMARY_KEY_ASC]
  ): TokensConnection!
  "Reads and enables pagination through a set of `UserRole`."
  userRoles(
    #Read all values in the set after (below) this cursor.
    after: Cursor
    #Read all values in the set before (above) this cursor.
    before: Cursor
    #A condition to be used in determining which values should be returned by the collection.
    condition: UserRoleCondition
    #A filter to be used in determining which values should be returned by the collection.
    filter: UserRoleFilter
    #Only read the first `n` values of the set.
    first: Int
    #Only read the last `n` values of the set.
    last: Int
    #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
    offset: Int
    #The method to use when ordering `UserRole`.
    orderBy: [UserRolesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserRolesConnection!
  username: String!
}

type UserRole implements Node {
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  "Reads a single `Role` that is related to this `UserRole`."
  role: Role
  roleId: Int!
  "Reads a single `User` that is related to this `UserRole`."
  user: User
  userId: Int!
}

"A connection to a list of `UserRole` values."
type UserRolesConnection {
  "A list of edges which contains the `UserRole` and cursor to aid in pagination."
  edges: [UserRolesEdge!]!
  "A list of `UserRole` objects."
  nodes: [UserRole]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `UserRole` you could get from the connection."
  totalCount: Int!
}

"A `UserRole` edge in the connection."
type UserRolesEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `UserRole` at the end of the edge."
  node: UserRole
}

"A connection to a list of `User` values."
type UsersConnection {
  "A list of edges which contains the `User` and cursor to aid in pagination."
  edges: [UsersEdge!]!
  "A list of `User` objects."
  nodes: [User]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `User` you could get from the connection."
  totalCount: Int!
}

"A `User` edge in the connection."
type UsersEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `User` at the end of the edge."
  node: User
}

"Methods to use when ordering `GameAssignment`."
enum GameAssignmentsOrderBy {
  GAME_BY_GAME_ID__AUTHOR_ID_ASC
  GAME_BY_GAME_ID__AUTHOR_ID_DESC
  GAME_BY_GAME_ID__CHAR_INSTRUCTIONS_ASC
  GAME_BY_GAME_ID__CHAR_INSTRUCTIONS_DESC
  GAME_BY_GAME_ID__DESCRIPTION_ASC
  GAME_BY_GAME_ID__DESCRIPTION_DESC
  GAME_BY_GAME_ID__ESTIMATED_LENGTH_ASC
  GAME_BY_GAME_ID__ESTIMATED_LENGTH_DESC
  GAME_BY_GAME_ID__GAME_CONTACT_EMAIL_ASC
  GAME_BY_GAME_ID__GAME_CONTACT_EMAIL_DESC
  GAME_BY_GAME_ID__GENRE_ASC
  GAME_BY_GAME_ID__GENRE_DESC
  GAME_BY_GAME_ID__GM_NAMES_ASC
  GAME_BY_GAME_ID__GM_NAMES_DESC
  GAME_BY_GAME_ID__ID_ASC
  GAME_BY_GAME_ID__ID_DESC
  GAME_BY_GAME_ID__LATE_FINISH_ASC
  GAME_BY_GAME_ID__LATE_FINISH_DESC
  GAME_BY_GAME_ID__LATE_START_ASC
  GAME_BY_GAME_ID__LATE_START_DESC
  GAME_BY_GAME_ID__MESSAGE_ASC
  GAME_BY_GAME_ID__MESSAGE_DESC
  GAME_BY_GAME_ID__NAME_ASC
  GAME_BY_GAME_ID__NAME_DESC
  GAME_BY_GAME_ID__PLAYERS_CONTACT_GM_ASC
  GAME_BY_GAME_ID__PLAYERS_CONTACT_GM_DESC
  GAME_BY_GAME_ID__PLAYER_MAX_ASC
  GAME_BY_GAME_ID__PLAYER_MAX_DESC
  GAME_BY_GAME_ID__PLAYER_MIN_ASC
  GAME_BY_GAME_ID__PLAYER_MIN_DESC
  GAME_BY_GAME_ID__PLAYER_PREFERENCE_ASC
  GAME_BY_GAME_ID__PLAYER_PREFERENCE_DESC
  GAME_BY_GAME_ID__RETURNING_PLAYERS_ASC
  GAME_BY_GAME_ID__RETURNING_PLAYERS_DESC
  GAME_BY_GAME_ID__ROOM_ID_ASC
  GAME_BY_GAME_ID__ROOM_ID_DESC
  GAME_BY_GAME_ID__SETTING_ASC
  GAME_BY_GAME_ID__SETTING_DESC
  GAME_BY_GAME_ID__SHORT_NAME_ASC
  GAME_BY_GAME_ID__SHORT_NAME_DESC
  GAME_BY_GAME_ID__SLOT_CONFLICTS_ASC
  GAME_BY_GAME_ID__SLOT_CONFLICTS_DESC
  GAME_BY_GAME_ID__SLOT_ID_ASC
  GAME_BY_GAME_ID__SLOT_ID_DESC
  GAME_BY_GAME_ID__SLOT_PREFERENCE_ASC
  GAME_BY_GAME_ID__SLOT_PREFERENCE_DESC
  GAME_BY_GAME_ID__TEEN_FRIENDLY_ASC
  GAME_BY_GAME_ID__TEEN_FRIENDLY_DESC
  GAME_BY_GAME_ID__TYPE_ASC
  GAME_BY_GAME_ID__TYPE_DESC
  GAME_BY_GAME_ID__YEAR_ASC
  GAME_BY_GAME_ID__YEAR_DESC
  GAME_ID_ASC
  GAME_ID_DESC
  GM_ASC
  GM_DESC
  MEMBERSHIP_BY_MEMBER_ID__AMOUNT_OWED_ASC
  MEMBERSHIP_BY_MEMBER_ID__AMOUNT_OWED_DESC
  MEMBERSHIP_BY_MEMBER_ID__AMOUNT_PAID_ASC
  MEMBERSHIP_BY_MEMBER_ID__AMOUNT_PAID_DESC
  MEMBERSHIP_BY_MEMBER_ID__ARRIVAL_DATE_ASC
  MEMBERSHIP_BY_MEMBER_ID__ARRIVAL_DATE_DESC
  MEMBERSHIP_BY_MEMBER_ID__ATTENDANCE_ASC
  MEMBERSHIP_BY_MEMBER_ID__ATTENDANCE_DESC
  MEMBERSHIP_BY_MEMBER_ID__ATTENDING_ASC
  MEMBERSHIP_BY_MEMBER_ID__ATTENDING_DESC
  MEMBERSHIP_BY_MEMBER_ID__DEPARTURE_DATE_ASC
  MEMBERSHIP_BY_MEMBER_ID__DEPARTURE_DATE_DESC
  MEMBERSHIP_BY_MEMBER_ID__HOTEL_ROOM_ID_ASC
  MEMBERSHIP_BY_MEMBER_ID__HOTEL_ROOM_ID_DESC
  MEMBERSHIP_BY_MEMBER_ID__ID_ASC
  MEMBERSHIP_BY_MEMBER_ID__ID_DESC
  MEMBERSHIP_BY_MEMBER_ID__INTEREST_LEVEL_ASC
  MEMBERSHIP_BY_MEMBER_ID__INTEREST_LEVEL_DESC
  MEMBERSHIP_BY_MEMBER_ID__MESSAGE_ASC
  MEMBERSHIP_BY_MEMBER_ID__MESSAGE_DESC
  MEMBERSHIP_BY_MEMBER_ID__OFFER_SUBSIDY_ASC
  MEMBERSHIP_BY_MEMBER_ID__OFFER_SUBSIDY_DESC
  MEMBERSHIP_BY_MEMBER_ID__REQUEST_OLD_PRICE_ASC
  MEMBERSHIP_BY_MEMBER_ID__REQUEST_OLD_PRICE_DESC
  MEMBERSHIP_BY_MEMBER_ID__ROOMING_PREFERENCES_ASC
  MEMBERSHIP_BY_MEMBER_ID__ROOMING_PREFERENCES_DESC
  MEMBERSHIP_BY_MEMBER_ID__ROOMING_WITH_ASC
  MEMBERSHIP_BY_MEMBER_ID__ROOMING_WITH_DESC
  MEMBERSHIP_BY_MEMBER_ID__ROOM_PREFERENCE_AND_NOTES_ASC
  MEMBERSHIP_BY_MEMBER_ID__ROOM_PREFERENCE_AND_NOTES_DESC
  MEMBERSHIP_BY_MEMBER_ID__USER_ID_ASC
  MEMBERSHIP_BY_MEMBER_ID__USER_ID_DESC
  MEMBERSHIP_BY_MEMBER_ID__VOLUNTEER_ASC
  MEMBERSHIP_BY_MEMBER_ID__VOLUNTEER_DESC
  MEMBERSHIP_BY_MEMBER_ID__YEAR_ASC
  MEMBERSHIP_BY_MEMBER_ID__YEAR_DESC
  MEMBER_ID_ASC
  MEMBER_ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  YEAR_ASC
  YEAR_DESC
}

"Methods to use when ordering `GameChoice`."
enum GameChoicesOrderBy {
  GAME_BY_GAME_ID__AUTHOR_ID_ASC
  GAME_BY_GAME_ID__AUTHOR_ID_DESC
  GAME_BY_GAME_ID__CHAR_INSTRUCTIONS_ASC
  GAME_BY_GAME_ID__CHAR_INSTRUCTIONS_DESC
  GAME_BY_GAME_ID__DESCRIPTION_ASC
  GAME_BY_GAME_ID__DESCRIPTION_DESC
  GAME_BY_GAME_ID__ESTIMATED_LENGTH_ASC
  GAME_BY_GAME_ID__ESTIMATED_LENGTH_DESC
  GAME_BY_GAME_ID__GAME_CONTACT_EMAIL_ASC
  GAME_BY_GAME_ID__GAME_CONTACT_EMAIL_DESC
  GAME_BY_GAME_ID__GENRE_ASC
  GAME_BY_GAME_ID__GENRE_DESC
  GAME_BY_GAME_ID__GM_NAMES_ASC
  GAME_BY_GAME_ID__GM_NAMES_DESC
  GAME_BY_GAME_ID__ID_ASC
  GAME_BY_GAME_ID__ID_DESC
  GAME_BY_GAME_ID__LATE_FINISH_ASC
  GAME_BY_GAME_ID__LATE_FINISH_DESC
  GAME_BY_GAME_ID__LATE_START_ASC
  GAME_BY_GAME_ID__LATE_START_DESC
  GAME_BY_GAME_ID__MESSAGE_ASC
  GAME_BY_GAME_ID__MESSAGE_DESC
  GAME_BY_GAME_ID__NAME_ASC
  GAME_BY_GAME_ID__NAME_DESC
  GAME_BY_GAME_ID__PLAYERS_CONTACT_GM_ASC
  GAME_BY_GAME_ID__PLAYERS_CONTACT_GM_DESC
  GAME_BY_GAME_ID__PLAYER_MAX_ASC
  GAME_BY_GAME_ID__PLAYER_MAX_DESC
  GAME_BY_GAME_ID__PLAYER_MIN_ASC
  GAME_BY_GAME_ID__PLAYER_MIN_DESC
  GAME_BY_GAME_ID__PLAYER_PREFERENCE_ASC
  GAME_BY_GAME_ID__PLAYER_PREFERENCE_DESC
  GAME_BY_GAME_ID__RETURNING_PLAYERS_ASC
  GAME_BY_GAME_ID__RETURNING_PLAYERS_DESC
  GAME_BY_GAME_ID__ROOM_ID_ASC
  GAME_BY_GAME_ID__ROOM_ID_DESC
  GAME_BY_GAME_ID__SETTING_ASC
  GAME_BY_GAME_ID__SETTING_DESC
  GAME_BY_GAME_ID__SHORT_NAME_ASC
  GAME_BY_GAME_ID__SHORT_NAME_DESC
  GAME_BY_GAME_ID__SLOT_CONFLICTS_ASC
  GAME_BY_GAME_ID__SLOT_CONFLICTS_DESC
  GAME_BY_GAME_ID__SLOT_ID_ASC
  GAME_BY_GAME_ID__SLOT_ID_DESC
  GAME_BY_GAME_ID__SLOT_PREFERENCE_ASC
  GAME_BY_GAME_ID__SLOT_PREFERENCE_DESC
  GAME_BY_GAME_ID__TEEN_FRIENDLY_ASC
  GAME_BY_GAME_ID__TEEN_FRIENDLY_DESC
  GAME_BY_GAME_ID__TYPE_ASC
  GAME_BY_GAME_ID__TYPE_DESC
  GAME_BY_GAME_ID__YEAR_ASC
  GAME_BY_GAME_ID__YEAR_DESC
  GAME_ID_ASC
  GAME_ID_DESC
  ID_ASC
  ID_DESC
  MEMBERSHIP_BY_MEMBER_ID__AMOUNT_OWED_ASC
  MEMBERSHIP_BY_MEMBER_ID__AMOUNT_OWED_DESC
  MEMBERSHIP_BY_MEMBER_ID__AMOUNT_PAID_ASC
  MEMBERSHIP_BY_MEMBER_ID__AMOUNT_PAID_DESC
  MEMBERSHIP_BY_MEMBER_ID__ARRIVAL_DATE_ASC
  MEMBERSHIP_BY_MEMBER_ID__ARRIVAL_DATE_DESC
  MEMBERSHIP_BY_MEMBER_ID__ATTENDANCE_ASC
  MEMBERSHIP_BY_MEMBER_ID__ATTENDANCE_DESC
  MEMBERSHIP_BY_MEMBER_ID__ATTENDING_ASC
  MEMBERSHIP_BY_MEMBER_ID__ATTENDING_DESC
  MEMBERSHIP_BY_MEMBER_ID__DEPARTURE_DATE_ASC
  MEMBERSHIP_BY_MEMBER_ID__DEPARTURE_DATE_DESC
  MEMBERSHIP_BY_MEMBER_ID__HOTEL_ROOM_ID_ASC
  MEMBERSHIP_BY_MEMBER_ID__HOTEL_ROOM_ID_DESC
  MEMBERSHIP_BY_MEMBER_ID__ID_ASC
  MEMBERSHIP_BY_MEMBER_ID__ID_DESC
  MEMBERSHIP_BY_MEMBER_ID__INTEREST_LEVEL_ASC
  MEMBERSHIP_BY_MEMBER_ID__INTEREST_LEVEL_DESC
  MEMBERSHIP_BY_MEMBER_ID__MESSAGE_ASC
  MEMBERSHIP_BY_MEMBER_ID__MESSAGE_DESC
  MEMBERSHIP_BY_MEMBER_ID__OFFER_SUBSIDY_ASC
  MEMBERSHIP_BY_MEMBER_ID__OFFER_SUBSIDY_DESC
  MEMBERSHIP_BY_MEMBER_ID__REQUEST_OLD_PRICE_ASC
  MEMBERSHIP_BY_MEMBER_ID__REQUEST_OLD_PRICE_DESC
  MEMBERSHIP_BY_MEMBER_ID__ROOMING_PREFERENCES_ASC
  MEMBERSHIP_BY_MEMBER_ID__ROOMING_PREFERENCES_DESC
  MEMBERSHIP_BY_MEMBER_ID__ROOMING_WITH_ASC
  MEMBERSHIP_BY_MEMBER_ID__ROOMING_WITH_DESC
  MEMBERSHIP_BY_MEMBER_ID__ROOM_PREFERENCE_AND_NOTES_ASC
  MEMBERSHIP_BY_MEMBER_ID__ROOM_PREFERENCE_AND_NOTES_DESC
  MEMBERSHIP_BY_MEMBER_ID__USER_ID_ASC
  MEMBERSHIP_BY_MEMBER_ID__USER_ID_DESC
  MEMBERSHIP_BY_MEMBER_ID__VOLUNTEER_ASC
  MEMBERSHIP_BY_MEMBER_ID__VOLUNTEER_DESC
  MEMBERSHIP_BY_MEMBER_ID__YEAR_ASC
  MEMBERSHIP_BY_MEMBER_ID__YEAR_DESC
  MEMBER_ID_ASC
  MEMBER_ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  RANK_ASC
  RANK_DESC
  RETURNING_PLAYER_ASC
  RETURNING_PLAYER_DESC
  SLOT_BY_SLOT_ID__DAY_ASC
  SLOT_BY_SLOT_ID__DAY_DESC
  SLOT_BY_SLOT_ID__FORMATTED_DATE_ASC
  SLOT_BY_SLOT_ID__FORMATTED_DATE_DESC
  SLOT_BY_SLOT_ID__ID_ASC
  SLOT_BY_SLOT_ID__ID_DESC
  SLOT_BY_SLOT_ID__LENGTH_ASC
  SLOT_BY_SLOT_ID__LENGTH_DESC
  SLOT_BY_SLOT_ID__SLOT_ASC
  SLOT_BY_SLOT_ID__SLOT_DESC
  SLOT_BY_SLOT_ID__TIME_ASC
  SLOT_BY_SLOT_ID__TIME_DESC
  SLOT_ID_ASC
  SLOT_ID_DESC
  YEAR_ASC
  YEAR_DESC
}

"Methods to use when ordering `GameSubmission`."
enum GameSubmissionsOrderBy {
  ID_ASC
  ID_DESC
  MEMBERSHIP_BY_MEMBER_ID__AMOUNT_OWED_ASC
  MEMBERSHIP_BY_MEMBER_ID__AMOUNT_OWED_DESC
  MEMBERSHIP_BY_MEMBER_ID__AMOUNT_PAID_ASC
  MEMBERSHIP_BY_MEMBER_ID__AMOUNT_PAID_DESC
  MEMBERSHIP_BY_MEMBER_ID__ARRIVAL_DATE_ASC
  MEMBERSHIP_BY_MEMBER_ID__ARRIVAL_DATE_DESC
  MEMBERSHIP_BY_MEMBER_ID__ATTENDANCE_ASC
  MEMBERSHIP_BY_MEMBER_ID__ATTENDANCE_DESC
  MEMBERSHIP_BY_MEMBER_ID__ATTENDING_ASC
  MEMBERSHIP_BY_MEMBER_ID__ATTENDING_DESC
  MEMBERSHIP_BY_MEMBER_ID__DEPARTURE_DATE_ASC
  MEMBERSHIP_BY_MEMBER_ID__DEPARTURE_DATE_DESC
  MEMBERSHIP_BY_MEMBER_ID__HOTEL_ROOM_ID_ASC
  MEMBERSHIP_BY_MEMBER_ID__HOTEL_ROOM_ID_DESC
  MEMBERSHIP_BY_MEMBER_ID__ID_ASC
  MEMBERSHIP_BY_MEMBER_ID__ID_DESC
  MEMBERSHIP_BY_MEMBER_ID__INTEREST_LEVEL_ASC
  MEMBERSHIP_BY_MEMBER_ID__INTEREST_LEVEL_DESC
  MEMBERSHIP_BY_MEMBER_ID__MESSAGE_ASC
  MEMBERSHIP_BY_MEMBER_ID__MESSAGE_DESC
  MEMBERSHIP_BY_MEMBER_ID__OFFER_SUBSIDY_ASC
  MEMBERSHIP_BY_MEMBER_ID__OFFER_SUBSIDY_DESC
  MEMBERSHIP_BY_MEMBER_ID__REQUEST_OLD_PRICE_ASC
  MEMBERSHIP_BY_MEMBER_ID__REQUEST_OLD_PRICE_DESC
  MEMBERSHIP_BY_MEMBER_ID__ROOMING_PREFERENCES_ASC
  MEMBERSHIP_BY_MEMBER_ID__ROOMING_PREFERENCES_DESC
  MEMBERSHIP_BY_MEMBER_ID__ROOMING_WITH_ASC
  MEMBERSHIP_BY_MEMBER_ID__ROOMING_WITH_DESC
  MEMBERSHIP_BY_MEMBER_ID__ROOM_PREFERENCE_AND_NOTES_ASC
  MEMBERSHIP_BY_MEMBER_ID__ROOM_PREFERENCE_AND_NOTES_DESC
  MEMBERSHIP_BY_MEMBER_ID__USER_ID_ASC
  MEMBERSHIP_BY_MEMBER_ID__USER_ID_DESC
  MEMBERSHIP_BY_MEMBER_ID__VOLUNTEER_ASC
  MEMBERSHIP_BY_MEMBER_ID__VOLUNTEER_DESC
  MEMBERSHIP_BY_MEMBER_ID__YEAR_ASC
  MEMBERSHIP_BY_MEMBER_ID__YEAR_DESC
  MEMBER_ID_ASC
  MEMBER_ID_DESC
  MESSAGE_ASC
  MESSAGE_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  YEAR_ASC
  YEAR_DESC
}

"Methods to use when ordering `Game`."
enum GamesOrderBy {
  AUTHOR_ID_ASC
  AUTHOR_ID_DESC
  CHAR_INSTRUCTIONS_ASC
  CHAR_INSTRUCTIONS_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  ESTIMATED_LENGTH_ASC
  ESTIMATED_LENGTH_DESC
  GAME_ASSIGNMENTS_BY_GAME_ID__COUNT_ASC
  GAME_ASSIGNMENTS_BY_GAME_ID__COUNT_DESC
  GAME_CHOICES_BY_GAME_ID__COUNT_ASC
  GAME_CHOICES_BY_GAME_ID__COUNT_DESC
  GAME_CONTACT_EMAIL_ASC
  GAME_CONTACT_EMAIL_DESC
  GENRE_ASC
  GENRE_DESC
  GM_NAMES_ASC
  GM_NAMES_DESC
  ID_ASC
  ID_DESC
  LATE_FINISH_ASC
  LATE_FINISH_DESC
  LATE_START_ASC
  LATE_START_DESC
  MESSAGE_ASC
  MESSAGE_DESC
  NAME_ASC
  NAME_DESC
  NATURAL
  PLAYERS_CONTACT_GM_ASC
  PLAYERS_CONTACT_GM_DESC
  PLAYER_MAX_ASC
  PLAYER_MAX_DESC
  PLAYER_MIN_ASC
  PLAYER_MIN_DESC
  PLAYER_PREFERENCE_ASC
  PLAYER_PREFERENCE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  RETURNING_PLAYERS_ASC
  RETURNING_PLAYERS_DESC
  ROOM_BY_ROOM_ID__DESCRIPTION_ASC
  ROOM_BY_ROOM_ID__DESCRIPTION_DESC
  ROOM_BY_ROOM_ID__ID_ASC
  ROOM_BY_ROOM_ID__ID_DESC
  ROOM_BY_ROOM_ID__SIZE_ASC
  ROOM_BY_ROOM_ID__SIZE_DESC
  ROOM_BY_ROOM_ID__TYPE_ASC
  ROOM_BY_ROOM_ID__TYPE_DESC
  ROOM_BY_ROOM_ID__UPDATED_ASC
  ROOM_BY_ROOM_ID__UPDATED_DESC
  ROOM_ID_ASC
  ROOM_ID_DESC
  SETTING_ASC
  SETTING_DESC
  SHORT_NAME_ASC
  SHORT_NAME_DESC
  SLOT_BY_SLOT_ID__DAY_ASC
  SLOT_BY_SLOT_ID__DAY_DESC
  SLOT_BY_SLOT_ID__FORMATTED_DATE_ASC
  SLOT_BY_SLOT_ID__FORMATTED_DATE_DESC
  SLOT_BY_SLOT_ID__ID_ASC
  SLOT_BY_SLOT_ID__ID_DESC
  SLOT_BY_SLOT_ID__LENGTH_ASC
  SLOT_BY_SLOT_ID__LENGTH_DESC
  SLOT_BY_SLOT_ID__SLOT_ASC
  SLOT_BY_SLOT_ID__SLOT_DESC
  SLOT_BY_SLOT_ID__TIME_ASC
  SLOT_BY_SLOT_ID__TIME_DESC
  SLOT_CONFLICTS_ASC
  SLOT_CONFLICTS_DESC
  SLOT_ID_ASC
  SLOT_ID_DESC
  SLOT_PREFERENCE_ASC
  SLOT_PREFERENCE_DESC
  TEEN_FRIENDLY_ASC
  TEEN_FRIENDLY_DESC
  TYPE_ASC
  TYPE_DESC
  USER_BY_AUTHOR_ID__ACCOUNT_LOCKED_ASC
  USER_BY_AUTHOR_ID__ACCOUNT_LOCKED_DESC
  USER_BY_AUTHOR_ID__ENABLED_ASC
  USER_BY_AUTHOR_ID__ENABLED_DESC
  USER_BY_AUTHOR_ID__ID_ASC
  USER_BY_AUTHOR_ID__ID_DESC
  USER_BY_AUTHOR_ID__PASSWORD_ASC
  USER_BY_AUTHOR_ID__PASSWORD_DESC
  USER_BY_AUTHOR_ID__PROFILE_ID_ASC
  USER_BY_AUTHOR_ID__PROFILE_ID_DESC
  USER_BY_AUTHOR_ID__USERNAME_ASC
  USER_BY_AUTHOR_ID__USERNAME_DESC
  YEAR_ASC
  YEAR_DESC
}

"Methods to use when ordering `HotelRoomDetail`."
enum HotelRoomDetailsOrderBy {
  BATHROOM_TYPE_ASC
  BATHROOM_TYPE_DESC
  COMMENT_ASC
  COMMENT_DESC
  ENABLED_ASC
  ENABLED_DESC
  FORMATTED_ROOM_TYPE_ASC
  FORMATTED_ROOM_TYPE_DESC
  GAMING_ROOM_ASC
  GAMING_ROOM_DESC
  ID_ASC
  ID_DESC
  INTERNAL_ROOM_TYPE_ASC
  INTERNAL_ROOM_TYPE_DESC
  MEMBER_HOTEL_ROOM_ASSIGNMENTS_BY_HOTEL_ROOM_ID__COUNT_ASC
  MEMBER_HOTEL_ROOM_ASSIGNMENTS_BY_HOTEL_ROOM_ID__COUNT_DESC
  NAME_ASC
  NAME_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  RESERVED_ASC
  RESERVED_DESC
  RESERVED_FOR_ASC
  RESERVED_FOR_DESC
  ROOM_TYPE_ASC
  ROOM_TYPE_DESC
  VERSION_ASC
  VERSION_DESC
}

"Methods to use when ordering `HotelRoom`."
enum HotelRoomsOrderBy {
  BATHROOM_TYPE_ASC
  BATHROOM_TYPE_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  GAMING_ROOM_ASC
  GAMING_ROOM_DESC
  ID_ASC
  ID_DESC
  MEMBERSHIPS_BY_HOTEL_ROOM_ID__COUNT_ASC
  MEMBERSHIPS_BY_HOTEL_ROOM_ID__COUNT_DESC
  NATURAL
  OCCUPANCY_ASC
  OCCUPANCY_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  QUANTITY_ASC
  QUANTITY_DESC
  RATE_ASC
  RATE_DESC
  TYPE_ASC
  TYPE_DESC
}

"Methods to use when ordering `LookupValue`."
enum LookupValuesOrderBy {
  CODE_ASC
  CODE_DESC
  ID_ASC
  ID_DESC
  LOOKUP_BY_LOOKUP_ID__CODE_MAXIMUM_ASC
  LOOKUP_BY_LOOKUP_ID__CODE_MAXIMUM_DESC
  LOOKUP_BY_LOOKUP_ID__CODE_MINIMUM_ASC
  LOOKUP_BY_LOOKUP_ID__CODE_MINIMUM_DESC
  LOOKUP_BY_LOOKUP_ID__CODE_SCALE_ASC
  LOOKUP_BY_LOOKUP_ID__CODE_SCALE_DESC
  LOOKUP_BY_LOOKUP_ID__CODE_TYPE_ASC
  LOOKUP_BY_LOOKUP_ID__CODE_TYPE_DESC
  LOOKUP_BY_LOOKUP_ID__ID_ASC
  LOOKUP_BY_LOOKUP_ID__ID_DESC
  LOOKUP_BY_LOOKUP_ID__INTERNATIONALIZE_ASC
  LOOKUP_BY_LOOKUP_ID__INTERNATIONALIZE_DESC
  LOOKUP_BY_LOOKUP_ID__ORDERING_ASC
  LOOKUP_BY_LOOKUP_ID__ORDERING_DESC
  LOOKUP_BY_LOOKUP_ID__REALM_ASC
  LOOKUP_BY_LOOKUP_ID__REALM_DESC
  LOOKUP_BY_LOOKUP_ID__VALUE_MAXIMUM_ASC
  LOOKUP_BY_LOOKUP_ID__VALUE_MAXIMUM_DESC
  LOOKUP_BY_LOOKUP_ID__VALUE_MINIMUM_ASC
  LOOKUP_BY_LOOKUP_ID__VALUE_MINIMUM_DESC
  LOOKUP_BY_LOOKUP_ID__VALUE_SCALE_ASC
  LOOKUP_BY_LOOKUP_ID__VALUE_SCALE_DESC
  LOOKUP_BY_LOOKUP_ID__VALUE_TYPE_ASC
  LOOKUP_BY_LOOKUP_ID__VALUE_TYPE_DESC
  LOOKUP_ID_ASC
  LOOKUP_ID_DESC
  NATURAL
  NUMERIC_SEQUENCER_ASC
  NUMERIC_SEQUENCER_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  SEQUENCER_ASC
  SEQUENCER_DESC
  STRING_SEQUENCER_ASC
  STRING_SEQUENCER_DESC
  VALUE_ASC
  VALUE_DESC
}

"Methods to use when ordering `Lookup`."
enum LookupsOrderBy {
  CODE_MAXIMUM_ASC
  CODE_MAXIMUM_DESC
  CODE_MINIMUM_ASC
  CODE_MINIMUM_DESC
  CODE_SCALE_ASC
  CODE_SCALE_DESC
  CODE_TYPE_ASC
  CODE_TYPE_DESC
  ID_ASC
  ID_DESC
  INTERNATIONALIZE_ASC
  INTERNATIONALIZE_DESC
  LOOKUP_VALUES_BY_LOOKUP_ID__COUNT_ASC
  LOOKUP_VALUES_BY_LOOKUP_ID__COUNT_DESC
  NATURAL
  ORDERING_ASC
  ORDERING_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  REALM_ASC
  REALM_DESC
  VALUE_MAXIMUM_ASC
  VALUE_MAXIMUM_DESC
  VALUE_MINIMUM_ASC
  VALUE_MINIMUM_DESC
  VALUE_SCALE_ASC
  VALUE_SCALE_DESC
  VALUE_TYPE_ASC
  VALUE_TYPE_DESC
}

"Methods to use when ordering `MemberHotelRoomAssignment`."
enum MemberHotelRoomAssignmentsOrderBy {
  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__BATHROOM_TYPE_ASC
  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__BATHROOM_TYPE_DESC
  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__COMMENT_ASC
  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__COMMENT_DESC
  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__ENABLED_ASC
  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__ENABLED_DESC
  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__FORMATTED_ROOM_TYPE_ASC
  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__FORMATTED_ROOM_TYPE_DESC
  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__GAMING_ROOM_ASC
  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__GAMING_ROOM_DESC
  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__ID_ASC
  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__ID_DESC
  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__INTERNAL_ROOM_TYPE_ASC
  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__INTERNAL_ROOM_TYPE_DESC
  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__NAME_ASC
  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__NAME_DESC
  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__RESERVED_ASC
  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__RESERVED_DESC
  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__RESERVED_FOR_ASC
  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__RESERVED_FOR_DESC
  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__ROOM_TYPE_ASC
  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__ROOM_TYPE_DESC
  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__VERSION_ASC
  HOTEL_ROOM_DETAIL_BY_HOTEL_ROOM_ID__VERSION_DESC
  HOTEL_ROOM_ID_ASC
  HOTEL_ROOM_ID_DESC
  MEMBERSHIP_BY_MEMBER_ID__AMOUNT_OWED_ASC
  MEMBERSHIP_BY_MEMBER_ID__AMOUNT_OWED_DESC
  MEMBERSHIP_BY_MEMBER_ID__AMOUNT_PAID_ASC
  MEMBERSHIP_BY_MEMBER_ID__AMOUNT_PAID_DESC
  MEMBERSHIP_BY_MEMBER_ID__ARRIVAL_DATE_ASC
  MEMBERSHIP_BY_MEMBER_ID__ARRIVAL_DATE_DESC
  MEMBERSHIP_BY_MEMBER_ID__ATTENDANCE_ASC
  MEMBERSHIP_BY_MEMBER_ID__ATTENDANCE_DESC
  MEMBERSHIP_BY_MEMBER_ID__ATTENDING_ASC
  MEMBERSHIP_BY_MEMBER_ID__ATTENDING_DESC
  MEMBERSHIP_BY_MEMBER_ID__DEPARTURE_DATE_ASC
  MEMBERSHIP_BY_MEMBER_ID__DEPARTURE_DATE_DESC
  MEMBERSHIP_BY_MEMBER_ID__HOTEL_ROOM_ID_ASC
  MEMBERSHIP_BY_MEMBER_ID__HOTEL_ROOM_ID_DESC
  MEMBERSHIP_BY_MEMBER_ID__ID_ASC
  MEMBERSHIP_BY_MEMBER_ID__ID_DESC
  MEMBERSHIP_BY_MEMBER_ID__INTEREST_LEVEL_ASC
  MEMBERSHIP_BY_MEMBER_ID__INTEREST_LEVEL_DESC
  MEMBERSHIP_BY_MEMBER_ID__MESSAGE_ASC
  MEMBERSHIP_BY_MEMBER_ID__MESSAGE_DESC
  MEMBERSHIP_BY_MEMBER_ID__OFFER_SUBSIDY_ASC
  MEMBERSHIP_BY_MEMBER_ID__OFFER_SUBSIDY_DESC
  MEMBERSHIP_BY_MEMBER_ID__REQUEST_OLD_PRICE_ASC
  MEMBERSHIP_BY_MEMBER_ID__REQUEST_OLD_PRICE_DESC
  MEMBERSHIP_BY_MEMBER_ID__ROOMING_PREFERENCES_ASC
  MEMBERSHIP_BY_MEMBER_ID__ROOMING_PREFERENCES_DESC
  MEMBERSHIP_BY_MEMBER_ID__ROOMING_WITH_ASC
  MEMBERSHIP_BY_MEMBER_ID__ROOMING_WITH_DESC
  MEMBERSHIP_BY_MEMBER_ID__ROOM_PREFERENCE_AND_NOTES_ASC
  MEMBERSHIP_BY_MEMBER_ID__ROOM_PREFERENCE_AND_NOTES_DESC
  MEMBERSHIP_BY_MEMBER_ID__USER_ID_ASC
  MEMBERSHIP_BY_MEMBER_ID__USER_ID_DESC
  MEMBERSHIP_BY_MEMBER_ID__VOLUNTEER_ASC
  MEMBERSHIP_BY_MEMBER_ID__VOLUNTEER_DESC
  MEMBERSHIP_BY_MEMBER_ID__YEAR_ASC
  MEMBERSHIP_BY_MEMBER_ID__YEAR_DESC
  MEMBER_ID_ASC
  MEMBER_ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROOM_OWNER_ASC
  ROOM_OWNER_DESC
  YEAR_ASC
  YEAR_DESC
}

"Methods to use when ordering `Membership`."
enum MembershipsOrderBy {
  AMOUNT_OWED_ASC
  AMOUNT_OWED_DESC
  AMOUNT_PAID_ASC
  AMOUNT_PAID_DESC
  ARRIVAL_DATE_ASC
  ARRIVAL_DATE_DESC
  ATTENDANCE_ASC
  ATTENDANCE_DESC
  ATTENDING_ASC
  ATTENDING_DESC
  DEPARTURE_DATE_ASC
  DEPARTURE_DATE_DESC
  GAME_ASSIGNMENTS_BY_MEMBER_ID__COUNT_ASC
  GAME_ASSIGNMENTS_BY_MEMBER_ID__COUNT_DESC
  GAME_CHOICES_BY_MEMBER_ID__COUNT_ASC
  GAME_CHOICES_BY_MEMBER_ID__COUNT_DESC
  GAME_SUBMISSIONS_BY_MEMBER_ID__COUNT_ASC
  GAME_SUBMISSIONS_BY_MEMBER_ID__COUNT_DESC
  HOTEL_ROOM_BY_HOTEL_ROOM_ID__BATHROOM_TYPE_ASC
  HOTEL_ROOM_BY_HOTEL_ROOM_ID__BATHROOM_TYPE_DESC
  HOTEL_ROOM_BY_HOTEL_ROOM_ID__DESCRIPTION_ASC
  HOTEL_ROOM_BY_HOTEL_ROOM_ID__DESCRIPTION_DESC
  HOTEL_ROOM_BY_HOTEL_ROOM_ID__GAMING_ROOM_ASC
  HOTEL_ROOM_BY_HOTEL_ROOM_ID__GAMING_ROOM_DESC
  HOTEL_ROOM_BY_HOTEL_ROOM_ID__ID_ASC
  HOTEL_ROOM_BY_HOTEL_ROOM_ID__ID_DESC
  HOTEL_ROOM_BY_HOTEL_ROOM_ID__OCCUPANCY_ASC
  HOTEL_ROOM_BY_HOTEL_ROOM_ID__OCCUPANCY_DESC
  HOTEL_ROOM_BY_HOTEL_ROOM_ID__QUANTITY_ASC
  HOTEL_ROOM_BY_HOTEL_ROOM_ID__QUANTITY_DESC
  HOTEL_ROOM_BY_HOTEL_ROOM_ID__RATE_ASC
  HOTEL_ROOM_BY_HOTEL_ROOM_ID__RATE_DESC
  HOTEL_ROOM_BY_HOTEL_ROOM_ID__TYPE_ASC
  HOTEL_ROOM_BY_HOTEL_ROOM_ID__TYPE_DESC
  HOTEL_ROOM_ID_ASC
  HOTEL_ROOM_ID_DESC
  ID_ASC
  ID_DESC
  INTEREST_LEVEL_ASC
  INTEREST_LEVEL_DESC
  MEMBER_HOTEL_ROOM_ASSIGNMENTS_BY_MEMBER_ID__COUNT_ASC
  MEMBER_HOTEL_ROOM_ASSIGNMENTS_BY_MEMBER_ID__COUNT_DESC
  MESSAGE_ASC
  MESSAGE_DESC
  NATURAL
  OFFER_SUBSIDY_ASC
  OFFER_SUBSIDY_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  REQUEST_OLD_PRICE_ASC
  REQUEST_OLD_PRICE_DESC
  ROOMING_PREFERENCES_ASC
  ROOMING_PREFERENCES_DESC
  ROOMING_WITH_ASC
  ROOMING_WITH_DESC
  ROOM_PREFERENCE_AND_NOTES_ASC
  ROOM_PREFERENCE_AND_NOTES_DESC
  USER_BY_USER_ID__ACCOUNT_LOCKED_ASC
  USER_BY_USER_ID__ACCOUNT_LOCKED_DESC
  USER_BY_USER_ID__ENABLED_ASC
  USER_BY_USER_ID__ENABLED_DESC
  USER_BY_USER_ID__ID_ASC
  USER_BY_USER_ID__ID_DESC
  USER_BY_USER_ID__PASSWORD_ASC
  USER_BY_USER_ID__PASSWORD_DESC
  USER_BY_USER_ID__PROFILE_ID_ASC
  USER_BY_USER_ID__PROFILE_ID_DESC
  USER_BY_USER_ID__USERNAME_ASC
  USER_BY_USER_ID__USERNAME_DESC
  USER_ID_ASC
  USER_ID_DESC
  VOLUNTEER_ASC
  VOLUNTEER_DESC
  YEAR_ASC
  YEAR_DESC
}

"Methods to use when ordering `Profile`."
enum ProfilesOrderBy {
  EMAIL_ASC
  EMAIL_DESC
  FULL_NAME_ASC
  FULL_NAME_DESC
  ID_ASC
  ID_DESC
  NATURAL
  PHONE_NUMBER_ASC
  PHONE_NUMBER_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  SNAIL_MAIL_ADDRESS_ASC
  SNAIL_MAIL_ADDRESS_DESC
  USERS_BY_PROFILE_ID__COUNT_ASC
  USERS_BY_PROFILE_ID__COUNT_DESC
}

"Methods to use when ordering `RegistrationCode`."
enum RegistrationCodesOrderBy {
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  TOKEN_ASC
  TOKEN_DESC
  USERNAME_ASC
  USERNAME_DESC
}

"Methods to use when ordering `Role`."
enum RolesOrderBy {
  AUTHORITY_ASC
  AUTHORITY_DESC
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  USER_ROLES_BY_ROLE_ID__COUNT_ASC
  USER_ROLES_BY_ROLE_ID__COUNT_DESC
}

"Methods to use when ordering `Room`."
enum RoomsOrderBy {
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  GAMES_BY_ROOM_ID__COUNT_ASC
  GAMES_BY_ROOM_ID__COUNT_DESC
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  SIZE_ASC
  SIZE_DESC
  TYPE_ASC
  TYPE_DESC
  UPDATED_ASC
  UPDATED_DESC
}

"Methods to use when ordering `Setting`."
enum SettingsOrderBy {
  CODE_ASC
  CODE_DESC
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  TYPE_ASC
  TYPE_DESC
  VALUE_ASC
  VALUE_DESC
}

"Methods to use when ordering `ShirtOrderItem`."
enum ShirtOrderItemsOrderBy {
  ID_ASC
  ID_DESC
  ITEMS_IDX_ASC
  ITEMS_IDX_DESC
  NATURAL
  ORDER_ID_ASC
  ORDER_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  QUANTITY_ASC
  QUANTITY_DESC
  SHIRT_ORDER_BY_ORDER_ID__DELIVERY_METHOD_ASC
  SHIRT_ORDER_BY_ORDER_ID__DELIVERY_METHOD_DESC
  SHIRT_ORDER_BY_ORDER_ID__ID_ASC
  SHIRT_ORDER_BY_ORDER_ID__ID_DESC
  SHIRT_ORDER_BY_ORDER_ID__MESSAGE_ASC
  SHIRT_ORDER_BY_ORDER_ID__MESSAGE_DESC
  SHIRT_ORDER_BY_ORDER_ID__USER_ID_ASC
  SHIRT_ORDER_BY_ORDER_ID__USER_ID_DESC
  SHIRT_ORDER_BY_ORDER_ID__YEAR_ASC
  SHIRT_ORDER_BY_ORDER_ID__YEAR_DESC
  SIZE_ASC
  SIZE_DESC
  STYLE_ASC
  STYLE_DESC
}

"Methods to use when ordering `ShirtOrder`."
enum ShirtOrdersOrderBy {
  DELIVERY_METHOD_ASC
  DELIVERY_METHOD_DESC
  ID_ASC
  ID_DESC
  MESSAGE_ASC
  MESSAGE_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  SHIRT_ORDER_ITEMS_BY_ORDER_ID__COUNT_ASC
  SHIRT_ORDER_ITEMS_BY_ORDER_ID__COUNT_DESC
  USER_BY_USER_ID__ACCOUNT_LOCKED_ASC
  USER_BY_USER_ID__ACCOUNT_LOCKED_DESC
  USER_BY_USER_ID__ENABLED_ASC
  USER_BY_USER_ID__ENABLED_DESC
  USER_BY_USER_ID__ID_ASC
  USER_BY_USER_ID__ID_DESC
  USER_BY_USER_ID__PASSWORD_ASC
  USER_BY_USER_ID__PASSWORD_DESC
  USER_BY_USER_ID__PROFILE_ID_ASC
  USER_BY_USER_ID__PROFILE_ID_DESC
  USER_BY_USER_ID__USERNAME_ASC
  USER_BY_USER_ID__USERNAME_DESC
  USER_ID_ASC
  USER_ID_DESC
  YEAR_ASC
  YEAR_DESC
}

"Methods to use when ordering `Slot`."
enum SlotsOrderBy {
  DAY_ASC
  DAY_DESC
  FORMATTED_DATE_ASC
  FORMATTED_DATE_DESC
  GAMES_BY_SLOT_ID__COUNT_ASC
  GAMES_BY_SLOT_ID__COUNT_DESC
  GAME_CHOICES_BY_SLOT_ID__COUNT_ASC
  GAME_CHOICES_BY_SLOT_ID__COUNT_DESC
  ID_ASC
  ID_DESC
  LENGTH_ASC
  LENGTH_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  SLOT_ASC
  SLOT_DESC
  TIME_ASC
  TIME_DESC
}

"Methods to use when ordering `Token`."
enum TokensOrderBy {
  ACTIVE_ASC
  ACTIVE_DESC
  CUID_ASC
  CUID_DESC
  ID_ASC
  ID_DESC
  LAST_USED_ASC
  LAST_USED_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  USER_BY_USER_ID__ACCOUNT_LOCKED_ASC
  USER_BY_USER_ID__ACCOUNT_LOCKED_DESC
  USER_BY_USER_ID__ENABLED_ASC
  USER_BY_USER_ID__ENABLED_DESC
  USER_BY_USER_ID__ID_ASC
  USER_BY_USER_ID__ID_DESC
  USER_BY_USER_ID__PASSWORD_ASC
  USER_BY_USER_ID__PASSWORD_DESC
  USER_BY_USER_ID__PROFILE_ID_ASC
  USER_BY_USER_ID__PROFILE_ID_DESC
  USER_BY_USER_ID__USERNAME_ASC
  USER_BY_USER_ID__USERNAME_DESC
  USER_ID_ASC
  USER_ID_DESC
}

"Methods to use when ordering `UserRole`."
enum UserRolesOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROLE_BY_ROLE_ID__AUTHORITY_ASC
  ROLE_BY_ROLE_ID__AUTHORITY_DESC
  ROLE_BY_ROLE_ID__ID_ASC
  ROLE_BY_ROLE_ID__ID_DESC
  ROLE_ID_ASC
  ROLE_ID_DESC
  USER_BY_USER_ID__ACCOUNT_LOCKED_ASC
  USER_BY_USER_ID__ACCOUNT_LOCKED_DESC
  USER_BY_USER_ID__ENABLED_ASC
  USER_BY_USER_ID__ENABLED_DESC
  USER_BY_USER_ID__ID_ASC
  USER_BY_USER_ID__ID_DESC
  USER_BY_USER_ID__PASSWORD_ASC
  USER_BY_USER_ID__PASSWORD_DESC
  USER_BY_USER_ID__PROFILE_ID_ASC
  USER_BY_USER_ID__PROFILE_ID_DESC
  USER_BY_USER_ID__USERNAME_ASC
  USER_BY_USER_ID__USERNAME_DESC
  USER_ID_ASC
  USER_ID_DESC
}

"Methods to use when ordering `User`."
enum UsersOrderBy {
  ACCOUNT_LOCKED_ASC
  ACCOUNT_LOCKED_DESC
  ENABLED_ASC
  ENABLED_DESC
  GAMES_BY_AUTHOR_ID__COUNT_ASC
  GAMES_BY_AUTHOR_ID__COUNT_DESC
  ID_ASC
  ID_DESC
  MEMBERSHIPS_BY_USER_ID__COUNT_ASC
  MEMBERSHIPS_BY_USER_ID__COUNT_DESC
  NATURAL
  PASSWORD_ASC
  PASSWORD_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  PROFILE_BY_PROFILE_ID__EMAIL_ASC
  PROFILE_BY_PROFILE_ID__EMAIL_DESC
  PROFILE_BY_PROFILE_ID__FULL_NAME_ASC
  PROFILE_BY_PROFILE_ID__FULL_NAME_DESC
  PROFILE_BY_PROFILE_ID__ID_ASC
  PROFILE_BY_PROFILE_ID__ID_DESC
  PROFILE_BY_PROFILE_ID__PHONE_NUMBER_ASC
  PROFILE_BY_PROFILE_ID__PHONE_NUMBER_DESC
  PROFILE_BY_PROFILE_ID__SNAIL_MAIL_ADDRESS_ASC
  PROFILE_BY_PROFILE_ID__SNAIL_MAIL_ADDRESS_DESC
  PROFILE_ID_ASC
  PROFILE_ID_DESC
  SHIRT_ORDERS_BY_USER_ID__COUNT_ASC
  SHIRT_ORDERS_BY_USER_ID__COUNT_DESC
  TOKENS_BY_USER_ID__COUNT_ASC
  TOKENS_BY_USER_ID__COUNT_DESC
  USERNAME_ASC
  USERNAME_DESC
  USER_ROLES_BY_USER_ID__COUNT_ASC
  USER_ROLES_BY_USER_ID__COUNT_DESC
}

"A filter to be used against BigFloat fields. All fields are combined with a logical and."
input BigFloatFilter {
  "Not equal to the specified value, treating null like an ordinary value."
  distinctFrom: BigFloat
  "Equal to the specified value."
  equalTo: BigFloat
  "Greater than the specified value."
  greaterThan: BigFloat
  "Greater than or equal to the specified value."
  greaterThanOrEqualTo: BigFloat
  "Included in the specified list."
  in: [BigFloat!]
  "Is null (if `true` is specified) or is not null (if `false` is specified)."
  isNull: Boolean
  "Less than the specified value."
  lessThan: BigFloat
  "Less than or equal to the specified value."
  lessThanOrEqualTo: BigFloat
  "Equal to the specified value, treating null like an ordinary value."
  notDistinctFrom: BigFloat
  "Not equal to the specified value."
  notEqualTo: BigFloat
  "Not included in the specified list."
  notIn: [BigFloat!]
}

"A filter to be used against BigInt fields. All fields are combined with a logical and."
input BigIntFilter {
  "Not equal to the specified value, treating null like an ordinary value."
  distinctFrom: BigInt
  "Equal to the specified value."
  equalTo: BigInt
  "Greater than the specified value."
  greaterThan: BigInt
  "Greater than or equal to the specified value."
  greaterThanOrEqualTo: BigInt
  "Included in the specified list."
  in: [BigInt!]
  "Is null (if `true` is specified) or is not null (if `false` is specified)."
  isNull: Boolean
  "Less than the specified value."
  lessThan: BigInt
  "Less than or equal to the specified value."
  lessThanOrEqualTo: BigInt
  "Equal to the specified value, treating null like an ordinary value."
  notDistinctFrom: BigInt
  "Not equal to the specified value."
  notEqualTo: BigInt
  "Not included in the specified list."
  notIn: [BigInt!]
}

"A filter to be used against Boolean fields. All fields are combined with a logical and."
input BooleanFilter {
  "Not equal to the specified value, treating null like an ordinary value."
  distinctFrom: Boolean
  "Equal to the specified value."
  equalTo: Boolean
  "Greater than the specified value."
  greaterThan: Boolean
  "Greater than or equal to the specified value."
  greaterThanOrEqualTo: Boolean
  "Included in the specified list."
  in: [Boolean!]
  "Is null (if `true` is specified) or is not null (if `false` is specified)."
  isNull: Boolean
  "Less than the specified value."
  lessThan: Boolean
  "Less than or equal to the specified value."
  lessThanOrEqualTo: Boolean
  "Equal to the specified value, treating null like an ordinary value."
  notDistinctFrom: Boolean
  "Not equal to the specified value."
  notEqualTo: Boolean
  "Not included in the specified list."
  notIn: [Boolean!]
}

"All input for the create `GameAssignment` mutation."
input CreateGameAssignmentInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The `GameAssignment` to be created by this mutation."
  gameAssignment: GameAssignmentInput!
}

"All input for the create `GameChoice` mutation."
input CreateGameChoiceInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The `GameChoice` to be created by this mutation."
  gameChoice: GameChoiceInput!
}

"All input for the create `Game` mutation."
input CreateGameInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The `Game` to be created by this mutation."
  game: GameInput!
}

"All input for the create `GameSubmission` mutation."
input CreateGameSubmissionInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The `GameSubmission` to be created by this mutation."
  gameSubmission: GameSubmissionInput!
}

"All input for the create `HotelRoomDetail` mutation."
input CreateHotelRoomDetailInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The `HotelRoomDetail` to be created by this mutation."
  hotelRoomDetail: HotelRoomDetailInput!
}

"All input for the create `HotelRoom` mutation."
input CreateHotelRoomInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The `HotelRoom` to be created by this mutation."
  hotelRoom: HotelRoomInput!
}

"All input for the create `Lookup` mutation."
input CreateLookupInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The `Lookup` to be created by this mutation."
  lookup: LookupInput!
}

"All input for the create `LookupValue` mutation."
input CreateLookupValueInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The `LookupValue` to be created by this mutation."
  lookupValue: LookupValueInput!
}

"All input for the create `MemberHotelRoomAssignment` mutation."
input CreateMemberHotelRoomAssignmentInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The `MemberHotelRoomAssignment` to be created by this mutation."
  memberHotelRoomAssignment: MemberHotelRoomAssignmentInput!
}

"All input for the create `Membership` mutation."
input CreateMembershipInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The `Membership` to be created by this mutation."
  membership: MembershipInput!
}

"All input for the create `Profile` mutation."
input CreateProfileInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The `Profile` to be created by this mutation."
  profile: ProfileInput!
}

"All input for the create `RegistrationCode` mutation."
input CreateRegistrationCodeInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The `RegistrationCode` to be created by this mutation."
  registrationCode: RegistrationCodeInput!
}

"All input for the create `Role` mutation."
input CreateRoleInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The `Role` to be created by this mutation."
  role: RoleInput!
}

"All input for the create `Room` mutation."
input CreateRoomInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The `Room` to be created by this mutation."
  room: RoomInput!
}

"All input for the create `Setting` mutation."
input CreateSettingInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The `Setting` to be created by this mutation."
  setting: SettingInput!
}

"All input for the create `ShirtOrder` mutation."
input CreateShirtOrderInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The `ShirtOrder` to be created by this mutation."
  shirtOrder: ShirtOrderInput!
}

"All input for the create `ShirtOrderItem` mutation."
input CreateShirtOrderItemInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The `ShirtOrderItem` to be created by this mutation."
  shirtOrderItem: ShirtOrderItemInput!
}

"All input for the create `Slot` mutation."
input CreateSlotInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The `Slot` to be created by this mutation."
  slot: SlotInput!
}

"All input for the create `Token` mutation."
input CreateTokenInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The `Token` to be created by this mutation."
  token: TokenInput!
}

"All input for the create `User` mutation."
input CreateUserInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The `User` to be created by this mutation."
  user: UserInput!
}

"All input for the create `UserRole` mutation."
input CreateUserRoleInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The `UserRole` to be created by this mutation."
  userRole: UserRoleInput!
}

"A filter to be used against Datetime fields. All fields are combined with a logical and."
input DatetimeFilter {
  "Not equal to the specified value, treating null like an ordinary value."
  distinctFrom: Datetime
  "Equal to the specified value."
  equalTo: Datetime
  "Greater than the specified value."
  greaterThan: Datetime
  "Greater than or equal to the specified value."
  greaterThanOrEqualTo: Datetime
  "Included in the specified list."
  in: [Datetime!]
  "Is null (if `true` is specified) or is not null (if `false` is specified)."
  isNull: Boolean
  "Less than the specified value."
  lessThan: Datetime
  "Less than or equal to the specified value."
  lessThanOrEqualTo: Datetime
  "Equal to the specified value, treating null like an ordinary value."
  notDistinctFrom: Datetime
  "Not equal to the specified value."
  notEqualTo: Datetime
  "Not included in the specified list."
  notIn: [Datetime!]
}

"All input for the `deleteGameAssignmentByNodeId` mutation."
input DeleteGameAssignmentByNodeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `GameAssignment` to be deleted."
  nodeId: ID!
}

"All input for the `deleteGameAssignment` mutation."
input DeleteGameAssignmentInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  gameId: Int!
  gm: Int!
  memberId: Int!
}

"All input for the `deleteGameByNodeId` mutation."
input DeleteGameByNodeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `Game` to be deleted."
  nodeId: ID!
}

"All input for the `deleteGameChoiceByNodeId` mutation."
input DeleteGameChoiceByNodeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `GameChoice` to be deleted."
  nodeId: ID!
}

"All input for the `deleteGameChoice` mutation."
input DeleteGameChoiceInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  id: Int!
}

"All input for the `deleteGame` mutation."
input DeleteGameInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  id: Int!
}

"All input for the `deleteGameSubmissionByNodeId` mutation."
input DeleteGameSubmissionByNodeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `GameSubmission` to be deleted."
  nodeId: ID!
}

"All input for the `deleteGameSubmission` mutation."
input DeleteGameSubmissionInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  id: Int!
}

"All input for the `deleteHotelRoomByNodeId` mutation."
input DeleteHotelRoomByNodeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `HotelRoom` to be deleted."
  nodeId: ID!
}

"All input for the `deleteHotelRoomDetailByNodeId` mutation."
input DeleteHotelRoomDetailByNodeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `HotelRoomDetail` to be deleted."
  nodeId: ID!
}

"All input for the `deleteHotelRoomDetail` mutation."
input DeleteHotelRoomDetailInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  id: BigInt!
}

"All input for the `deleteHotelRoom` mutation."
input DeleteHotelRoomInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  id: Int!
}

"All input for the `deleteLookupByNodeId` mutation."
input DeleteLookupByNodeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `Lookup` to be deleted."
  nodeId: ID!
}

"All input for the `deleteLookupByRealm` mutation."
input DeleteLookupByRealmInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  realm: String!
}

"All input for the `deleteLookup` mutation."
input DeleteLookupInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  id: Int!
}

"All input for the `deleteLookupValueByLookupIdAndCode` mutation."
input DeleteLookupValueByLookupIdAndCodeInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  code: String!
  lookupId: Int!
}

"All input for the `deleteLookupValueByNodeId` mutation."
input DeleteLookupValueByNodeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `LookupValue` to be deleted."
  nodeId: ID!
}

"All input for the `deleteLookupValue` mutation."
input DeleteLookupValueInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  id: Int!
}

"All input for the `deleteMemberHotelRoomAssignmentByNodeId` mutation."
input DeleteMemberHotelRoomAssignmentByNodeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `MemberHotelRoomAssignment` to be deleted."
  nodeId: ID!
}

"All input for the `deleteMemberHotelRoomAssignment` mutation."
input DeleteMemberHotelRoomAssignmentInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  hotelRoomId: BigInt!
  memberId: BigInt!
}

"All input for the `deleteMembershipByNodeId` mutation."
input DeleteMembershipByNodeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `Membership` to be deleted."
  nodeId: ID!
}

"All input for the `deleteMembership` mutation."
input DeleteMembershipInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  id: Int!
}

"All input for the `deleteProfileByEmail` mutation."
input DeleteProfileByEmailInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  email: String!
}

"All input for the `deleteProfileByNodeId` mutation."
input DeleteProfileByNodeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `Profile` to be deleted."
  nodeId: ID!
}

"All input for the `deleteProfile` mutation."
input DeleteProfileInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  id: Int!
}

"All input for the `deleteRegistrationCodeByNodeId` mutation."
input DeleteRegistrationCodeByNodeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `RegistrationCode` to be deleted."
  nodeId: ID!
}

"All input for the `deleteRegistrationCode` mutation."
input DeleteRegistrationCodeInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  id: Int!
}

"All input for the `deleteRoleByAuthority` mutation."
input DeleteRoleByAuthorityInput {
  authority: String!
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
}

"All input for the `deleteRoleByNodeId` mutation."
input DeleteRoleByNodeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `Role` to be deleted."
  nodeId: ID!
}

"All input for the `deleteRole` mutation."
input DeleteRoleInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  id: Int!
}

"All input for the `deleteRoomByNodeId` mutation."
input DeleteRoomByNodeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `Room` to be deleted."
  nodeId: ID!
}

"All input for the `deleteRoom` mutation."
input DeleteRoomInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  id: Int!
}

"All input for the `deleteSettingByNodeId` mutation."
input DeleteSettingByNodeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `Setting` to be deleted."
  nodeId: ID!
}

"All input for the `deleteSetting` mutation."
input DeleteSettingInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  id: Int!
}

"All input for the `deleteShirtOrderByNodeId` mutation."
input DeleteShirtOrderByNodeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `ShirtOrder` to be deleted."
  nodeId: ID!
}

"All input for the `deleteShirtOrder` mutation."
input DeleteShirtOrderInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  id: Int!
}

"All input for the `deleteShirtOrderItemByNodeId` mutation."
input DeleteShirtOrderItemByNodeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `ShirtOrderItem` to be deleted."
  nodeId: ID!
}

"All input for the `deleteShirtOrderItem` mutation."
input DeleteShirtOrderItemInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  id: Int!
}

"All input for the `deleteSlotByNodeId` mutation."
input DeleteSlotByNodeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `Slot` to be deleted."
  nodeId: ID!
}

"All input for the `deleteSlot` mutation."
input DeleteSlotInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  id: Int!
}

"All input for the `deleteTokenByNodeId` mutation."
input DeleteTokenByNodeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `Token` to be deleted."
  nodeId: ID!
}

"All input for the `deleteToken` mutation."
input DeleteTokenInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  id: Int!
}

"All input for the `deleteUserByNodeId` mutation."
input DeleteUserByNodeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `User` to be deleted."
  nodeId: ID!
}

"All input for the `deleteUserByUsername` mutation."
input DeleteUserByUsernameInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  username: String!
}

"All input for the `deleteUser` mutation."
input DeleteUserInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  id: Int!
}

"All input for the `deleteUserRoleByNodeId` mutation."
input DeleteUserRoleByNodeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `UserRole` to be deleted."
  nodeId: ID!
}

"All input for the `deleteUserRole` mutation."
input DeleteUserRoleInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  roleId: Int!
  userId: Int!
}

"All input for the `fTruncateTables` mutation."
input FTruncateTablesInput {
  _username: String
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
}

"A filter to be used against Float fields. All fields are combined with a logical and."
input FloatFilter {
  "Not equal to the specified value, treating null like an ordinary value."
  distinctFrom: Float
  "Equal to the specified value."
  equalTo: Float
  "Greater than the specified value."
  greaterThan: Float
  "Greater than or equal to the specified value."
  greaterThanOrEqualTo: Float
  "Included in the specified list."
  in: [Float!]
  "Is null (if `true` is specified) or is not null (if `false` is specified)."
  isNull: Boolean
  "Less than the specified value."
  lessThan: Float
  "Less than or equal to the specified value."
  lessThanOrEqualTo: Float
  "Equal to the specified value, treating null like an ordinary value."
  notDistinctFrom: Float
  "Not equal to the specified value."
  notEqualTo: Float
  "Not included in the specified list."
  notIn: [Float!]
}

"A condition to be used against `GameAssignment` object types. All fields are tested for equality and combined with a logical and."
input GameAssignmentCondition {
  "Checks for equality with the objects `gameId` field."
  gameId: Int
  "Checks for equality with the objects `gm` field."
  gm: Int
  "Checks for equality with the objects `memberId` field."
  memberId: Int
  "Checks for equality with the objects `year` field."
  year: Int
}

"A filter to be used against `GameAssignment` object types. All fields are combined with a logical and."
input GameAssignmentFilter {
  "Checks for all expressions in this list."
  and: [GameAssignmentFilter!]
  "Filter by the objects `gameId` field."
  gameId: IntFilter
  "Filter by the objects `gm` field."
  gm: IntFilter
  "Filter by the objects `memberId` field."
  memberId: IntFilter
  "Negates the expression."
  not: GameAssignmentFilter
  "Checks for any expressions in this list."
  or: [GameAssignmentFilter!]
  "Filter by the objects `year` field."
  year: IntFilter
}

"An input for mutations affecting `GameAssignment`"
input GameAssignmentInput {
  gameId: Int!
  gm: Int!
  memberId: Int!
  year: Int!
}

"Represents an update to a `GameAssignment`. Fields that are set will be updated."
input GameAssignmentPatch {
  gameId: Int
  gm: Int
  memberId: Int
  year: Int
}

"A condition to be used against `GameChoice` object types. All fields are tested for equality and combined with a logical and."
input GameChoiceCondition {
  "Checks for equality with the objects `gameId` field."
  gameId: Int
  "Checks for equality with the objects `id` field."
  id: Int
  "Checks for equality with the objects `memberId` field."
  memberId: Int
  "Checks for equality with the objects `rank` field."
  rank: Int
  "Checks for equality with the objects `returningPlayer` field."
  returningPlayer: Boolean
  "Checks for equality with the objects `slotId` field."
  slotId: Int
  "Checks for equality with the objects `year` field."
  year: Int
}

"A filter to be used against `GameChoice` object types. All fields are combined with a logical and."
input GameChoiceFilter {
  "Checks for all expressions in this list."
  and: [GameChoiceFilter!]
  "Filter by the objects `gameId` field."
  gameId: IntFilter
  "Filter by the objects `id` field."
  id: IntFilter
  "Filter by the objects `memberId` field."
  memberId: IntFilter
  "Negates the expression."
  not: GameChoiceFilter
  "Checks for any expressions in this list."
  or: [GameChoiceFilter!]
  "Filter by the objects `rank` field."
  rank: IntFilter
  "Filter by the objects `returningPlayer` field."
  returningPlayer: BooleanFilter
  "Filter by the objects `slotId` field."
  slotId: IntFilter
  "Filter by the objects `year` field."
  year: IntFilter
}

"An input for mutations affecting `GameChoice`"
input GameChoiceInput {
  gameId: Int
  id: Int
  memberId: Int!
  rank: Int!
  returningPlayer: Boolean!
  slotId: Int!
  year: Int!
}

"Represents an update to a `GameChoice`. Fields that are set will be updated."
input GameChoicePatch {
  gameId: Int
  id: Int
  memberId: Int
  rank: Int
  returningPlayer: Boolean
  slotId: Int
  year: Int
}

"A condition to be used against `Game` object types. All fields are tested for equality and combined with a logical and."
input GameCondition {
  "Checks for equality with the objects `authorId` field."
  authorId: Int
  "Checks for equality with the objects `charInstructions` field."
  charInstructions: String
  "Checks for equality with the objects `description` field."
  description: String
  "Checks for equality with the objects `estimatedLength` field."
  estimatedLength: String
  "Checks for equality with the objects `gameContactEmail` field."
  gameContactEmail: String
  "Checks for equality with the objects `genre` field."
  genre: String
  "Checks for equality with the objects `gmNames` field."
  gmNames: String
  "Checks for equality with the objects `id` field."
  id: Int
  "Checks for equality with the objects `lateFinish` field."
  lateFinish: Boolean
  "Checks for equality with the objects `lateStart` field."
  lateStart: String
  "Checks for equality with the objects `message` field."
  message: String
  "Checks for equality with the objects `name` field."
  name: String
  "Checks for equality with the objects `playerMax` field."
  playerMax: Int
  "Checks for equality with the objects `playerMin` field."
  playerMin: Int
  "Checks for equality with the objects `playerPreference` field."
  playerPreference: String
  "Checks for equality with the objects `playersContactGm` field."
  playersContactGm: Boolean
  "Checks for equality with the objects `returningPlayers` field."
  returningPlayers: String
  "Checks for equality with the objects `roomId` field."
  roomId: Int
  "Checks for equality with the objects `setting` field."
  setting: String
  "Checks for equality with the objects `shortName` field."
  shortName: String
  "Checks for equality with the objects `slotConflicts` field."
  slotConflicts: String
  "Checks for equality with the objects `slotId` field."
  slotId: Int
  "Checks for equality with the objects `slotPreference` field."
  slotPreference: Int
  "Checks for equality with the objects `teenFriendly` field."
  teenFriendly: Boolean
  "Checks for equality with the objects `type` field."
  type: String
  "Checks for equality with the objects `year` field."
  year: Int
}

"A filter to be used against `Game` object types. All fields are combined with a logical and."
input GameFilter {
  "Checks for all expressions in this list."
  and: [GameFilter!]
  "Filter by the objects `authorId` field."
  authorId: IntFilter
  "Filter by the objects `charInstructions` field."
  charInstructions: StringFilter
  "Filter by the objects `description` field."
  description: StringFilter
  "Filter by the objects `estimatedLength` field."
  estimatedLength: StringFilter
  "Filter by the objects `gameContactEmail` field."
  gameContactEmail: StringFilter
  "Filter by the objects `genre` field."
  genre: StringFilter
  "Filter by the objects `gmNames` field."
  gmNames: StringFilter
  "Filter by the objects `id` field."
  id: IntFilter
  "Filter by the objects `lateFinish` field."
  lateFinish: BooleanFilter
  "Filter by the objects `lateStart` field."
  lateStart: StringFilter
  "Filter by the objects `message` field."
  message: StringFilter
  "Filter by the objects `name` field."
  name: StringFilter
  "Negates the expression."
  not: GameFilter
  "Checks for any expressions in this list."
  or: [GameFilter!]
  "Filter by the objects `playerMax` field."
  playerMax: IntFilter
  "Filter by the objects `playerMin` field."
  playerMin: IntFilter
  "Filter by the objects `playerPreference` field."
  playerPreference: StringFilter
  "Filter by the objects `playersContactGm` field."
  playersContactGm: BooleanFilter
  "Filter by the objects `returningPlayers` field."
  returningPlayers: StringFilter
  "Filter by the objects `roomId` field."
  roomId: IntFilter
  "Filter by the objects `setting` field."
  setting: StringFilter
  "Filter by the objects `shortName` field."
  shortName: StringFilter
  "Filter by the objects `slotConflicts` field."
  slotConflicts: StringFilter
  "Filter by the objects `slotId` field."
  slotId: IntFilter
  "Filter by the objects `slotPreference` field."
  slotPreference: IntFilter
  "Filter by the objects `teenFriendly` field."
  teenFriendly: BooleanFilter
  "Filter by the objects `type` field."
  type: StringFilter
  "Filter by the objects `year` field."
  year: IntFilter
}

"An input for mutations affecting `Game`"
input GameInput {
  authorId: Int
  charInstructions: String!
  description: String!
  estimatedLength: String!
  gameContactEmail: String!
  genre: String!
  gmNames: String
  id: Int
  lateFinish: Boolean
  lateStart: String
  message: String!
  name: String!
  playerMax: Int!
  playerMin: Int!
  playerPreference: String!
  playersContactGm: Boolean!
  returningPlayers: String!
  roomId: Int
  setting: String!
  shortName: String
  slotConflicts: String!
  slotId: Int
  slotPreference: Int!
  teenFriendly: Boolean!
  type: String!
  year: Int!
}

"Represents an update to a `Game`. Fields that are set will be updated."
input GamePatch {
  authorId: Int
  charInstructions: String
  description: String
  estimatedLength: String
  gameContactEmail: String
  genre: String
  gmNames: String
  id: Int
  lateFinish: Boolean
  lateStart: String
  message: String
  name: String
  playerMax: Int
  playerMin: Int
  playerPreference: String
  playersContactGm: Boolean
  returningPlayers: String
  roomId: Int
  setting: String
  shortName: String
  slotConflicts: String
  slotId: Int
  slotPreference: Int
  teenFriendly: Boolean
  type: String
  year: Int
}

"A condition to be used against `GameSubmission` object types. All fields are tested for equality and combined with a logical and."
input GameSubmissionCondition {
  "Checks for equality with the objects `id` field."
  id: Int
  "Checks for equality with the objects `memberId` field."
  memberId: Int
  "Checks for equality with the objects `message` field."
  message: String
  "Checks for equality with the objects `year` field."
  year: Int
}

"A filter to be used against `GameSubmission` object types. All fields are combined with a logical and."
input GameSubmissionFilter {
  "Checks for all expressions in this list."
  and: [GameSubmissionFilter!]
  "Filter by the objects `id` field."
  id: IntFilter
  "Filter by the objects `memberId` field."
  memberId: IntFilter
  "Filter by the objects `message` field."
  message: StringFilter
  "Negates the expression."
  not: GameSubmissionFilter
  "Checks for any expressions in this list."
  or: [GameSubmissionFilter!]
  "Filter by the objects `year` field."
  year: IntFilter
}

"An input for mutations affecting `GameSubmission`"
input GameSubmissionInput {
  id: Int
  memberId: Int!
  message: String!
  year: Int!
}

"Represents an update to a `GameSubmission`. Fields that are set will be updated."
input GameSubmissionPatch {
  id: Int
  memberId: Int
  message: String
  year: Int
}

"A condition to be used against `HotelRoom` object types. All fields are tested for equality and combined with a logical and."
input HotelRoomCondition {
  "Checks for equality with the objects `bathroomType` field."
  bathroomType: String
  "Checks for equality with the objects `description` field."
  description: String
  "Checks for equality with the objects `gamingRoom` field."
  gamingRoom: Boolean
  "Checks for equality with the objects `id` field."
  id: Int
  "Checks for equality with the objects `occupancy` field."
  occupancy: String
  "Checks for equality with the objects `quantity` field."
  quantity: Int
  "Checks for equality with the objects `rate` field."
  rate: String
  "Checks for equality with the objects `type` field."
  type: String
}

"A condition to be used against `HotelRoomDetail` object types. All fields are tested for equality and combined with a logical and."
input HotelRoomDetailCondition {
  "Checks for equality with the objects `bathroomType` field."
  bathroomType: String
  "Checks for equality with the objects `comment` field."
  comment: String
  "Checks for equality with the objects `enabled` field."
  enabled: Boolean
  "Checks for equality with the objects `formattedRoomType` field."
  formattedRoomType: String
  "Checks for equality with the objects `gamingRoom` field."
  gamingRoom: Boolean
  "Checks for equality with the objects `id` field."
  id: BigInt
  "Checks for equality with the objects `internalRoomType` field."
  internalRoomType: String
  "Checks for equality with the objects `name` field."
  name: String
  "Checks for equality with the objects `reserved` field."
  reserved: Boolean
  "Checks for equality with the objects `reservedFor` field."
  reservedFor: String
  "Checks for equality with the objects `roomType` field."
  roomType: String
  "Checks for equality with the objects `version` field."
  version: BigInt
}

"A filter to be used against `HotelRoomDetail` object types. All fields are combined with a logical and."
input HotelRoomDetailFilter {
  "Checks for all expressions in this list."
  and: [HotelRoomDetailFilter!]
  "Filter by the objects `bathroomType` field."
  bathroomType: StringFilter
  "Filter by the objects `comment` field."
  comment: StringFilter
  "Filter by the objects `enabled` field."
  enabled: BooleanFilter
  "Filter by the objects `formattedRoomType` field."
  formattedRoomType: StringFilter
  "Filter by the objects `gamingRoom` field."
  gamingRoom: BooleanFilter
  "Filter by the objects `id` field."
  id: BigIntFilter
  "Filter by the objects `internalRoomType` field."
  internalRoomType: StringFilter
  "Filter by the objects `name` field."
  name: StringFilter
  "Negates the expression."
  not: HotelRoomDetailFilter
  "Checks for any expressions in this list."
  or: [HotelRoomDetailFilter!]
  "Filter by the objects `reserved` field."
  reserved: BooleanFilter
  "Filter by the objects `reservedFor` field."
  reservedFor: StringFilter
  "Filter by the objects `roomType` field."
  roomType: StringFilter
  "Filter by the objects `version` field."
  version: BigIntFilter
}

"An input for mutations affecting `HotelRoomDetail`"
input HotelRoomDetailInput {
  bathroomType: String!
  comment: String!
  enabled: Boolean!
  formattedRoomType: String!
  gamingRoom: Boolean!
  id: BigInt
  internalRoomType: String!
  name: String!
  reserved: Boolean!
  reservedFor: String!
  roomType: String!
  version: BigInt!
}

"Represents an update to a `HotelRoomDetail`. Fields that are set will be updated."
input HotelRoomDetailPatch {
  bathroomType: String
  comment: String
  enabled: Boolean
  formattedRoomType: String
  gamingRoom: Boolean
  id: BigInt
  internalRoomType: String
  name: String
  reserved: Boolean
  reservedFor: String
  roomType: String
  version: BigInt
}

"A filter to be used against `HotelRoom` object types. All fields are combined with a logical and."
input HotelRoomFilter {
  "Checks for all expressions in this list."
  and: [HotelRoomFilter!]
  "Filter by the objects `bathroomType` field."
  bathroomType: StringFilter
  "Filter by the objects `description` field."
  description: StringFilter
  "Filter by the objects `gamingRoom` field."
  gamingRoom: BooleanFilter
  "Filter by the objects `id` field."
  id: IntFilter
  "Negates the expression."
  not: HotelRoomFilter
  "Filter by the objects `occupancy` field."
  occupancy: StringFilter
  "Checks for any expressions in this list."
  or: [HotelRoomFilter!]
  "Filter by the objects `quantity` field."
  quantity: IntFilter
  "Filter by the objects `rate` field."
  rate: StringFilter
  "Filter by the objects `type` field."
  type: StringFilter
}

"An input for mutations affecting `HotelRoom`"
input HotelRoomInput {
  bathroomType: String!
  description: String!
  gamingRoom: Boolean!
  id: Int
  occupancy: String!
  quantity: Int!
  rate: String!
  type: String!
}

"Represents an update to a `HotelRoom`. Fields that are set will be updated."
input HotelRoomPatch {
  bathroomType: String
  description: String
  gamingRoom: Boolean
  id: Int
  occupancy: String
  quantity: Int
  rate: String
  type: String
}

"A filter to be used against Int fields. All fields are combined with a logical and."
input IntFilter {
  "Not equal to the specified value, treating null like an ordinary value."
  distinctFrom: Int
  "Equal to the specified value."
  equalTo: Int
  "Greater than the specified value."
  greaterThan: Int
  "Greater than or equal to the specified value."
  greaterThanOrEqualTo: Int
  "Included in the specified list."
  in: [Int!]
  "Is null (if `true` is specified) or is not null (if `false` is specified)."
  isNull: Boolean
  "Less than the specified value."
  lessThan: Int
  "Less than or equal to the specified value."
  lessThanOrEqualTo: Int
  "Equal to the specified value, treating null like an ordinary value."
  notDistinctFrom: Int
  "Not equal to the specified value."
  notEqualTo: Int
  "Not included in the specified list."
  notIn: [Int!]
}

"A condition to be used against `Lookup` object types. All fields are tested for equality and combined with a logical and."
input LookupCondition {
  "Checks for equality with the objects `codeMaximum` field."
  codeMaximum: String
  "Checks for equality with the objects `codeMinimum` field."
  codeMinimum: String
  "Checks for equality with the objects `codeScale` field."
  codeScale: Int
  "Checks for equality with the objects `codeType` field."
  codeType: String
  "Checks for equality with the objects `id` field."
  id: Int
  "Checks for equality with the objects `internationalize` field."
  internationalize: Boolean
  "Checks for equality with the objects `ordering` field."
  ordering: String
  "Checks for equality with the objects `realm` field."
  realm: String
  "Checks for equality with the objects `valueMaximum` field."
  valueMaximum: String
  "Checks for equality with the objects `valueMinimum` field."
  valueMinimum: String
  "Checks for equality with the objects `valueScale` field."
  valueScale: Int
  "Checks for equality with the objects `valueType` field."
  valueType: String
}

"A filter to be used against `Lookup` object types. All fields are combined with a logical and."
input LookupFilter {
  "Checks for all expressions in this list."
  and: [LookupFilter!]
  "Filter by the objects `codeMaximum` field."
  codeMaximum: StringFilter
  "Filter by the objects `codeMinimum` field."
  codeMinimum: StringFilter
  "Filter by the objects `codeScale` field."
  codeScale: IntFilter
  "Filter by the objects `codeType` field."
  codeType: StringFilter
  "Filter by the objects `id` field."
  id: IntFilter
  "Filter by the objects `internationalize` field."
  internationalize: BooleanFilter
  "Negates the expression."
  not: LookupFilter
  "Checks for any expressions in this list."
  or: [LookupFilter!]
  "Filter by the objects `ordering` field."
  ordering: StringFilter
  "Filter by the objects `realm` field."
  realm: StringFilter
  "Filter by the objects `valueMaximum` field."
  valueMaximum: StringFilter
  "Filter by the objects `valueMinimum` field."
  valueMinimum: StringFilter
  "Filter by the objects `valueScale` field."
  valueScale: IntFilter
  "Filter by the objects `valueType` field."
  valueType: StringFilter
}

"An input for mutations affecting `Lookup`"
input LookupInput {
  codeMaximum: String
  codeMinimum: String
  codeScale: Int
  codeType: String!
  id: Int
  internationalize: Boolean!
  ordering: String!
  realm: String!
  valueMaximum: String
  valueMinimum: String
  valueScale: Int
  valueType: String!
}

"Represents an update to a `Lookup`. Fields that are set will be updated."
input LookupPatch {
  codeMaximum: String
  codeMinimum: String
  codeScale: Int
  codeType: String
  id: Int
  internationalize: Boolean
  ordering: String
  realm: String
  valueMaximum: String
  valueMinimum: String
  valueScale: Int
  valueType: String
}

"A condition to be used against `LookupValue` object types. All fields are tested for equality and combined with a logical and."
input LookupValueCondition {
  "Checks for equality with the objects `code` field."
  code: String
  "Checks for equality with the objects `id` field."
  id: Int
  "Checks for equality with the objects `lookupId` field."
  lookupId: Int
  "Checks for equality with the objects `numericSequencer` field."
  numericSequencer: BigFloat
  "Checks for equality with the objects `sequencer` field."
  sequencer: Int
  "Checks for equality with the objects `stringSequencer` field."
  stringSequencer: String
  "Checks for equality with the objects `value` field."
  value: String
}

"A filter to be used against `LookupValue` object types. All fields are combined with a logical and."
input LookupValueFilter {
  "Checks for all expressions in this list."
  and: [LookupValueFilter!]
  "Filter by the objects `code` field."
  code: StringFilter
  "Filter by the objects `id` field."
  id: IntFilter
  "Filter by the objects `lookupId` field."
  lookupId: IntFilter
  "Negates the expression."
  not: LookupValueFilter
  "Filter by the objects `numericSequencer` field."
  numericSequencer: BigFloatFilter
  "Checks for any expressions in this list."
  or: [LookupValueFilter!]
  "Filter by the objects `sequencer` field."
  sequencer: IntFilter
  "Filter by the objects `stringSequencer` field."
  stringSequencer: StringFilter
  "Filter by the objects `value` field."
  value: StringFilter
}

"An input for mutations affecting `LookupValue`"
input LookupValueInput {
  code: String!
  id: Int
  lookupId: Int!
  numericSequencer: BigFloat!
  sequencer: Int!
  stringSequencer: String!
  value: String!
}

"Represents an update to a `LookupValue`. Fields that are set will be updated."
input LookupValuePatch {
  code: String
  id: Int
  lookupId: Int
  numericSequencer: BigFloat
  sequencer: Int
  stringSequencer: String
  value: String
}

"A condition to be used against `MemberHotelRoomAssignment` object types. All fields are tested for equality and combined with a logical and."
input MemberHotelRoomAssignmentCondition {
  "Checks for equality with the objects `hotelRoomId` field."
  hotelRoomId: BigInt
  "Checks for equality with the objects `memberId` field."
  memberId: BigInt
  "Checks for equality with the objects `roomOwner` field."
  roomOwner: Boolean
  "Checks for equality with the objects `year` field."
  year: Int
}

"A filter to be used against `MemberHotelRoomAssignment` object types. All fields are combined with a logical and."
input MemberHotelRoomAssignmentFilter {
  "Checks for all expressions in this list."
  and: [MemberHotelRoomAssignmentFilter!]
  "Filter by the objects `hotelRoomId` field."
  hotelRoomId: BigIntFilter
  "Filter by the objects `memberId` field."
  memberId: BigIntFilter
  "Negates the expression."
  not: MemberHotelRoomAssignmentFilter
  "Checks for any expressions in this list."
  or: [MemberHotelRoomAssignmentFilter!]
  "Filter by the objects `roomOwner` field."
  roomOwner: BooleanFilter
  "Filter by the objects `year` field."
  year: IntFilter
}

"An input for mutations affecting `MemberHotelRoomAssignment`"
input MemberHotelRoomAssignmentInput {
  hotelRoomId: BigInt!
  memberId: BigInt!
  roomOwner: Boolean!
  year: Int!
}

"Represents an update to a `MemberHotelRoomAssignment`. Fields that are set will be updated."
input MemberHotelRoomAssignmentPatch {
  hotelRoomId: BigInt
  memberId: BigInt
  roomOwner: Boolean
  year: Int
}

"A condition to be used against `Membership` object types. All fields are tested for equality and combined with a logical and."
input MembershipCondition {
  "Checks for equality with the objects `amountOwed` field."
  amountOwed: Float
  "Checks for equality with the objects `amountPaid` field."
  amountPaid: Float
  "Checks for equality with the objects `arrivalDate` field."
  arrivalDate: Datetime
  "Checks for equality with the objects `attendance` field."
  attendance: String
  "Checks for equality with the objects `attending` field."
  attending: Boolean
  "Checks for equality with the objects `departureDate` field."
  departureDate: Datetime
  "Checks for equality with the objects `hotelRoomId` field."
  hotelRoomId: Int
  "Checks for equality with the objects `id` field."
  id: Int
  "Checks for equality with the objects `interestLevel` field."
  interestLevel: String
  "Checks for equality with the objects `message` field."
  message: String
  "Checks for equality with the objects `offerSubsidy` field."
  offerSubsidy: Boolean
  "Checks for equality with the objects `requestOldPrice` field."
  requestOldPrice: Boolean
  "Checks for equality with the objects `roomPreferenceAndNotes` field."
  roomPreferenceAndNotes: String
  "Checks for equality with the objects `roomingPreferences` field."
  roomingPreferences: String
  "Checks for equality with the objects `roomingWith` field."
  roomingWith: String
  "Checks for equality with the objects `userId` field."
  userId: Int
  "Checks for equality with the objects `volunteer` field."
  volunteer: Boolean
  "Checks for equality with the objects `year` field."
  year: Int
}

"A filter to be used against `Membership` object types. All fields are combined with a logical and."
input MembershipFilter {
  "Filter by the objects `amountOwed` field."
  amountOwed: FloatFilter
  "Filter by the objects `amountPaid` field."
  amountPaid: FloatFilter
  "Checks for all expressions in this list."
  and: [MembershipFilter!]
  "Filter by the objects `arrivalDate` field."
  arrivalDate: DatetimeFilter
  "Filter by the objects `attendance` field."
  attendance: StringFilter
  "Filter by the objects `attending` field."
  attending: BooleanFilter
  "Filter by the objects `departureDate` field."
  departureDate: DatetimeFilter
  "Filter by the objects `hotelRoomId` field."
  hotelRoomId: IntFilter
  "Filter by the objects `id` field."
  id: IntFilter
  "Filter by the objects `interestLevel` field."
  interestLevel: StringFilter
  "Filter by the objects `message` field."
  message: StringFilter
  "Negates the expression."
  not: MembershipFilter
  "Filter by the objects `offerSubsidy` field."
  offerSubsidy: BooleanFilter
  "Checks for any expressions in this list."
  or: [MembershipFilter!]
  "Filter by the objects `requestOldPrice` field."
  requestOldPrice: BooleanFilter
  "Filter by the objects `roomPreferenceAndNotes` field."
  roomPreferenceAndNotes: StringFilter
  "Filter by the objects `roomingPreferences` field."
  roomingPreferences: StringFilter
  "Filter by the objects `roomingWith` field."
  roomingWith: StringFilter
  "Filter by the objects `userId` field."
  userId: IntFilter
  "Filter by the objects `volunteer` field."
  volunteer: BooleanFilter
  "Filter by the objects `year` field."
  year: IntFilter
}

"An input for mutations affecting `Membership`"
input MembershipInput {
  amountOwed: Float!
  amountPaid: Float!
  arrivalDate: Datetime!
  attendance: String!
  attending: Boolean!
  departureDate: Datetime!
  hotelRoomId: Int!
  id: Int
  interestLevel: String!
  message: String!
  offerSubsidy: Boolean!
  requestOldPrice: Boolean!
  roomPreferenceAndNotes: String!
  roomingPreferences: String!
  roomingWith: String!
  userId: Int!
  volunteer: Boolean!
  year: Int!
}

"Represents an update to a `Membership`. Fields that are set will be updated."
input MembershipPatch {
  amountOwed: Float
  amountPaid: Float
  arrivalDate: Datetime
  attendance: String
  attending: Boolean
  departureDate: Datetime
  hotelRoomId: Int
  id: Int
  interestLevel: String
  message: String
  offerSubsidy: Boolean
  requestOldPrice: Boolean
  roomPreferenceAndNotes: String
  roomingPreferences: String
  roomingWith: String
  userId: Int
  volunteer: Boolean
  year: Int
}

"A condition to be used against `Profile` object types. All fields are tested for equality and combined with a logical and."
input ProfileCondition {
  "Checks for equality with the objects `email` field."
  email: String
  "Checks for equality with the objects `fullName` field."
  fullName: String
  "Checks for equality with the objects `id` field."
  id: Int
  "Checks for equality with the objects `phoneNumber` field."
  phoneNumber: String
  "Checks for equality with the objects `snailMailAddress` field."
  snailMailAddress: String
}

"A filter to be used against `Profile` object types. All fields are combined with a logical and."
input ProfileFilter {
  "Checks for all expressions in this list."
  and: [ProfileFilter!]
  "Filter by the objects `email` field."
  email: StringFilter
  "Filter by the objects `fullName` field."
  fullName: StringFilter
  "Filter by the objects `id` field."
  id: IntFilter
  "Negates the expression."
  not: ProfileFilter
  "Checks for any expressions in this list."
  or: [ProfileFilter!]
  "Filter by the objects `phoneNumber` field."
  phoneNumber: StringFilter
  "Filter by the objects `snailMailAddress` field."
  snailMailAddress: StringFilter
}

"An input for mutations affecting `Profile`"
input ProfileInput {
  email: String!
  fullName: String!
  id: Int
  phoneNumber: String
  snailMailAddress: String
}

"Represents an update to a `Profile`. Fields that are set will be updated."
input ProfilePatch {
  email: String
  fullName: String
  id: Int
  phoneNumber: String
  snailMailAddress: String
}

"A condition to be used against `RegistrationCode` object types. All fields are tested for equality and combined with a logical and."
input RegistrationCodeCondition {
  "Checks for equality with the objects `id` field."
  id: Int
  "Checks for equality with the objects `token` field."
  token: String
  "Checks for equality with the objects `username` field."
  username: String
}

"A filter to be used against `RegistrationCode` object types. All fields are combined with a logical and."
input RegistrationCodeFilter {
  "Checks for all expressions in this list."
  and: [RegistrationCodeFilter!]
  "Filter by the objects `id` field."
  id: IntFilter
  "Negates the expression."
  not: RegistrationCodeFilter
  "Checks for any expressions in this list."
  or: [RegistrationCodeFilter!]
  "Filter by the objects `token` field."
  token: StringFilter
  "Filter by the objects `username` field."
  username: StringFilter
}

"An input for mutations affecting `RegistrationCode`"
input RegistrationCodeInput {
  id: Int
  token: String!
  username: String!
}

"Represents an update to a `RegistrationCode`. Fields that are set will be updated."
input RegistrationCodePatch {
  id: Int
  token: String
  username: String
}

"A condition to be used against `Role` object types. All fields are tested for equality and combined with a logical and."
input RoleCondition {
  "Checks for equality with the objects `authority` field."
  authority: String
  "Checks for equality with the objects `id` field."
  id: Int
}

"A filter to be used against `Role` object types. All fields are combined with a logical and."
input RoleFilter {
  "Checks for all expressions in this list."
  and: [RoleFilter!]
  "Filter by the objects `authority` field."
  authority: StringFilter
  "Filter by the objects `id` field."
  id: IntFilter
  "Negates the expression."
  not: RoleFilter
  "Checks for any expressions in this list."
  or: [RoleFilter!]
}

"An input for mutations affecting `Role`"
input RoleInput {
  authority: String!
  id: Int
}

"Represents an update to a `Role`. Fields that are set will be updated."
input RolePatch {
  authority: String
  id: Int
}

"A condition to be used against `Room` object types. All fields are tested for equality and combined with a logical and."
input RoomCondition {
  "Checks for equality with the objects `description` field."
  description: String
  "Checks for equality with the objects `id` field."
  id: Int
  "Checks for equality with the objects `size` field."
  size: Int
  "Checks for equality with the objects `type` field."
  type: String
  "Checks for equality with the objects `updated` field."
  updated: Boolean
}

"A filter to be used against `Room` object types. All fields are combined with a logical and."
input RoomFilter {
  "Checks for all expressions in this list."
  and: [RoomFilter!]
  "Filter by the objects `description` field."
  description: StringFilter
  "Filter by the objects `id` field."
  id: IntFilter
  "Negates the expression."
  not: RoomFilter
  "Checks for any expressions in this list."
  or: [RoomFilter!]
  "Filter by the objects `size` field."
  size: IntFilter
  "Filter by the objects `type` field."
  type: StringFilter
  "Filter by the objects `updated` field."
  updated: BooleanFilter
}

"An input for mutations affecting `Room`"
input RoomInput {
  description: String!
  id: Int
  size: Int!
  type: String!
  updated: Boolean!
}

"Represents an update to a `Room`. Fields that are set will be updated."
input RoomPatch {
  description: String
  id: Int
  size: Int
  type: String
  updated: Boolean
}

"A condition to be used against `Setting` object types. All fields are tested for equality and combined with a logical and."
input SettingCondition {
  "Checks for equality with the objects `code` field."
  code: String
  "Checks for equality with the objects `id` field."
  id: Int
  "Checks for equality with the objects `type` field."
  type: String
  "Checks for equality with the objects `value` field."
  value: String
}

"A filter to be used against `Setting` object types. All fields are combined with a logical and."
input SettingFilter {
  "Checks for all expressions in this list."
  and: [SettingFilter!]
  "Filter by the objects `code` field."
  code: StringFilter
  "Filter by the objects `id` field."
  id: IntFilter
  "Negates the expression."
  not: SettingFilter
  "Checks for any expressions in this list."
  or: [SettingFilter!]
  "Filter by the objects `type` field."
  type: StringFilter
  "Filter by the objects `value` field."
  value: StringFilter
}

"An input for mutations affecting `Setting`"
input SettingInput {
  code: String!
  id: Int
  type: String!
  value: String!
}

"Represents an update to a `Setting`. Fields that are set will be updated."
input SettingPatch {
  code: String
  id: Int
  type: String
  value: String
}

"A condition to be used against `ShirtOrder` object types. All fields are tested for equality and combined with a logical and."
input ShirtOrderCondition {
  "Checks for equality with the objects `deliveryMethod` field."
  deliveryMethod: String
  "Checks for equality with the objects `id` field."
  id: Int
  "Checks for equality with the objects `message` field."
  message: String
  "Checks for equality with the objects `userId` field."
  userId: Int
  "Checks for equality with the objects `year` field."
  year: Int
}

"A filter to be used against `ShirtOrder` object types. All fields are combined with a logical and."
input ShirtOrderFilter {
  "Checks for all expressions in this list."
  and: [ShirtOrderFilter!]
  "Filter by the objects `deliveryMethod` field."
  deliveryMethod: StringFilter
  "Filter by the objects `id` field."
  id: IntFilter
  "Filter by the objects `message` field."
  message: StringFilter
  "Negates the expression."
  not: ShirtOrderFilter
  "Checks for any expressions in this list."
  or: [ShirtOrderFilter!]
  "Filter by the objects `userId` field."
  userId: IntFilter
  "Filter by the objects `year` field."
  year: IntFilter
}

"An input for mutations affecting `ShirtOrder`"
input ShirtOrderInput {
  deliveryMethod: String!
  id: Int
  message: String!
  userId: Int!
  year: Int!
}

"A condition to be used against `ShirtOrderItem` object types. All fields are tested for equality and combined with a logical and."
input ShirtOrderItemCondition {
  "Checks for equality with the objects `id` field."
  id: Int
  "Checks for equality with the objects `itemsIdx` field."
  itemsIdx: Int
  "Checks for equality with the objects `orderId` field."
  orderId: Int
  "Checks for equality with the objects `quantity` field."
  quantity: Int
  "Checks for equality with the objects `size` field."
  size: String
  "Checks for equality with the objects `style` field."
  style: String
}

"A filter to be used against `ShirtOrderItem` object types. All fields are combined with a logical and."
input ShirtOrderItemFilter {
  "Checks for all expressions in this list."
  and: [ShirtOrderItemFilter!]
  "Filter by the objects `id` field."
  id: IntFilter
  "Filter by the objects `itemsIdx` field."
  itemsIdx: IntFilter
  "Negates the expression."
  not: ShirtOrderItemFilter
  "Checks for any expressions in this list."
  or: [ShirtOrderItemFilter!]
  "Filter by the objects `orderId` field."
  orderId: IntFilter
  "Filter by the objects `quantity` field."
  quantity: IntFilter
  "Filter by the objects `size` field."
  size: StringFilter
  "Filter by the objects `style` field."
  style: StringFilter
}

"An input for mutations affecting `ShirtOrderItem`"
input ShirtOrderItemInput {
  id: Int
  itemsIdx: Int
  orderId: Int!
  quantity: Int!
  size: String!
  style: String!
}

"Represents an update to a `ShirtOrderItem`. Fields that are set will be updated."
input ShirtOrderItemPatch {
  id: Int
  itemsIdx: Int
  orderId: Int
  quantity: Int
  size: String
  style: String
}

"Represents an update to a `ShirtOrder`. Fields that are set will be updated."
input ShirtOrderPatch {
  deliveryMethod: String
  id: Int
  message: String
  userId: Int
  year: Int
}

"A condition to be used against `Slot` object types. All fields are tested for equality and combined with a logical and."
input SlotCondition {
  "Checks for equality with the objects `day` field."
  day: String
  "Checks for equality with the objects `formattedDate` field."
  formattedDate: String
  "Checks for equality with the objects `id` field."
  id: Int
  "Checks for equality with the objects `length` field."
  length: String
  "Checks for equality with the objects `slot` field."
  slot: Int
  "Checks for equality with the objects `time` field."
  time: String
}

"A filter to be used against `Slot` object types. All fields are combined with a logical and."
input SlotFilter {
  "Checks for all expressions in this list."
  and: [SlotFilter!]
  "Filter by the objects `day` field."
  day: StringFilter
  "Filter by the objects `formattedDate` field."
  formattedDate: StringFilter
  "Filter by the objects `id` field."
  id: IntFilter
  "Filter by the objects `length` field."
  length: StringFilter
  "Negates the expression."
  not: SlotFilter
  "Checks for any expressions in this list."
  or: [SlotFilter!]
  "Filter by the objects `slot` field."
  slot: IntFilter
  "Filter by the objects `time` field."
  time: StringFilter
}

"An input for mutations affecting `Slot`"
input SlotInput {
  day: String!
  formattedDate: String!
  id: Int
  length: String!
  slot: Int!
  time: String!
}

"Represents an update to a `Slot`. Fields that are set will be updated."
input SlotPatch {
  day: String
  formattedDate: String
  id: Int
  length: String
  slot: Int
  time: String
}

"A filter to be used against String fields. All fields are combined with a logical and."
input StringFilter {
  "Not equal to the specified value, treating null like an ordinary value."
  distinctFrom: String
  "Ends with the specified string (case-sensitive)."
  endsWith: String
  "Ends with the specified string (case-insensitive)."
  endsWithInsensitive: String
  "Equal to the specified value."
  equalTo: String
  "Greater than the specified value."
  greaterThan: String
  "Greater than or equal to the specified value."
  greaterThanOrEqualTo: String
  "Included in the specified list."
  in: [String!]
  "Contains the specified string (case-sensitive)."
  includes: String
  "Contains the specified string (case-insensitive)."
  includesInsensitive: String
  "Is null (if `true` is specified) or is not null (if `false` is specified)."
  isNull: Boolean
  "Less than the specified value."
  lessThan: String
  "Less than or equal to the specified value."
  lessThanOrEqualTo: String
  "Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters."
  like: String
  "Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters."
  likeInsensitive: String
  "Equal to the specified value, treating null like an ordinary value."
  notDistinctFrom: String
  "Does not end with the specified string (case-sensitive)."
  notEndsWith: String
  "Does not end with the specified string (case-insensitive)."
  notEndsWithInsensitive: String
  "Not equal to the specified value."
  notEqualTo: String
  "Not included in the specified list."
  notIn: [String!]
  "Does not contain the specified string (case-sensitive)."
  notIncludes: String
  "Does not contain the specified string (case-insensitive)."
  notIncludesInsensitive: String
  "Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters."
  notLike: String
  "Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters."
  notLikeInsensitive: String
  "Does not match the specified pattern using the SQL standard's definition of a regular expression."
  notSimilarTo: String
  "Does not start with the specified string (case-sensitive)."
  notStartsWith: String
  "Does not start with the specified string (case-insensitive)."
  notStartsWithInsensitive: String
  "Matches the specified pattern using the SQL standard's definition of a regular expression."
  similarTo: String
  "Starts with the specified string (case-sensitive)."
  startsWith: String
  "Starts with the specified string (case-insensitive)."
  startsWithInsensitive: String
}

"A condition to be used against `Token` object types. All fields are tested for equality and combined with a logical and."
input TokenCondition {
  "Checks for equality with the objects `active` field."
  active: Boolean
  "Checks for equality with the objects `cuid` field."
  cuid: String
  "Checks for equality with the objects `id` field."
  id: Int
  "Checks for equality with the objects `lastUsed` field."
  lastUsed: Datetime
  "Checks for equality with the objects `userId` field."
  userId: Int
}

"A filter to be used against `Token` object types. All fields are combined with a logical and."
input TokenFilter {
  "Filter by the objects `active` field."
  active: BooleanFilter
  "Checks for all expressions in this list."
  and: [TokenFilter!]
  "Filter by the objects `cuid` field."
  cuid: StringFilter
  "Filter by the objects `id` field."
  id: IntFilter
  "Filter by the objects `lastUsed` field."
  lastUsed: DatetimeFilter
  "Negates the expression."
  not: TokenFilter
  "Checks for any expressions in this list."
  or: [TokenFilter!]
  "Filter by the objects `userId` field."
  userId: IntFilter
}

"An input for mutations affecting `Token`"
input TokenInput {
  active: Boolean
  cuid: String
  id: Int
  lastUsed: Datetime
  userId: Int!
}

"Represents an update to a `Token`. Fields that are set will be updated."
input TokenPatch {
  active: Boolean
  cuid: String
  id: Int
  lastUsed: Datetime
  userId: Int
}

"All input for the `updateGameAssignmentByNodeId` mutation."
input UpdateGameAssignmentByNodeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `GameAssignment` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `GameAssignment` being updated."
  patch: GameAssignmentPatch!
}

"All input for the `updateGameAssignment` mutation."
input UpdateGameAssignmentInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  gameId: Int!
  gm: Int!
  memberId: Int!
  "An object where the defined keys will be set on the `GameAssignment` being updated."
  patch: GameAssignmentPatch!
}

"All input for the `updateGameByNodeId` mutation."
input UpdateGameByNodeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `Game` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `Game` being updated."
  patch: GamePatch!
}

"All input for the `updateGameChoiceByNodeId` mutation."
input UpdateGameChoiceByNodeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `GameChoice` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `GameChoice` being updated."
  patch: GameChoicePatch!
}

"All input for the `updateGameChoice` mutation."
input UpdateGameChoiceInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  id: Int!
  "An object where the defined keys will be set on the `GameChoice` being updated."
  patch: GameChoicePatch!
}

"All input for the `updateGame` mutation."
input UpdateGameInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  id: Int!
  "An object where the defined keys will be set on the `Game` being updated."
  patch: GamePatch!
}

"All input for the `updateGameSubmissionByNodeId` mutation."
input UpdateGameSubmissionByNodeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `GameSubmission` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `GameSubmission` being updated."
  patch: GameSubmissionPatch!
}

"All input for the `updateGameSubmission` mutation."
input UpdateGameSubmissionInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  id: Int!
  "An object where the defined keys will be set on the `GameSubmission` being updated."
  patch: GameSubmissionPatch!
}

"All input for the `updateHotelRoomByNodeId` mutation."
input UpdateHotelRoomByNodeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `HotelRoom` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `HotelRoom` being updated."
  patch: HotelRoomPatch!
}

"All input for the `updateHotelRoomDetailByNodeId` mutation."
input UpdateHotelRoomDetailByNodeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `HotelRoomDetail` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `HotelRoomDetail` being updated."
  patch: HotelRoomDetailPatch!
}

"All input for the `updateHotelRoomDetail` mutation."
input UpdateHotelRoomDetailInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  id: BigInt!
  "An object where the defined keys will be set on the `HotelRoomDetail` being updated."
  patch: HotelRoomDetailPatch!
}

"All input for the `updateHotelRoom` mutation."
input UpdateHotelRoomInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  id: Int!
  "An object where the defined keys will be set on the `HotelRoom` being updated."
  patch: HotelRoomPatch!
}

"All input for the `updateLookupByNodeId` mutation."
input UpdateLookupByNodeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `Lookup` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `Lookup` being updated."
  patch: LookupPatch!
}

"All input for the `updateLookupByRealm` mutation."
input UpdateLookupByRealmInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "An object where the defined keys will be set on the `Lookup` being updated."
  patch: LookupPatch!
  realm: String!
}

"All input for the `updateLookup` mutation."
input UpdateLookupInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  id: Int!
  "An object where the defined keys will be set on the `Lookup` being updated."
  patch: LookupPatch!
}

"All input for the `updateLookupValueByLookupIdAndCode` mutation."
input UpdateLookupValueByLookupIdAndCodeInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  code: String!
  lookupId: Int!
  "An object where the defined keys will be set on the `LookupValue` being updated."
  patch: LookupValuePatch!
}

"All input for the `updateLookupValueByNodeId` mutation."
input UpdateLookupValueByNodeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `LookupValue` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `LookupValue` being updated."
  patch: LookupValuePatch!
}

"All input for the `updateLookupValue` mutation."
input UpdateLookupValueInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  id: Int!
  "An object where the defined keys will be set on the `LookupValue` being updated."
  patch: LookupValuePatch!
}

"All input for the `updateMemberHotelRoomAssignmentByNodeId` mutation."
input UpdateMemberHotelRoomAssignmentByNodeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `MemberHotelRoomAssignment` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `MemberHotelRoomAssignment` being updated."
  patch: MemberHotelRoomAssignmentPatch!
}

"All input for the `updateMemberHotelRoomAssignment` mutation."
input UpdateMemberHotelRoomAssignmentInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  hotelRoomId: BigInt!
  memberId: BigInt!
  "An object where the defined keys will be set on the `MemberHotelRoomAssignment` being updated."
  patch: MemberHotelRoomAssignmentPatch!
}

"All input for the `updateMembershipByNodeId` mutation."
input UpdateMembershipByNodeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `Membership` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `Membership` being updated."
  patch: MembershipPatch!
}

"All input for the `updateMembership` mutation."
input UpdateMembershipInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  id: Int!
  "An object where the defined keys will be set on the `Membership` being updated."
  patch: MembershipPatch!
}

"All input for the `updateProfileByEmail` mutation."
input UpdateProfileByEmailInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  email: String!
  "An object where the defined keys will be set on the `Profile` being updated."
  patch: ProfilePatch!
}

"All input for the `updateProfileByNodeId` mutation."
input UpdateProfileByNodeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `Profile` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `Profile` being updated."
  patch: ProfilePatch!
}

"All input for the `updateProfile` mutation."
input UpdateProfileInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  id: Int!
  "An object where the defined keys will be set on the `Profile` being updated."
  patch: ProfilePatch!
}

"All input for the `updateRegistrationCodeByNodeId` mutation."
input UpdateRegistrationCodeByNodeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `RegistrationCode` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `RegistrationCode` being updated."
  patch: RegistrationCodePatch!
}

"All input for the `updateRegistrationCode` mutation."
input UpdateRegistrationCodeInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  id: Int!
  "An object where the defined keys will be set on the `RegistrationCode` being updated."
  patch: RegistrationCodePatch!
}

"All input for the `updateRoleByAuthority` mutation."
input UpdateRoleByAuthorityInput {
  authority: String!
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "An object where the defined keys will be set on the `Role` being updated."
  patch: RolePatch!
}

"All input for the `updateRoleByNodeId` mutation."
input UpdateRoleByNodeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `Role` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `Role` being updated."
  patch: RolePatch!
}

"All input for the `updateRole` mutation."
input UpdateRoleInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  id: Int!
  "An object where the defined keys will be set on the `Role` being updated."
  patch: RolePatch!
}

"All input for the `updateRoomByNodeId` mutation."
input UpdateRoomByNodeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `Room` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `Room` being updated."
  patch: RoomPatch!
}

"All input for the `updateRoom` mutation."
input UpdateRoomInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  id: Int!
  "An object where the defined keys will be set on the `Room` being updated."
  patch: RoomPatch!
}

"All input for the `updateSettingByNodeId` mutation."
input UpdateSettingByNodeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `Setting` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `Setting` being updated."
  patch: SettingPatch!
}

"All input for the `updateSetting` mutation."
input UpdateSettingInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  id: Int!
  "An object where the defined keys will be set on the `Setting` being updated."
  patch: SettingPatch!
}

"All input for the `updateShirtOrderByNodeId` mutation."
input UpdateShirtOrderByNodeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `ShirtOrder` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `ShirtOrder` being updated."
  patch: ShirtOrderPatch!
}

"All input for the `updateShirtOrder` mutation."
input UpdateShirtOrderInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  id: Int!
  "An object where the defined keys will be set on the `ShirtOrder` being updated."
  patch: ShirtOrderPatch!
}

"All input for the `updateShirtOrderItemByNodeId` mutation."
input UpdateShirtOrderItemByNodeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `ShirtOrderItem` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `ShirtOrderItem` being updated."
  patch: ShirtOrderItemPatch!
}

"All input for the `updateShirtOrderItem` mutation."
input UpdateShirtOrderItemInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  id: Int!
  "An object where the defined keys will be set on the `ShirtOrderItem` being updated."
  patch: ShirtOrderItemPatch!
}

"All input for the `updateSlotByNodeId` mutation."
input UpdateSlotByNodeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `Slot` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `Slot` being updated."
  patch: SlotPatch!
}

"All input for the `updateSlot` mutation."
input UpdateSlotInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  id: Int!
  "An object where the defined keys will be set on the `Slot` being updated."
  patch: SlotPatch!
}

"All input for the `updateTokenByNodeId` mutation."
input UpdateTokenByNodeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `Token` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `Token` being updated."
  patch: TokenPatch!
}

"All input for the `updateToken` mutation."
input UpdateTokenInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  id: Int!
  "An object where the defined keys will be set on the `Token` being updated."
  patch: TokenPatch!
}

"All input for the `updateUserByNodeId` mutation."
input UpdateUserByNodeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `User` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `User` being updated."
  patch: UserPatch!
}

"All input for the `updateUserByUsername` mutation."
input UpdateUserByUsernameInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "An object where the defined keys will be set on the `User` being updated."
  patch: UserPatch!
  username: String!
}

"All input for the `updateUser` mutation."
input UpdateUserInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  id: Int!
  "An object where the defined keys will be set on the `User` being updated."
  patch: UserPatch!
}

"All input for the `updateUserRoleByNodeId` mutation."
input UpdateUserRoleByNodeIdInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "The globally unique `ID` which will identify a single `UserRole` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `UserRole` being updated."
  patch: UserRolePatch!
}

"All input for the `updateUserRole` mutation."
input UpdateUserRoleInput {
  "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
  clientMutationId: String
  "An object where the defined keys will be set on the `UserRole` being updated."
  patch: UserRolePatch!
  roleId: Int!
  userId: Int!
}

"A condition to be used against `User` object types. All fields are tested for equality and combined with a logical and."
input UserCondition {
  "Checks for equality with the objects `accountLocked` field."
  accountLocked: Boolean
  "Checks for equality with the objects `enabled` field."
  enabled: Boolean
  "Checks for equality with the objects `id` field."
  id: Int
  "Checks for equality with the objects `password` field."
  password: String
  "Checks for equality with the objects `profileId` field."
  profileId: Int
  "Checks for equality with the objects `username` field."
  username: String
}

"A filter to be used against `User` object types. All fields are combined with a logical and."
input UserFilter {
  "Filter by the objects `accountLocked` field."
  accountLocked: BooleanFilter
  "Checks for all expressions in this list."
  and: [UserFilter!]
  "Filter by the objects `enabled` field."
  enabled: BooleanFilter
  "Filter by the objects `id` field."
  id: IntFilter
  "Negates the expression."
  not: UserFilter
  "Checks for any expressions in this list."
  or: [UserFilter!]
  "Filter by the objects `password` field."
  password: StringFilter
  "Filter by the objects `profileId` field."
  profileId: IntFilter
  "Filter by the objects `username` field."
  username: StringFilter
}

"An input for mutations affecting `User`"
input UserInput {
  accountLocked: Boolean!
  enabled: Boolean!
  id: Int
  password: String!
  profileId: Int!
  username: String!
}

"Represents an update to a `User`. Fields that are set will be updated."
input UserPatch {
  accountLocked: Boolean
  enabled: Boolean
  id: Int
  password: String
  profileId: Int
  username: String
}

"A condition to be used against `UserRole` object types. All fields are tested for equality and combined with a logical and."
input UserRoleCondition {
  "Checks for equality with the objects `roleId` field."
  roleId: Int
  "Checks for equality with the objects `userId` field."
  userId: Int
}

"A filter to be used against `UserRole` object types. All fields are combined with a logical and."
input UserRoleFilter {
  "Checks for all expressions in this list."
  and: [UserRoleFilter!]
  "Negates the expression."
  not: UserRoleFilter
  "Checks for any expressions in this list."
  or: [UserRoleFilter!]
  "Filter by the objects `roleId` field."
  roleId: IntFilter
  "Filter by the objects `userId` field."
  userId: IntFilter
}

"An input for mutations affecting `UserRole`"
input UserRoleInput {
  roleId: Int!
  userId: Int!
}

"Represents an update to a `UserRole`. Fields that are set will be updated."
input UserRolePatch {
  roleId: Int
  userId: Int
}

"A location in a connection that can be used for resuming pagination."
scalar Cursor

"A point in time as described by the [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone."
scalar Datetime

"A signed eight-byte integer. The upper big integer values are greater than the max value for a JavaScript number. Therefore all big integers will be output as strings and not numbers."
scalar BigInt

"A floating point number that requires more precision than IEEE 754 binary 64"
scalar BigFloat
