/* DO NOT EDIT! This file is auto-generated by graphql-code-generator - see `codegen.yml` */
/* eslint-disable @typescript-eslint/ban-types,no-duplicate-imports,etc/prefer-interface,import/order,import/newline-after-import */
import { QueryError } from './error'
import { useQuery, useMutation, UseQueryOptions, UseMutationOptions } from '@tanstack/react-query'
import { useFetchData } from '@/client/fetcher'
export type Maybe<T> = T | null
export type InputMaybe<T> = Maybe<T>
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] }
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> }
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> }
/** All built-in and custom scalars, mapped to their actual values */
export interface Scalars {
  ID: string
  String: string
  Boolean: boolean
  Int: number
  Float: number
  /** A floating point number that requires more precision than IEEE 754 binary 64 */
  BigFloat: any
  /**
   * A signed eight-byte integer. The upper big integer values are greater than the
   * max value for a JavaScript number. Therefore all big integers will be output as
   * strings and not numbers.
   */
  BigInt: any
  /** A location in a connection that can be used for resuming pagination. */
  Cursor: any
  /**
   * A point in time as described by the [ISO
   * 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
   */
  Datetime: string
}

/** A filter to be used against BigFloat fields. All fields are combined with a logical ‘and.’ */
export interface BigFloatFilter {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['BigFloat']>
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['BigFloat']>
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['BigFloat']>
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['BigFloat']>
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['BigFloat']>>
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']>
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['BigFloat']>
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['BigFloat']>
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['BigFloat']>
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['BigFloat']>
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['BigFloat']>>
}

/** A filter to be used against BigInt fields. All fields are combined with a logical ‘and.’ */
export interface BigIntFilter {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['BigInt']>
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['BigInt']>
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['BigInt']>
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['BigInt']>
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['BigInt']>>
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']>
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['BigInt']>
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['BigInt']>
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['BigInt']>
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['BigInt']>
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['BigInt']>>
}

/** A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’ */
export interface BooleanFilter {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Boolean']>
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Boolean']>
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Boolean']>
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Boolean']>
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Boolean']>>
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']>
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Boolean']>
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Boolean']>
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Boolean']>
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Boolean']>
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Boolean']>>
}

/** All input for the `createBareSlotChoices` mutation. */
export interface CreateBareSlotChoicesInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  memberId?: InputMaybe<Scalars['Int']>
  yearno?: InputMaybe<Scalars['Int']>
}

/** The output of our `createBareSlotChoices` mutation. */
export interface CreateBareSlotChoicesPayload {
  __typename: 'CreateBareSlotChoicesPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
}

/** All input for the create `GameAssignment` mutation. */
export interface CreateGameAssignmentInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The `GameAssignment` to be created by this mutation. */
  gameAssignment: GameAssignmentInput
}

/** The output of our create `GameAssignment` mutation. */
export interface CreateGameAssignmentPayload {
  __typename: 'CreateGameAssignmentPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** Reads a single `Game` that is related to this `GameAssignment`. */
  game?: Maybe<Game>
  /** The `GameAssignment` that was created by this mutation. */
  gameAssignment?: Maybe<GameAssignment>
  /** An edge for our `GameAssignment`. May be used by Relay 1. */
  gameAssignmentEdge?: Maybe<GameAssignmentsEdge>
  /** Reads a single `Membership` that is related to this `GameAssignment`. */
  member?: Maybe<Membership>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
}

/** The output of our create `GameAssignment` mutation. */
export interface CreateGameAssignmentPayloadGameAssignmentEdgeArgs {
  orderBy?: InputMaybe<Array<GameAssignmentsOrderBy>>
}

/** All input for the create `GameChoice` mutation. */
export interface CreateGameChoiceInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The `GameChoice` to be created by this mutation. */
  gameChoice: GameChoiceInput
}

/** The output of our create `GameChoice` mutation. */
export interface CreateGameChoicePayload {
  __typename: 'CreateGameChoicePayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** Reads a single `Game` that is related to this `GameChoice`. */
  game?: Maybe<Game>
  /** The `GameChoice` that was created by this mutation. */
  gameChoice?: Maybe<GameChoice>
  /** An edge for our `GameChoice`. May be used by Relay 1. */
  gameChoiceEdge?: Maybe<GameChoicesEdge>
  /** Reads a single `Membership` that is related to this `GameChoice`. */
  member?: Maybe<Membership>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `Slot` that is related to this `GameChoice`. */
  slot?: Maybe<Slot>
}

/** The output of our create `GameChoice` mutation. */
export interface CreateGameChoicePayloadGameChoiceEdgeArgs {
  orderBy?: InputMaybe<Array<GameChoicesOrderBy>>
}

/** All input for the create `Game` mutation. */
export interface CreateGameInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The `Game` to be created by this mutation. */
  game: GameInput
}

/** The output of our create `Game` mutation. */
export interface CreateGamePayload {
  __typename: 'CreateGamePayload'
  /** Reads a single `User` that is related to this `Game`. */
  author?: Maybe<User>
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `Game` that was created by this mutation. */
  game?: Maybe<Game>
  /** An edge for our `Game`. May be used by Relay 1. */
  gameEdge?: Maybe<GamesEdge>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `Room` that is related to this `Game`. */
  room?: Maybe<Room>
  /** Reads a single `Slot` that is related to this `Game`. */
  slot?: Maybe<Slot>
}

/** The output of our create `Game` mutation. */
export interface CreateGamePayloadGameEdgeArgs {
  orderBy?: InputMaybe<Array<GamesOrderBy>>
}

/** All input for the create `GameSubmission` mutation. */
export interface CreateGameSubmissionInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The `GameSubmission` to be created by this mutation. */
  gameSubmission: GameSubmissionInput
}

/** The output of our create `GameSubmission` mutation. */
export interface CreateGameSubmissionPayload {
  __typename: 'CreateGameSubmissionPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `GameSubmission` that was created by this mutation. */
  gameSubmission?: Maybe<GameSubmission>
  /** An edge for our `GameSubmission`. May be used by Relay 1. */
  gameSubmissionEdge?: Maybe<GameSubmissionsEdge>
  /** Reads a single `Membership` that is related to this `GameSubmission`. */
  member?: Maybe<Membership>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
}

/** The output of our create `GameSubmission` mutation. */
export interface CreateGameSubmissionPayloadGameSubmissionEdgeArgs {
  orderBy?: InputMaybe<Array<GameSubmissionsOrderBy>>
}

/** All input for the create `HotelRoomDetail` mutation. */
export interface CreateHotelRoomDetailInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The `HotelRoomDetail` to be created by this mutation. */
  hotelRoomDetail: HotelRoomDetailInput
}

/** The output of our create `HotelRoomDetail` mutation. */
export interface CreateHotelRoomDetailPayload {
  __typename: 'CreateHotelRoomDetailPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `HotelRoomDetail` that was created by this mutation. */
  hotelRoomDetail?: Maybe<HotelRoomDetail>
  /** An edge for our `HotelRoomDetail`. May be used by Relay 1. */
  hotelRoomDetailEdge?: Maybe<HotelRoomDetailsEdge>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
}

/** The output of our create `HotelRoomDetail` mutation. */
export interface CreateHotelRoomDetailPayloadHotelRoomDetailEdgeArgs {
  orderBy?: InputMaybe<Array<HotelRoomDetailsOrderBy>>
}

/** All input for the create `HotelRoom` mutation. */
export interface CreateHotelRoomInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The `HotelRoom` to be created by this mutation. */
  hotelRoom: HotelRoomInput
}

/** The output of our create `HotelRoom` mutation. */
export interface CreateHotelRoomPayload {
  __typename: 'CreateHotelRoomPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `HotelRoom` that was created by this mutation. */
  hotelRoom?: Maybe<HotelRoom>
  /** An edge for our `HotelRoom`. May be used by Relay 1. */
  hotelRoomEdge?: Maybe<HotelRoomsEdge>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
}

/** The output of our create `HotelRoom` mutation. */
export interface CreateHotelRoomPayloadHotelRoomEdgeArgs {
  orderBy?: InputMaybe<Array<HotelRoomsOrderBy>>
}

/** All input for the create `Lookup` mutation. */
export interface CreateLookupInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The `Lookup` to be created by this mutation. */
  lookup: LookupInput
}

/** The output of our create `Lookup` mutation. */
export interface CreateLookupPayload {
  __typename: 'CreateLookupPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `Lookup` that was created by this mutation. */
  lookup?: Maybe<Lookup>
  /** An edge for our `Lookup`. May be used by Relay 1. */
  lookupEdge?: Maybe<LookupsEdge>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
}

/** The output of our create `Lookup` mutation. */
export interface CreateLookupPayloadLookupEdgeArgs {
  orderBy?: InputMaybe<Array<LookupsOrderBy>>
}

/** All input for the create `LookupValue` mutation. */
export interface CreateLookupValueInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The `LookupValue` to be created by this mutation. */
  lookupValue: LookupValueInput
}

/** The output of our create `LookupValue` mutation. */
export interface CreateLookupValuePayload {
  __typename: 'CreateLookupValuePayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** Reads a single `Lookup` that is related to this `LookupValue`. */
  lookup?: Maybe<Lookup>
  /** The `LookupValue` that was created by this mutation. */
  lookupValue?: Maybe<LookupValue>
  /** An edge for our `LookupValue`. May be used by Relay 1. */
  lookupValueEdge?: Maybe<LookupValuesEdge>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
}

/** The output of our create `LookupValue` mutation. */
export interface CreateLookupValuePayloadLookupValueEdgeArgs {
  orderBy?: InputMaybe<Array<LookupValuesOrderBy>>
}

/** All input for the create `Membership` mutation. */
export interface CreateMembershipInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The `Membership` to be created by this mutation. */
  membership: MembershipInput
}

/** The output of our create `Membership` mutation. */
export interface CreateMembershipPayload {
  __typename: 'CreateMembershipPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** Reads a single `HotelRoom` that is related to this `Membership`. */
  hotelRoom?: Maybe<HotelRoom>
  /** The `Membership` that was created by this mutation. */
  membership?: Maybe<Membership>
  /** An edge for our `Membership`. May be used by Relay 1. */
  membershipEdge?: Maybe<MembershipsEdge>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `User` that is related to this `Membership`. */
  user?: Maybe<User>
}

/** The output of our create `Membership` mutation. */
export interface CreateMembershipPayloadMembershipEdgeArgs {
  orderBy?: InputMaybe<Array<MembershipsOrderBy>>
}

/** All input for the create `Profile` mutation. */
export interface CreateProfileInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The `Profile` to be created by this mutation. */
  profile: ProfileInput
}

/** The output of our create `Profile` mutation. */
export interface CreateProfilePayload {
  __typename: 'CreateProfilePayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `Profile` that was created by this mutation. */
  profile?: Maybe<Profile>
  /** An edge for our `Profile`. May be used by Relay 1. */
  profileEdge?: Maybe<ProfilesEdge>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `User` that is related to this `Profile`. */
  user?: Maybe<User>
}

/** The output of our create `Profile` mutation. */
export interface CreateProfilePayloadProfileEdgeArgs {
  orderBy?: InputMaybe<Array<ProfilesOrderBy>>
}

/** All input for the create `Role` mutation. */
export interface CreateRoleInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The `Role` to be created by this mutation. */
  role: RoleInput
}

/** The output of our create `Role` mutation. */
export interface CreateRolePayload {
  __typename: 'CreateRolePayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** The `Role` that was created by this mutation. */
  role?: Maybe<Role>
  /** An edge for our `Role`. May be used by Relay 1. */
  roleEdge?: Maybe<RolesEdge>
}

/** The output of our create `Role` mutation. */
export interface CreateRolePayloadRoleEdgeArgs {
  orderBy?: InputMaybe<Array<RolesOrderBy>>
}

/** All input for the create `Room` mutation. */
export interface CreateRoomInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The `Room` to be created by this mutation. */
  room: RoomInput
}

/** The output of our create `Room` mutation. */
export interface CreateRoomPayload {
  __typename: 'CreateRoomPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** The `Room` that was created by this mutation. */
  room?: Maybe<Room>
  /** An edge for our `Room`. May be used by Relay 1. */
  roomEdge?: Maybe<RoomsEdge>
}

/** The output of our create `Room` mutation. */
export interface CreateRoomPayloadRoomEdgeArgs {
  orderBy?: InputMaybe<Array<RoomsOrderBy>>
}

/** All input for the create `Setting` mutation. */
export interface CreateSettingInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The `Setting` to be created by this mutation. */
  setting: SettingInput
}

/** The output of our create `Setting` mutation. */
export interface CreateSettingPayload {
  __typename: 'CreateSettingPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** The `Setting` that was created by this mutation. */
  setting?: Maybe<Setting>
  /** An edge for our `Setting`. May be used by Relay 1. */
  settingEdge?: Maybe<SettingsEdge>
}

/** The output of our create `Setting` mutation. */
export interface CreateSettingPayloadSettingEdgeArgs {
  orderBy?: InputMaybe<Array<SettingsOrderBy>>
}

/** All input for the create `ShirtOrder` mutation. */
export interface CreateShirtOrderInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The `ShirtOrder` to be created by this mutation. */
  shirtOrder: ShirtOrderInput
}

/** All input for the create `ShirtOrderItem` mutation. */
export interface CreateShirtOrderItemInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The `ShirtOrderItem` to be created by this mutation. */
  shirtOrderItem: ShirtOrderItemInput
}

/** The output of our create `ShirtOrderItem` mutation. */
export interface CreateShirtOrderItemPayload {
  __typename: 'CreateShirtOrderItemPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** Reads a single `ShirtOrder` that is related to this `ShirtOrderItem`. */
  order?: Maybe<ShirtOrder>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** The `ShirtOrderItem` that was created by this mutation. */
  shirtOrderItem?: Maybe<ShirtOrderItem>
  /** An edge for our `ShirtOrderItem`. May be used by Relay 1. */
  shirtOrderItemEdge?: Maybe<ShirtOrderItemsEdge>
}

/** The output of our create `ShirtOrderItem` mutation. */
export interface CreateShirtOrderItemPayloadShirtOrderItemEdgeArgs {
  orderBy?: InputMaybe<Array<ShirtOrderItemsOrderBy>>
}

/** The output of our create `ShirtOrder` mutation. */
export interface CreateShirtOrderPayload {
  __typename: 'CreateShirtOrderPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** The `ShirtOrder` that was created by this mutation. */
  shirtOrder?: Maybe<ShirtOrder>
  /** An edge for our `ShirtOrder`. May be used by Relay 1. */
  shirtOrderEdge?: Maybe<ShirtOrdersEdge>
  /** Reads a single `User` that is related to this `ShirtOrder`. */
  user?: Maybe<User>
}

/** The output of our create `ShirtOrder` mutation. */
export interface CreateShirtOrderPayloadShirtOrderEdgeArgs {
  orderBy?: InputMaybe<Array<ShirtOrdersOrderBy>>
}

/** All input for the create `Slot` mutation. */
export interface CreateSlotInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The `Slot` to be created by this mutation. */
  slot: SlotInput
}

/** The output of our create `Slot` mutation. */
export interface CreateSlotPayload {
  __typename: 'CreateSlotPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** The `Slot` that was created by this mutation. */
  slot?: Maybe<Slot>
  /** An edge for our `Slot`. May be used by Relay 1. */
  slotEdge?: Maybe<SlotsEdge>
}

/** The output of our create `Slot` mutation. */
export interface CreateSlotPayloadSlotEdgeArgs {
  orderBy?: InputMaybe<Array<SlotsOrderBy>>
}

/** All input for the create `User` mutation. */
export interface CreateUserInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The `User` to be created by this mutation. */
  user: UserInput
}

/** The output of our create `User` mutation. */
export interface CreateUserPayload {
  __typename: 'CreateUserPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** The `User` that was created by this mutation. */
  user?: Maybe<User>
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>
}

/** The output of our create `User` mutation. */
export interface CreateUserPayloadUserEdgeArgs {
  orderBy?: InputMaybe<Array<UsersOrderBy>>
}

/** All input for the create `UserRole` mutation. */
export interface CreateUserRoleInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The `UserRole` to be created by this mutation. */
  userRole: UserRoleInput
}

/** The output of our create `UserRole` mutation. */
export interface CreateUserRolePayload {
  __typename: 'CreateUserRolePayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `Role` that is related to this `UserRole`. */
  role?: Maybe<Role>
  /** Reads a single `User` that is related to this `UserRole`. */
  user?: Maybe<User>
  /** The `UserRole` that was created by this mutation. */
  userRole?: Maybe<UserRole>
  /** An edge for our `UserRole`. May be used by Relay 1. */
  userRoleEdge?: Maybe<UserRolesEdge>
}

/** The output of our create `UserRole` mutation. */
export interface CreateUserRolePayloadUserRoleEdgeArgs {
  orderBy?: InputMaybe<Array<UserRolesOrderBy>>
}

/** A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’ */
export interface DatetimeFilter {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Datetime']>
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Datetime']>
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Datetime']>
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Datetime']>
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Datetime']>>
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']>
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Datetime']>
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Datetime']>
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Datetime']>
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Datetime']>
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Datetime']>>
}

/** All input for the `deleteGameAssignmentByNodeId` mutation. */
export interface DeleteGameAssignmentByNodeIdInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `GameAssignment` to be deleted. */
  nodeId: Scalars['ID']
}

/** All input for the `deleteGameAssignment` mutation. */
export interface DeleteGameAssignmentInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  gameId: Scalars['Int']
  gm: Scalars['Int']
  memberId: Scalars['Int']
}

/** The output of our delete `GameAssignment` mutation. */
export interface DeleteGameAssignmentPayload {
  __typename: 'DeleteGameAssignmentPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  deletedGameAssignmentNodeId?: Maybe<Scalars['ID']>
  /** Reads a single `Game` that is related to this `GameAssignment`. */
  game?: Maybe<Game>
  /** The `GameAssignment` that was deleted by this mutation. */
  gameAssignment?: Maybe<GameAssignment>
  /** An edge for our `GameAssignment`. May be used by Relay 1. */
  gameAssignmentEdge?: Maybe<GameAssignmentsEdge>
  /** Reads a single `Membership` that is related to this `GameAssignment`. */
  member?: Maybe<Membership>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
}

/** The output of our delete `GameAssignment` mutation. */
export interface DeleteGameAssignmentPayloadGameAssignmentEdgeArgs {
  orderBy?: InputMaybe<Array<GameAssignmentsOrderBy>>
}

/** All input for the `deleteGameByNodeId` mutation. */
export interface DeleteGameByNodeIdInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `Game` to be deleted. */
  nodeId: Scalars['ID']
}

/** All input for the `deleteGameChoiceByNodeId` mutation. */
export interface DeleteGameChoiceByNodeIdInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `GameChoice` to be deleted. */
  nodeId: Scalars['ID']
}

/** All input for the `deleteGameChoice` mutation. */
export interface DeleteGameChoiceInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  id: Scalars['Int']
}

/** The output of our delete `GameChoice` mutation. */
export interface DeleteGameChoicePayload {
  __typename: 'DeleteGameChoicePayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  deletedGameChoiceNodeId?: Maybe<Scalars['ID']>
  /** Reads a single `Game` that is related to this `GameChoice`. */
  game?: Maybe<Game>
  /** The `GameChoice` that was deleted by this mutation. */
  gameChoice?: Maybe<GameChoice>
  /** An edge for our `GameChoice`. May be used by Relay 1. */
  gameChoiceEdge?: Maybe<GameChoicesEdge>
  /** Reads a single `Membership` that is related to this `GameChoice`. */
  member?: Maybe<Membership>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `Slot` that is related to this `GameChoice`. */
  slot?: Maybe<Slot>
}

/** The output of our delete `GameChoice` mutation. */
export interface DeleteGameChoicePayloadGameChoiceEdgeArgs {
  orderBy?: InputMaybe<Array<GameChoicesOrderBy>>
}

/** All input for the `deleteGame` mutation. */
export interface DeleteGameInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  id: Scalars['Int']
}

/** The output of our delete `Game` mutation. */
export interface DeleteGamePayload {
  __typename: 'DeleteGamePayload'
  /** Reads a single `User` that is related to this `Game`. */
  author?: Maybe<User>
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  deletedGameNodeId?: Maybe<Scalars['ID']>
  /** The `Game` that was deleted by this mutation. */
  game?: Maybe<Game>
  /** An edge for our `Game`. May be used by Relay 1. */
  gameEdge?: Maybe<GamesEdge>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `Room` that is related to this `Game`. */
  room?: Maybe<Room>
  /** Reads a single `Slot` that is related to this `Game`. */
  slot?: Maybe<Slot>
}

/** The output of our delete `Game` mutation. */
export interface DeleteGamePayloadGameEdgeArgs {
  orderBy?: InputMaybe<Array<GamesOrderBy>>
}

/** All input for the `deleteGameSubmissionByNodeId` mutation. */
export interface DeleteGameSubmissionByNodeIdInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `GameSubmission` to be deleted. */
  nodeId: Scalars['ID']
}

/** All input for the `deleteGameSubmission` mutation. */
export interface DeleteGameSubmissionInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  id: Scalars['Int']
}

/** The output of our delete `GameSubmission` mutation. */
export interface DeleteGameSubmissionPayload {
  __typename: 'DeleteGameSubmissionPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  deletedGameSubmissionNodeId?: Maybe<Scalars['ID']>
  /** The `GameSubmission` that was deleted by this mutation. */
  gameSubmission?: Maybe<GameSubmission>
  /** An edge for our `GameSubmission`. May be used by Relay 1. */
  gameSubmissionEdge?: Maybe<GameSubmissionsEdge>
  /** Reads a single `Membership` that is related to this `GameSubmission`. */
  member?: Maybe<Membership>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
}

/** The output of our delete `GameSubmission` mutation. */
export interface DeleteGameSubmissionPayloadGameSubmissionEdgeArgs {
  orderBy?: InputMaybe<Array<GameSubmissionsOrderBy>>
}

/** All input for the `deleteHotelRoomByNodeId` mutation. */
export interface DeleteHotelRoomByNodeIdInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `HotelRoom` to be deleted. */
  nodeId: Scalars['ID']
}

/** All input for the `deleteHotelRoomDetailByNodeId` mutation. */
export interface DeleteHotelRoomDetailByNodeIdInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `HotelRoomDetail` to be deleted. */
  nodeId: Scalars['ID']
}

/** All input for the `deleteHotelRoomDetail` mutation. */
export interface DeleteHotelRoomDetailInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  id: Scalars['BigInt']
}

/** The output of our delete `HotelRoomDetail` mutation. */
export interface DeleteHotelRoomDetailPayload {
  __typename: 'DeleteHotelRoomDetailPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  deletedHotelRoomDetailNodeId?: Maybe<Scalars['ID']>
  /** The `HotelRoomDetail` that was deleted by this mutation. */
  hotelRoomDetail?: Maybe<HotelRoomDetail>
  /** An edge for our `HotelRoomDetail`. May be used by Relay 1. */
  hotelRoomDetailEdge?: Maybe<HotelRoomDetailsEdge>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
}

/** The output of our delete `HotelRoomDetail` mutation. */
export interface DeleteHotelRoomDetailPayloadHotelRoomDetailEdgeArgs {
  orderBy?: InputMaybe<Array<HotelRoomDetailsOrderBy>>
}

/** All input for the `deleteHotelRoom` mutation. */
export interface DeleteHotelRoomInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  id: Scalars['Int']
}

/** The output of our delete `HotelRoom` mutation. */
export interface DeleteHotelRoomPayload {
  __typename: 'DeleteHotelRoomPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  deletedHotelRoomNodeId?: Maybe<Scalars['ID']>
  /** The `HotelRoom` that was deleted by this mutation. */
  hotelRoom?: Maybe<HotelRoom>
  /** An edge for our `HotelRoom`. May be used by Relay 1. */
  hotelRoomEdge?: Maybe<HotelRoomsEdge>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
}

/** The output of our delete `HotelRoom` mutation. */
export interface DeleteHotelRoomPayloadHotelRoomEdgeArgs {
  orderBy?: InputMaybe<Array<HotelRoomsOrderBy>>
}

/** All input for the `deleteLookupByNodeId` mutation. */
export interface DeleteLookupByNodeIdInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `Lookup` to be deleted. */
  nodeId: Scalars['ID']
}

/** All input for the `deleteLookupByRealm` mutation. */
export interface DeleteLookupByRealmInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  realm: Scalars['String']
}

/** All input for the `deleteLookup` mutation. */
export interface DeleteLookupInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  id: Scalars['Int']
}

/** The output of our delete `Lookup` mutation. */
export interface DeleteLookupPayload {
  __typename: 'DeleteLookupPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  deletedLookupNodeId?: Maybe<Scalars['ID']>
  /** The `Lookup` that was deleted by this mutation. */
  lookup?: Maybe<Lookup>
  /** An edge for our `Lookup`. May be used by Relay 1. */
  lookupEdge?: Maybe<LookupsEdge>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
}

/** The output of our delete `Lookup` mutation. */
export interface DeleteLookupPayloadLookupEdgeArgs {
  orderBy?: InputMaybe<Array<LookupsOrderBy>>
}

/** All input for the `deleteLookupValueByLookupIdAndCode` mutation. */
export interface DeleteLookupValueByLookupIdAndCodeInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  code: Scalars['String']
  lookupId: Scalars['Int']
}

/** All input for the `deleteLookupValueByNodeId` mutation. */
export interface DeleteLookupValueByNodeIdInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `LookupValue` to be deleted. */
  nodeId: Scalars['ID']
}

/** All input for the `deleteLookupValue` mutation. */
export interface DeleteLookupValueInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  id: Scalars['Int']
}

/** The output of our delete `LookupValue` mutation. */
export interface DeleteLookupValuePayload {
  __typename: 'DeleteLookupValuePayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  deletedLookupValueNodeId?: Maybe<Scalars['ID']>
  /** Reads a single `Lookup` that is related to this `LookupValue`. */
  lookup?: Maybe<Lookup>
  /** The `LookupValue` that was deleted by this mutation. */
  lookupValue?: Maybe<LookupValue>
  /** An edge for our `LookupValue`. May be used by Relay 1. */
  lookupValueEdge?: Maybe<LookupValuesEdge>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
}

/** The output of our delete `LookupValue` mutation. */
export interface DeleteLookupValuePayloadLookupValueEdgeArgs {
  orderBy?: InputMaybe<Array<LookupValuesOrderBy>>
}

/** All input for the `deleteMembershipByNodeId` mutation. */
export interface DeleteMembershipByNodeIdInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `Membership` to be deleted. */
  nodeId: Scalars['ID']
}

/** All input for the `deleteMembership` mutation. */
export interface DeleteMembershipInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  id: Scalars['Int']
}

/** The output of our delete `Membership` mutation. */
export interface DeleteMembershipPayload {
  __typename: 'DeleteMembershipPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  deletedMembershipNodeId?: Maybe<Scalars['ID']>
  /** Reads a single `HotelRoom` that is related to this `Membership`. */
  hotelRoom?: Maybe<HotelRoom>
  /** The `Membership` that was deleted by this mutation. */
  membership?: Maybe<Membership>
  /** An edge for our `Membership`. May be used by Relay 1. */
  membershipEdge?: Maybe<MembershipsEdge>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `User` that is related to this `Membership`. */
  user?: Maybe<User>
}

/** The output of our delete `Membership` mutation. */
export interface DeleteMembershipPayloadMembershipEdgeArgs {
  orderBy?: InputMaybe<Array<MembershipsOrderBy>>
}

/** All input for the `deleteProfileByNodeId` mutation. */
export interface DeleteProfileByNodeIdInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `Profile` to be deleted. */
  nodeId: Scalars['ID']
}

/** All input for the `deleteProfile` mutation. */
export interface DeleteProfileInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  id: Scalars['Int']
}

/** The output of our delete `Profile` mutation. */
export interface DeleteProfilePayload {
  __typename: 'DeleteProfilePayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  deletedProfileNodeId?: Maybe<Scalars['ID']>
  /** The `Profile` that was deleted by this mutation. */
  profile?: Maybe<Profile>
  /** An edge for our `Profile`. May be used by Relay 1. */
  profileEdge?: Maybe<ProfilesEdge>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `User` that is related to this `Profile`. */
  user?: Maybe<User>
}

/** The output of our delete `Profile` mutation. */
export interface DeleteProfilePayloadProfileEdgeArgs {
  orderBy?: InputMaybe<Array<ProfilesOrderBy>>
}

/** All input for the `deleteRoleByAuthority` mutation. */
export interface DeleteRoleByAuthorityInput {
  authority: Scalars['String']
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
}

/** All input for the `deleteRoleByNodeId` mutation. */
export interface DeleteRoleByNodeIdInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `Role` to be deleted. */
  nodeId: Scalars['ID']
}

/** All input for the `deleteRole` mutation. */
export interface DeleteRoleInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  id: Scalars['Int']
}

/** The output of our delete `Role` mutation. */
export interface DeleteRolePayload {
  __typename: 'DeleteRolePayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  deletedRoleNodeId?: Maybe<Scalars['ID']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** The `Role` that was deleted by this mutation. */
  role?: Maybe<Role>
  /** An edge for our `Role`. May be used by Relay 1. */
  roleEdge?: Maybe<RolesEdge>
}

/** The output of our delete `Role` mutation. */
export interface DeleteRolePayloadRoleEdgeArgs {
  orderBy?: InputMaybe<Array<RolesOrderBy>>
}

/** All input for the `deleteRoomByNodeId` mutation. */
export interface DeleteRoomByNodeIdInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `Room` to be deleted. */
  nodeId: Scalars['ID']
}

/** All input for the `deleteRoom` mutation. */
export interface DeleteRoomInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  id: Scalars['Int']
}

/** The output of our delete `Room` mutation. */
export interface DeleteRoomPayload {
  __typename: 'DeleteRoomPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  deletedRoomNodeId?: Maybe<Scalars['ID']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** The `Room` that was deleted by this mutation. */
  room?: Maybe<Room>
  /** An edge for our `Room`. May be used by Relay 1. */
  roomEdge?: Maybe<RoomsEdge>
}

/** The output of our delete `Room` mutation. */
export interface DeleteRoomPayloadRoomEdgeArgs {
  orderBy?: InputMaybe<Array<RoomsOrderBy>>
}

/** All input for the `deleteSettingByNodeId` mutation. */
export interface DeleteSettingByNodeIdInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `Setting` to be deleted. */
  nodeId: Scalars['ID']
}

/** All input for the `deleteSetting` mutation. */
export interface DeleteSettingInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  id: Scalars['Int']
}

/** The output of our delete `Setting` mutation. */
export interface DeleteSettingPayload {
  __typename: 'DeleteSettingPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  deletedSettingNodeId?: Maybe<Scalars['ID']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** The `Setting` that was deleted by this mutation. */
  setting?: Maybe<Setting>
  /** An edge for our `Setting`. May be used by Relay 1. */
  settingEdge?: Maybe<SettingsEdge>
}

/** The output of our delete `Setting` mutation. */
export interface DeleteSettingPayloadSettingEdgeArgs {
  orderBy?: InputMaybe<Array<SettingsOrderBy>>
}

/** All input for the `deleteShirtOrderByNodeId` mutation. */
export interface DeleteShirtOrderByNodeIdInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `ShirtOrder` to be deleted. */
  nodeId: Scalars['ID']
}

/** All input for the `deleteShirtOrder` mutation. */
export interface DeleteShirtOrderInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  id: Scalars['Int']
}

/** All input for the `deleteShirtOrderItemByNodeId` mutation. */
export interface DeleteShirtOrderItemByNodeIdInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `ShirtOrderItem` to be deleted. */
  nodeId: Scalars['ID']
}

/** All input for the `deleteShirtOrderItem` mutation. */
export interface DeleteShirtOrderItemInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  id: Scalars['Int']
}

/** The output of our delete `ShirtOrderItem` mutation. */
export interface DeleteShirtOrderItemPayload {
  __typename: 'DeleteShirtOrderItemPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  deletedShirtOrderItemNodeId?: Maybe<Scalars['ID']>
  /** Reads a single `ShirtOrder` that is related to this `ShirtOrderItem`. */
  order?: Maybe<ShirtOrder>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** The `ShirtOrderItem` that was deleted by this mutation. */
  shirtOrderItem?: Maybe<ShirtOrderItem>
  /** An edge for our `ShirtOrderItem`. May be used by Relay 1. */
  shirtOrderItemEdge?: Maybe<ShirtOrderItemsEdge>
}

/** The output of our delete `ShirtOrderItem` mutation. */
export interface DeleteShirtOrderItemPayloadShirtOrderItemEdgeArgs {
  orderBy?: InputMaybe<Array<ShirtOrderItemsOrderBy>>
}

/** The output of our delete `ShirtOrder` mutation. */
export interface DeleteShirtOrderPayload {
  __typename: 'DeleteShirtOrderPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  deletedShirtOrderNodeId?: Maybe<Scalars['ID']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** The `ShirtOrder` that was deleted by this mutation. */
  shirtOrder?: Maybe<ShirtOrder>
  /** An edge for our `ShirtOrder`. May be used by Relay 1. */
  shirtOrderEdge?: Maybe<ShirtOrdersEdge>
  /** Reads a single `User` that is related to this `ShirtOrder`. */
  user?: Maybe<User>
}

/** The output of our delete `ShirtOrder` mutation. */
export interface DeleteShirtOrderPayloadShirtOrderEdgeArgs {
  orderBy?: InputMaybe<Array<ShirtOrdersOrderBy>>
}

/** All input for the `deleteSlotByNodeId` mutation. */
export interface DeleteSlotByNodeIdInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `Slot` to be deleted. */
  nodeId: Scalars['ID']
}

/** All input for the `deleteSlot` mutation. */
export interface DeleteSlotInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  id: Scalars['Int']
}

/** The output of our delete `Slot` mutation. */
export interface DeleteSlotPayload {
  __typename: 'DeleteSlotPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  deletedSlotNodeId?: Maybe<Scalars['ID']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** The `Slot` that was deleted by this mutation. */
  slot?: Maybe<Slot>
  /** An edge for our `Slot`. May be used by Relay 1. */
  slotEdge?: Maybe<SlotsEdge>
}

/** The output of our delete `Slot` mutation. */
export interface DeleteSlotPayloadSlotEdgeArgs {
  orderBy?: InputMaybe<Array<SlotsOrderBy>>
}

/** All input for the `deleteUserByEmail` mutation. */
export interface DeleteUserByEmailInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  email: Scalars['String']
}

/** All input for the `deleteUserByNodeId` mutation. */
export interface DeleteUserByNodeIdInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `User` to be deleted. */
  nodeId: Scalars['ID']
}

/** All input for the `deleteUser` mutation. */
export interface DeleteUserInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  id: Scalars['Int']
}

/** The output of our delete `User` mutation. */
export interface DeleteUserPayload {
  __typename: 'DeleteUserPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  deletedUserNodeId?: Maybe<Scalars['ID']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** The `User` that was deleted by this mutation. */
  user?: Maybe<User>
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>
}

/** The output of our delete `User` mutation. */
export interface DeleteUserPayloadUserEdgeArgs {
  orderBy?: InputMaybe<Array<UsersOrderBy>>
}

/** All input for the `deleteUserRoleByNodeId` mutation. */
export interface DeleteUserRoleByNodeIdInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `UserRole` to be deleted. */
  nodeId: Scalars['ID']
}

/** All input for the `deleteUserRole` mutation. */
export interface DeleteUserRoleInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  roleId: Scalars['Int']
  userId: Scalars['Int']
}

/** The output of our delete `UserRole` mutation. */
export interface DeleteUserRolePayload {
  __typename: 'DeleteUserRolePayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  deletedUserRoleNodeId?: Maybe<Scalars['ID']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `Role` that is related to this `UserRole`. */
  role?: Maybe<Role>
  /** Reads a single `User` that is related to this `UserRole`. */
  user?: Maybe<User>
  /** The `UserRole` that was deleted by this mutation. */
  userRole?: Maybe<UserRole>
  /** An edge for our `UserRole`. May be used by Relay 1. */
  userRoleEdge?: Maybe<UserRolesEdge>
}

/** The output of our delete `UserRole` mutation. */
export interface DeleteUserRolePayloadUserRoleEdgeArgs {
  orderBy?: InputMaybe<Array<UserRolesOrderBy>>
}

/** All input for the `fTruncateTables` mutation. */
export interface FTruncateTablesInput {
  _username?: InputMaybe<Scalars['String']>
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
}

/** The output of our `fTruncateTables` mutation. */
export interface FTruncateTablesPayload {
  __typename: 'FTruncateTablesPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
}

/** A filter to be used against Float fields. All fields are combined with a logical ‘and.’ */
export interface FloatFilter {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Float']>
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Float']>
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Float']>
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Float']>
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Float']>>
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']>
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Float']>
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Float']>
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Float']>
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Float']>
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Float']>>
}

export interface Game extends Node {
  __typename: 'Game'
  /** Reads a single `User` that is related to this `Game`. */
  author?: Maybe<User>
  authorId?: Maybe<Scalars['Int']>
  charInstructions: Scalars['String']
  description: Scalars['String']
  estimatedLength: Scalars['String']
  full?: Maybe<Scalars['Boolean']>
  /** Reads and enables pagination through a set of `GameAssignment`. */
  gameAssignments: GameAssignmentsConnection
  /** Reads and enables pagination through a set of `GameChoice`. */
  gameChoices: GameChoicesConnection
  gameContactEmail: Scalars['String']
  genre: Scalars['String']
  gmNames?: Maybe<Scalars['String']>
  id: Scalars['Int']
  lateFinish?: Maybe<Scalars['Boolean']>
  lateStart?: Maybe<Scalars['String']>
  message: Scalars['String']
  name: Scalars['String']
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']
  playerMax: Scalars['Int']
  playerMin: Scalars['Int']
  playerPreference: Scalars['String']
  playersContactGm: Scalars['Boolean']
  returningPlayers: Scalars['String']
  /** Reads a single `Room` that is related to this `Game`. */
  room?: Maybe<Room>
  roomId?: Maybe<Scalars['Int']>
  setting: Scalars['String']
  shortName?: Maybe<Scalars['String']>
  /** Reads a single `Slot` that is related to this `Game`. */
  slot?: Maybe<Slot>
  slotConflicts: Scalars['String']
  slotId?: Maybe<Scalars['Int']>
  slotPreference: Scalars['Int']
  teenFriendly: Scalars['Boolean']
  type: Scalars['String']
  year: Scalars['Int']
}

export interface GameGameAssignmentsArgs {
  after?: InputMaybe<Scalars['Cursor']>
  before?: InputMaybe<Scalars['Cursor']>
  condition?: InputMaybe<GameAssignmentCondition>
  filter?: InputMaybe<GameAssignmentFilter>
  first?: InputMaybe<Scalars['Int']>
  last?: InputMaybe<Scalars['Int']>
  offset?: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<GameAssignmentsOrderBy>>
}

export interface GameGameChoicesArgs {
  after?: InputMaybe<Scalars['Cursor']>
  before?: InputMaybe<Scalars['Cursor']>
  condition?: InputMaybe<GameChoiceCondition>
  filter?: InputMaybe<GameChoiceFilter>
  first?: InputMaybe<Scalars['Int']>
  last?: InputMaybe<Scalars['Int']>
  offset?: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<GameChoicesOrderBy>>
}

export interface GameAssignment extends Node {
  __typename: 'GameAssignment'
  /** Reads a single `Game` that is related to this `GameAssignment`. */
  game?: Maybe<Game>
  gameId: Scalars['Int']
  gm: Scalars['Int']
  /** Reads a single `Membership` that is related to this `GameAssignment`. */
  member?: Maybe<Membership>
  memberId: Scalars['Int']
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']
  year: Scalars['Int']
}

/**
 * A condition to be used against `GameAssignment` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export interface GameAssignmentCondition {
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `gm` field. */
  gm?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `memberId` field. */
  memberId?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `year` field. */
  year?: InputMaybe<Scalars['Int']>
}

/** A filter to be used against `GameAssignment` object types. All fields are combined with a logical ‘and.’ */
export interface GameAssignmentFilter {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<GameAssignmentFilter>>
  /** Filter by the object’s `gameId` field. */
  gameId?: InputMaybe<IntFilter>
  /** Filter by the object’s `gm` field. */
  gm?: InputMaybe<IntFilter>
  /** Filter by the object’s `memberId` field. */
  memberId?: InputMaybe<IntFilter>
  /** Negates the expression. */
  not?: InputMaybe<GameAssignmentFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<GameAssignmentFilter>>
  /** Filter by the object’s `year` field. */
  year?: InputMaybe<IntFilter>
}

/** An input for mutations affecting `GameAssignment` */
export interface GameAssignmentInput {
  gameId: Scalars['Int']
  gm: Scalars['Int']
  memberId: Scalars['Int']
  year: Scalars['Int']
}

/** Represents an update to a `GameAssignment`. Fields that are set will be updated. */
export interface GameAssignmentPatch {
  gameId?: InputMaybe<Scalars['Int']>
  gm?: InputMaybe<Scalars['Int']>
  memberId?: InputMaybe<Scalars['Int']>
  year?: InputMaybe<Scalars['Int']>
}

/** A connection to a list of `GameAssignment` values. */
export interface GameAssignmentsConnection {
  __typename: 'GameAssignmentsConnection'
  /** A list of edges which contains the `GameAssignment` and cursor to aid in pagination. */
  edges: Array<GameAssignmentsEdge>
  /** A list of `GameAssignment` objects. */
  nodes: Array<Maybe<GameAssignment>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `GameAssignment` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `GameAssignment` edge in the connection. */
export interface GameAssignmentsEdge {
  __typename: 'GameAssignmentsEdge'
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `GameAssignment` at the end of the edge. */
  node?: Maybe<GameAssignment>
}

/** Methods to use when ordering `GameAssignment`. */
export enum GameAssignmentsOrderBy {
  GameByGameIdAuthorIdAsc = 'GAME_BY_GAME_ID__AUTHOR_ID_ASC',
  GameByGameIdAuthorIdDesc = 'GAME_BY_GAME_ID__AUTHOR_ID_DESC',
  GameByGameIdCharInstructionsAsc = 'GAME_BY_GAME_ID__CHAR_INSTRUCTIONS_ASC',
  GameByGameIdCharInstructionsDesc = 'GAME_BY_GAME_ID__CHAR_INSTRUCTIONS_DESC',
  GameByGameIdDescriptionAsc = 'GAME_BY_GAME_ID__DESCRIPTION_ASC',
  GameByGameIdDescriptionDesc = 'GAME_BY_GAME_ID__DESCRIPTION_DESC',
  GameByGameIdEstimatedLengthAsc = 'GAME_BY_GAME_ID__ESTIMATED_LENGTH_ASC',
  GameByGameIdEstimatedLengthDesc = 'GAME_BY_GAME_ID__ESTIMATED_LENGTH_DESC',
  GameByGameIdFullAsc = 'GAME_BY_GAME_ID__FULL_ASC',
  GameByGameIdFullDesc = 'GAME_BY_GAME_ID__FULL_DESC',
  GameByGameIdGameContactEmailAsc = 'GAME_BY_GAME_ID__GAME_CONTACT_EMAIL_ASC',
  GameByGameIdGameContactEmailDesc = 'GAME_BY_GAME_ID__GAME_CONTACT_EMAIL_DESC',
  GameByGameIdGenreAsc = 'GAME_BY_GAME_ID__GENRE_ASC',
  GameByGameIdGenreDesc = 'GAME_BY_GAME_ID__GENRE_DESC',
  GameByGameIdGmNamesAsc = 'GAME_BY_GAME_ID__GM_NAMES_ASC',
  GameByGameIdGmNamesDesc = 'GAME_BY_GAME_ID__GM_NAMES_DESC',
  GameByGameIdIdAsc = 'GAME_BY_GAME_ID__ID_ASC',
  GameByGameIdIdDesc = 'GAME_BY_GAME_ID__ID_DESC',
  GameByGameIdLateFinishAsc = 'GAME_BY_GAME_ID__LATE_FINISH_ASC',
  GameByGameIdLateFinishDesc = 'GAME_BY_GAME_ID__LATE_FINISH_DESC',
  GameByGameIdLateStartAsc = 'GAME_BY_GAME_ID__LATE_START_ASC',
  GameByGameIdLateStartDesc = 'GAME_BY_GAME_ID__LATE_START_DESC',
  GameByGameIdMessageAsc = 'GAME_BY_GAME_ID__MESSAGE_ASC',
  GameByGameIdMessageDesc = 'GAME_BY_GAME_ID__MESSAGE_DESC',
  GameByGameIdNameAsc = 'GAME_BY_GAME_ID__NAME_ASC',
  GameByGameIdNameDesc = 'GAME_BY_GAME_ID__NAME_DESC',
  GameByGameIdPlayersContactGmAsc = 'GAME_BY_GAME_ID__PLAYERS_CONTACT_GM_ASC',
  GameByGameIdPlayersContactGmDesc = 'GAME_BY_GAME_ID__PLAYERS_CONTACT_GM_DESC',
  GameByGameIdPlayerMaxAsc = 'GAME_BY_GAME_ID__PLAYER_MAX_ASC',
  GameByGameIdPlayerMaxDesc = 'GAME_BY_GAME_ID__PLAYER_MAX_DESC',
  GameByGameIdPlayerMinAsc = 'GAME_BY_GAME_ID__PLAYER_MIN_ASC',
  GameByGameIdPlayerMinDesc = 'GAME_BY_GAME_ID__PLAYER_MIN_DESC',
  GameByGameIdPlayerPreferenceAsc = 'GAME_BY_GAME_ID__PLAYER_PREFERENCE_ASC',
  GameByGameIdPlayerPreferenceDesc = 'GAME_BY_GAME_ID__PLAYER_PREFERENCE_DESC',
  GameByGameIdReturningPlayersAsc = 'GAME_BY_GAME_ID__RETURNING_PLAYERS_ASC',
  GameByGameIdReturningPlayersDesc = 'GAME_BY_GAME_ID__RETURNING_PLAYERS_DESC',
  GameByGameIdRoomIdAsc = 'GAME_BY_GAME_ID__ROOM_ID_ASC',
  GameByGameIdRoomIdDesc = 'GAME_BY_GAME_ID__ROOM_ID_DESC',
  GameByGameIdSettingAsc = 'GAME_BY_GAME_ID__SETTING_ASC',
  GameByGameIdSettingDesc = 'GAME_BY_GAME_ID__SETTING_DESC',
  GameByGameIdShortNameAsc = 'GAME_BY_GAME_ID__SHORT_NAME_ASC',
  GameByGameIdShortNameDesc = 'GAME_BY_GAME_ID__SHORT_NAME_DESC',
  GameByGameIdSlotConflictsAsc = 'GAME_BY_GAME_ID__SLOT_CONFLICTS_ASC',
  GameByGameIdSlotConflictsDesc = 'GAME_BY_GAME_ID__SLOT_CONFLICTS_DESC',
  GameByGameIdSlotIdAsc = 'GAME_BY_GAME_ID__SLOT_ID_ASC',
  GameByGameIdSlotIdDesc = 'GAME_BY_GAME_ID__SLOT_ID_DESC',
  GameByGameIdSlotPreferenceAsc = 'GAME_BY_GAME_ID__SLOT_PREFERENCE_ASC',
  GameByGameIdSlotPreferenceDesc = 'GAME_BY_GAME_ID__SLOT_PREFERENCE_DESC',
  GameByGameIdTeenFriendlyAsc = 'GAME_BY_GAME_ID__TEEN_FRIENDLY_ASC',
  GameByGameIdTeenFriendlyDesc = 'GAME_BY_GAME_ID__TEEN_FRIENDLY_DESC',
  GameByGameIdTypeAsc = 'GAME_BY_GAME_ID__TYPE_ASC',
  GameByGameIdTypeDesc = 'GAME_BY_GAME_ID__TYPE_DESC',
  GameByGameIdYearAsc = 'GAME_BY_GAME_ID__YEAR_ASC',
  GameByGameIdYearDesc = 'GAME_BY_GAME_ID__YEAR_DESC',
  GameIdAsc = 'GAME_ID_ASC',
  GameIdDesc = 'GAME_ID_DESC',
  GmAsc = 'GM_ASC',
  GmDesc = 'GM_DESC',
  MembershipByMemberIdAmountOwedAsc = 'MEMBERSHIP_BY_MEMBER_ID__AMOUNT_OWED_ASC',
  MembershipByMemberIdAmountOwedDesc = 'MEMBERSHIP_BY_MEMBER_ID__AMOUNT_OWED_DESC',
  MembershipByMemberIdAmountPaidAsc = 'MEMBERSHIP_BY_MEMBER_ID__AMOUNT_PAID_ASC',
  MembershipByMemberIdAmountPaidDesc = 'MEMBERSHIP_BY_MEMBER_ID__AMOUNT_PAID_DESC',
  MembershipByMemberIdArrivalDateAsc = 'MEMBERSHIP_BY_MEMBER_ID__ARRIVAL_DATE_ASC',
  MembershipByMemberIdArrivalDateDesc = 'MEMBERSHIP_BY_MEMBER_ID__ARRIVAL_DATE_DESC',
  MembershipByMemberIdAttendanceAsc = 'MEMBERSHIP_BY_MEMBER_ID__ATTENDANCE_ASC',
  MembershipByMemberIdAttendanceDesc = 'MEMBERSHIP_BY_MEMBER_ID__ATTENDANCE_DESC',
  MembershipByMemberIdAttendingAsc = 'MEMBERSHIP_BY_MEMBER_ID__ATTENDING_ASC',
  MembershipByMemberIdAttendingDesc = 'MEMBERSHIP_BY_MEMBER_ID__ATTENDING_DESC',
  MembershipByMemberIdDepartureDateAsc = 'MEMBERSHIP_BY_MEMBER_ID__DEPARTURE_DATE_ASC',
  MembershipByMemberIdDepartureDateDesc = 'MEMBERSHIP_BY_MEMBER_ID__DEPARTURE_DATE_DESC',
  MembershipByMemberIdHotelRoomIdAsc = 'MEMBERSHIP_BY_MEMBER_ID__HOTEL_ROOM_ID_ASC',
  MembershipByMemberIdHotelRoomIdDesc = 'MEMBERSHIP_BY_MEMBER_ID__HOTEL_ROOM_ID_DESC',
  MembershipByMemberIdIdAsc = 'MEMBERSHIP_BY_MEMBER_ID__ID_ASC',
  MembershipByMemberIdIdDesc = 'MEMBERSHIP_BY_MEMBER_ID__ID_DESC',
  MembershipByMemberIdInterestLevelAsc = 'MEMBERSHIP_BY_MEMBER_ID__INTEREST_LEVEL_ASC',
  MembershipByMemberIdInterestLevelDesc = 'MEMBERSHIP_BY_MEMBER_ID__INTEREST_LEVEL_DESC',
  MembershipByMemberIdMessageAsc = 'MEMBERSHIP_BY_MEMBER_ID__MESSAGE_ASC',
  MembershipByMemberIdMessageDesc = 'MEMBERSHIP_BY_MEMBER_ID__MESSAGE_DESC',
  MembershipByMemberIdOfferSubsidyAsc = 'MEMBERSHIP_BY_MEMBER_ID__OFFER_SUBSIDY_ASC',
  MembershipByMemberIdOfferSubsidyDesc = 'MEMBERSHIP_BY_MEMBER_ID__OFFER_SUBSIDY_DESC',
  MembershipByMemberIdRequestOldPriceAsc = 'MEMBERSHIP_BY_MEMBER_ID__REQUEST_OLD_PRICE_ASC',
  MembershipByMemberIdRequestOldPriceDesc = 'MEMBERSHIP_BY_MEMBER_ID__REQUEST_OLD_PRICE_DESC',
  MembershipByMemberIdRoomingPreferencesAsc = 'MEMBERSHIP_BY_MEMBER_ID__ROOMING_PREFERENCES_ASC',
  MembershipByMemberIdRoomingPreferencesDesc = 'MEMBERSHIP_BY_MEMBER_ID__ROOMING_PREFERENCES_DESC',
  MembershipByMemberIdRoomingWithAsc = 'MEMBERSHIP_BY_MEMBER_ID__ROOMING_WITH_ASC',
  MembershipByMemberIdRoomingWithDesc = 'MEMBERSHIP_BY_MEMBER_ID__ROOMING_WITH_DESC',
  MembershipByMemberIdRoomPreferenceAndNotesAsc = 'MEMBERSHIP_BY_MEMBER_ID__ROOM_PREFERENCE_AND_NOTES_ASC',
  MembershipByMemberIdRoomPreferenceAndNotesDesc = 'MEMBERSHIP_BY_MEMBER_ID__ROOM_PREFERENCE_AND_NOTES_DESC',
  MembershipByMemberIdSlotsAttendingAsc = 'MEMBERSHIP_BY_MEMBER_ID__SLOTS_ATTENDING_ASC',
  MembershipByMemberIdSlotsAttendingDesc = 'MEMBERSHIP_BY_MEMBER_ID__SLOTS_ATTENDING_DESC',
  MembershipByMemberIdUserIdAsc = 'MEMBERSHIP_BY_MEMBER_ID__USER_ID_ASC',
  MembershipByMemberIdUserIdDesc = 'MEMBERSHIP_BY_MEMBER_ID__USER_ID_DESC',
  MembershipByMemberIdVolunteerAsc = 'MEMBERSHIP_BY_MEMBER_ID__VOLUNTEER_ASC',
  MembershipByMemberIdVolunteerDesc = 'MEMBERSHIP_BY_MEMBER_ID__VOLUNTEER_DESC',
  MembershipByMemberIdYearAsc = 'MEMBERSHIP_BY_MEMBER_ID__YEAR_ASC',
  MembershipByMemberIdYearDesc = 'MEMBERSHIP_BY_MEMBER_ID__YEAR_DESC',
  MemberIdAsc = 'MEMBER_ID_ASC',
  MemberIdDesc = 'MEMBER_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  YearAsc = 'YEAR_ASC',
  YearDesc = 'YEAR_DESC',
}

export interface GameChoice extends Node {
  __typename: 'GameChoice'
  /** Reads a single `Game` that is related to this `GameChoice`. */
  game?: Maybe<Game>
  gameId?: Maybe<Scalars['Int']>
  id: Scalars['Int']
  /** Reads a single `Membership` that is related to this `GameChoice`. */
  member?: Maybe<Membership>
  memberId: Scalars['Int']
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']
  rank: Scalars['Int']
  returningPlayer: Scalars['Boolean']
  /** Reads a single `Slot` that is related to this `GameChoice`. */
  slot?: Maybe<Slot>
  slotId: Scalars['Int']
  year: Scalars['Int']
}

/**
 * A condition to be used against `GameChoice` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export interface GameChoiceCondition {
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `memberId` field. */
  memberId?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `rank` field. */
  rank?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `returningPlayer` field. */
  returningPlayer?: InputMaybe<Scalars['Boolean']>
  /** Checks for equality with the object’s `slotId` field. */
  slotId?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `year` field. */
  year?: InputMaybe<Scalars['Int']>
}

/** A filter to be used against `GameChoice` object types. All fields are combined with a logical ‘and.’ */
export interface GameChoiceFilter {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<GameChoiceFilter>>
  /** Filter by the object’s `gameId` field. */
  gameId?: InputMaybe<IntFilter>
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>
  /** Filter by the object’s `memberId` field. */
  memberId?: InputMaybe<IntFilter>
  /** Negates the expression. */
  not?: InputMaybe<GameChoiceFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<GameChoiceFilter>>
  /** Filter by the object’s `rank` field. */
  rank?: InputMaybe<IntFilter>
  /** Filter by the object’s `returningPlayer` field. */
  returningPlayer?: InputMaybe<BooleanFilter>
  /** Filter by the object’s `slotId` field. */
  slotId?: InputMaybe<IntFilter>
  /** Filter by the object’s `year` field. */
  year?: InputMaybe<IntFilter>
}

/** An input for mutations affecting `GameChoice` */
export interface GameChoiceInput {
  gameId?: InputMaybe<Scalars['Int']>
  id?: InputMaybe<Scalars['Int']>
  memberId: Scalars['Int']
  rank: Scalars['Int']
  returningPlayer: Scalars['Boolean']
  slotId: Scalars['Int']
  year: Scalars['Int']
}

/** Represents an update to a `GameChoice`. Fields that are set will be updated. */
export interface GameChoicePatch {
  gameId?: InputMaybe<Scalars['Int']>
  id?: InputMaybe<Scalars['Int']>
  memberId?: InputMaybe<Scalars['Int']>
  rank?: InputMaybe<Scalars['Int']>
  returningPlayer?: InputMaybe<Scalars['Boolean']>
  slotId?: InputMaybe<Scalars['Int']>
  year?: InputMaybe<Scalars['Int']>
}

/** A connection to a list of `GameChoice` values. */
export interface GameChoicesConnection {
  __typename: 'GameChoicesConnection'
  /** A list of edges which contains the `GameChoice` and cursor to aid in pagination. */
  edges: Array<GameChoicesEdge>
  /** A list of `GameChoice` objects. */
  nodes: Array<Maybe<GameChoice>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `GameChoice` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `GameChoice` edge in the connection. */
export interface GameChoicesEdge {
  __typename: 'GameChoicesEdge'
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `GameChoice` at the end of the edge. */
  node?: Maybe<GameChoice>
}

/** Methods to use when ordering `GameChoice`. */
export enum GameChoicesOrderBy {
  GameByGameIdAuthorIdAsc = 'GAME_BY_GAME_ID__AUTHOR_ID_ASC',
  GameByGameIdAuthorIdDesc = 'GAME_BY_GAME_ID__AUTHOR_ID_DESC',
  GameByGameIdCharInstructionsAsc = 'GAME_BY_GAME_ID__CHAR_INSTRUCTIONS_ASC',
  GameByGameIdCharInstructionsDesc = 'GAME_BY_GAME_ID__CHAR_INSTRUCTIONS_DESC',
  GameByGameIdDescriptionAsc = 'GAME_BY_GAME_ID__DESCRIPTION_ASC',
  GameByGameIdDescriptionDesc = 'GAME_BY_GAME_ID__DESCRIPTION_DESC',
  GameByGameIdEstimatedLengthAsc = 'GAME_BY_GAME_ID__ESTIMATED_LENGTH_ASC',
  GameByGameIdEstimatedLengthDesc = 'GAME_BY_GAME_ID__ESTIMATED_LENGTH_DESC',
  GameByGameIdFullAsc = 'GAME_BY_GAME_ID__FULL_ASC',
  GameByGameIdFullDesc = 'GAME_BY_GAME_ID__FULL_DESC',
  GameByGameIdGameContactEmailAsc = 'GAME_BY_GAME_ID__GAME_CONTACT_EMAIL_ASC',
  GameByGameIdGameContactEmailDesc = 'GAME_BY_GAME_ID__GAME_CONTACT_EMAIL_DESC',
  GameByGameIdGenreAsc = 'GAME_BY_GAME_ID__GENRE_ASC',
  GameByGameIdGenreDesc = 'GAME_BY_GAME_ID__GENRE_DESC',
  GameByGameIdGmNamesAsc = 'GAME_BY_GAME_ID__GM_NAMES_ASC',
  GameByGameIdGmNamesDesc = 'GAME_BY_GAME_ID__GM_NAMES_DESC',
  GameByGameIdIdAsc = 'GAME_BY_GAME_ID__ID_ASC',
  GameByGameIdIdDesc = 'GAME_BY_GAME_ID__ID_DESC',
  GameByGameIdLateFinishAsc = 'GAME_BY_GAME_ID__LATE_FINISH_ASC',
  GameByGameIdLateFinishDesc = 'GAME_BY_GAME_ID__LATE_FINISH_DESC',
  GameByGameIdLateStartAsc = 'GAME_BY_GAME_ID__LATE_START_ASC',
  GameByGameIdLateStartDesc = 'GAME_BY_GAME_ID__LATE_START_DESC',
  GameByGameIdMessageAsc = 'GAME_BY_GAME_ID__MESSAGE_ASC',
  GameByGameIdMessageDesc = 'GAME_BY_GAME_ID__MESSAGE_DESC',
  GameByGameIdNameAsc = 'GAME_BY_GAME_ID__NAME_ASC',
  GameByGameIdNameDesc = 'GAME_BY_GAME_ID__NAME_DESC',
  GameByGameIdPlayersContactGmAsc = 'GAME_BY_GAME_ID__PLAYERS_CONTACT_GM_ASC',
  GameByGameIdPlayersContactGmDesc = 'GAME_BY_GAME_ID__PLAYERS_CONTACT_GM_DESC',
  GameByGameIdPlayerMaxAsc = 'GAME_BY_GAME_ID__PLAYER_MAX_ASC',
  GameByGameIdPlayerMaxDesc = 'GAME_BY_GAME_ID__PLAYER_MAX_DESC',
  GameByGameIdPlayerMinAsc = 'GAME_BY_GAME_ID__PLAYER_MIN_ASC',
  GameByGameIdPlayerMinDesc = 'GAME_BY_GAME_ID__PLAYER_MIN_DESC',
  GameByGameIdPlayerPreferenceAsc = 'GAME_BY_GAME_ID__PLAYER_PREFERENCE_ASC',
  GameByGameIdPlayerPreferenceDesc = 'GAME_BY_GAME_ID__PLAYER_PREFERENCE_DESC',
  GameByGameIdReturningPlayersAsc = 'GAME_BY_GAME_ID__RETURNING_PLAYERS_ASC',
  GameByGameIdReturningPlayersDesc = 'GAME_BY_GAME_ID__RETURNING_PLAYERS_DESC',
  GameByGameIdRoomIdAsc = 'GAME_BY_GAME_ID__ROOM_ID_ASC',
  GameByGameIdRoomIdDesc = 'GAME_BY_GAME_ID__ROOM_ID_DESC',
  GameByGameIdSettingAsc = 'GAME_BY_GAME_ID__SETTING_ASC',
  GameByGameIdSettingDesc = 'GAME_BY_GAME_ID__SETTING_DESC',
  GameByGameIdShortNameAsc = 'GAME_BY_GAME_ID__SHORT_NAME_ASC',
  GameByGameIdShortNameDesc = 'GAME_BY_GAME_ID__SHORT_NAME_DESC',
  GameByGameIdSlotConflictsAsc = 'GAME_BY_GAME_ID__SLOT_CONFLICTS_ASC',
  GameByGameIdSlotConflictsDesc = 'GAME_BY_GAME_ID__SLOT_CONFLICTS_DESC',
  GameByGameIdSlotIdAsc = 'GAME_BY_GAME_ID__SLOT_ID_ASC',
  GameByGameIdSlotIdDesc = 'GAME_BY_GAME_ID__SLOT_ID_DESC',
  GameByGameIdSlotPreferenceAsc = 'GAME_BY_GAME_ID__SLOT_PREFERENCE_ASC',
  GameByGameIdSlotPreferenceDesc = 'GAME_BY_GAME_ID__SLOT_PREFERENCE_DESC',
  GameByGameIdTeenFriendlyAsc = 'GAME_BY_GAME_ID__TEEN_FRIENDLY_ASC',
  GameByGameIdTeenFriendlyDesc = 'GAME_BY_GAME_ID__TEEN_FRIENDLY_DESC',
  GameByGameIdTypeAsc = 'GAME_BY_GAME_ID__TYPE_ASC',
  GameByGameIdTypeDesc = 'GAME_BY_GAME_ID__TYPE_DESC',
  GameByGameIdYearAsc = 'GAME_BY_GAME_ID__YEAR_ASC',
  GameByGameIdYearDesc = 'GAME_BY_GAME_ID__YEAR_DESC',
  GameIdAsc = 'GAME_ID_ASC',
  GameIdDesc = 'GAME_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  MembershipByMemberIdAmountOwedAsc = 'MEMBERSHIP_BY_MEMBER_ID__AMOUNT_OWED_ASC',
  MembershipByMemberIdAmountOwedDesc = 'MEMBERSHIP_BY_MEMBER_ID__AMOUNT_OWED_DESC',
  MembershipByMemberIdAmountPaidAsc = 'MEMBERSHIP_BY_MEMBER_ID__AMOUNT_PAID_ASC',
  MembershipByMemberIdAmountPaidDesc = 'MEMBERSHIP_BY_MEMBER_ID__AMOUNT_PAID_DESC',
  MembershipByMemberIdArrivalDateAsc = 'MEMBERSHIP_BY_MEMBER_ID__ARRIVAL_DATE_ASC',
  MembershipByMemberIdArrivalDateDesc = 'MEMBERSHIP_BY_MEMBER_ID__ARRIVAL_DATE_DESC',
  MembershipByMemberIdAttendanceAsc = 'MEMBERSHIP_BY_MEMBER_ID__ATTENDANCE_ASC',
  MembershipByMemberIdAttendanceDesc = 'MEMBERSHIP_BY_MEMBER_ID__ATTENDANCE_DESC',
  MembershipByMemberIdAttendingAsc = 'MEMBERSHIP_BY_MEMBER_ID__ATTENDING_ASC',
  MembershipByMemberIdAttendingDesc = 'MEMBERSHIP_BY_MEMBER_ID__ATTENDING_DESC',
  MembershipByMemberIdDepartureDateAsc = 'MEMBERSHIP_BY_MEMBER_ID__DEPARTURE_DATE_ASC',
  MembershipByMemberIdDepartureDateDesc = 'MEMBERSHIP_BY_MEMBER_ID__DEPARTURE_DATE_DESC',
  MembershipByMemberIdHotelRoomIdAsc = 'MEMBERSHIP_BY_MEMBER_ID__HOTEL_ROOM_ID_ASC',
  MembershipByMemberIdHotelRoomIdDesc = 'MEMBERSHIP_BY_MEMBER_ID__HOTEL_ROOM_ID_DESC',
  MembershipByMemberIdIdAsc = 'MEMBERSHIP_BY_MEMBER_ID__ID_ASC',
  MembershipByMemberIdIdDesc = 'MEMBERSHIP_BY_MEMBER_ID__ID_DESC',
  MembershipByMemberIdInterestLevelAsc = 'MEMBERSHIP_BY_MEMBER_ID__INTEREST_LEVEL_ASC',
  MembershipByMemberIdInterestLevelDesc = 'MEMBERSHIP_BY_MEMBER_ID__INTEREST_LEVEL_DESC',
  MembershipByMemberIdMessageAsc = 'MEMBERSHIP_BY_MEMBER_ID__MESSAGE_ASC',
  MembershipByMemberIdMessageDesc = 'MEMBERSHIP_BY_MEMBER_ID__MESSAGE_DESC',
  MembershipByMemberIdOfferSubsidyAsc = 'MEMBERSHIP_BY_MEMBER_ID__OFFER_SUBSIDY_ASC',
  MembershipByMemberIdOfferSubsidyDesc = 'MEMBERSHIP_BY_MEMBER_ID__OFFER_SUBSIDY_DESC',
  MembershipByMemberIdRequestOldPriceAsc = 'MEMBERSHIP_BY_MEMBER_ID__REQUEST_OLD_PRICE_ASC',
  MembershipByMemberIdRequestOldPriceDesc = 'MEMBERSHIP_BY_MEMBER_ID__REQUEST_OLD_PRICE_DESC',
  MembershipByMemberIdRoomingPreferencesAsc = 'MEMBERSHIP_BY_MEMBER_ID__ROOMING_PREFERENCES_ASC',
  MembershipByMemberIdRoomingPreferencesDesc = 'MEMBERSHIP_BY_MEMBER_ID__ROOMING_PREFERENCES_DESC',
  MembershipByMemberIdRoomingWithAsc = 'MEMBERSHIP_BY_MEMBER_ID__ROOMING_WITH_ASC',
  MembershipByMemberIdRoomingWithDesc = 'MEMBERSHIP_BY_MEMBER_ID__ROOMING_WITH_DESC',
  MembershipByMemberIdRoomPreferenceAndNotesAsc = 'MEMBERSHIP_BY_MEMBER_ID__ROOM_PREFERENCE_AND_NOTES_ASC',
  MembershipByMemberIdRoomPreferenceAndNotesDesc = 'MEMBERSHIP_BY_MEMBER_ID__ROOM_PREFERENCE_AND_NOTES_DESC',
  MembershipByMemberIdSlotsAttendingAsc = 'MEMBERSHIP_BY_MEMBER_ID__SLOTS_ATTENDING_ASC',
  MembershipByMemberIdSlotsAttendingDesc = 'MEMBERSHIP_BY_MEMBER_ID__SLOTS_ATTENDING_DESC',
  MembershipByMemberIdUserIdAsc = 'MEMBERSHIP_BY_MEMBER_ID__USER_ID_ASC',
  MembershipByMemberIdUserIdDesc = 'MEMBERSHIP_BY_MEMBER_ID__USER_ID_DESC',
  MembershipByMemberIdVolunteerAsc = 'MEMBERSHIP_BY_MEMBER_ID__VOLUNTEER_ASC',
  MembershipByMemberIdVolunteerDesc = 'MEMBERSHIP_BY_MEMBER_ID__VOLUNTEER_DESC',
  MembershipByMemberIdYearAsc = 'MEMBERSHIP_BY_MEMBER_ID__YEAR_ASC',
  MembershipByMemberIdYearDesc = 'MEMBERSHIP_BY_MEMBER_ID__YEAR_DESC',
  MemberIdAsc = 'MEMBER_ID_ASC',
  MemberIdDesc = 'MEMBER_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RankAsc = 'RANK_ASC',
  RankDesc = 'RANK_DESC',
  ReturningPlayerAsc = 'RETURNING_PLAYER_ASC',
  ReturningPlayerDesc = 'RETURNING_PLAYER_DESC',
  SlotBySlotIdDayAsc = 'SLOT_BY_SLOT_ID__DAY_ASC',
  SlotBySlotIdDayDesc = 'SLOT_BY_SLOT_ID__DAY_DESC',
  SlotBySlotIdFormattedDateAsc = 'SLOT_BY_SLOT_ID__FORMATTED_DATE_ASC',
  SlotBySlotIdFormattedDateDesc = 'SLOT_BY_SLOT_ID__FORMATTED_DATE_DESC',
  SlotBySlotIdIdAsc = 'SLOT_BY_SLOT_ID__ID_ASC',
  SlotBySlotIdIdDesc = 'SLOT_BY_SLOT_ID__ID_DESC',
  SlotBySlotIdLengthAsc = 'SLOT_BY_SLOT_ID__LENGTH_ASC',
  SlotBySlotIdLengthDesc = 'SLOT_BY_SLOT_ID__LENGTH_DESC',
  SlotBySlotIdSlotAsc = 'SLOT_BY_SLOT_ID__SLOT_ASC',
  SlotBySlotIdSlotDesc = 'SLOT_BY_SLOT_ID__SLOT_DESC',
  SlotBySlotIdTimeAsc = 'SLOT_BY_SLOT_ID__TIME_ASC',
  SlotBySlotIdTimeDesc = 'SLOT_BY_SLOT_ID__TIME_DESC',
  SlotIdAsc = 'SLOT_ID_ASC',
  SlotIdDesc = 'SLOT_ID_DESC',
  YearAsc = 'YEAR_ASC',
  YearDesc = 'YEAR_DESC',
}

/** A condition to be used against `Game` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export interface GameCondition {
  /** Checks for equality with the object’s `authorId` field. */
  authorId?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `charInstructions` field. */
  charInstructions?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `estimatedLength` field. */
  estimatedLength?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `full` field. */
  full?: InputMaybe<Scalars['Boolean']>
  /** Checks for equality with the object’s `gameContactEmail` field. */
  gameContactEmail?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `genre` field. */
  genre?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `gmNames` field. */
  gmNames?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `lateFinish` field. */
  lateFinish?: InputMaybe<Scalars['Boolean']>
  /** Checks for equality with the object’s `lateStart` field. */
  lateStart?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `message` field. */
  message?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `playerMax` field. */
  playerMax?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `playerMin` field. */
  playerMin?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `playerPreference` field. */
  playerPreference?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `playersContactGm` field. */
  playersContactGm?: InputMaybe<Scalars['Boolean']>
  /** Checks for equality with the object’s `returningPlayers` field. */
  returningPlayers?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `roomId` field. */
  roomId?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `setting` field. */
  setting?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `shortName` field. */
  shortName?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `slotConflicts` field. */
  slotConflicts?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `slotId` field. */
  slotId?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `slotPreference` field. */
  slotPreference?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `teenFriendly` field. */
  teenFriendly?: InputMaybe<Scalars['Boolean']>
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `year` field. */
  year?: InputMaybe<Scalars['Int']>
}

/** A filter to be used against `Game` object types. All fields are combined with a logical ‘and.’ */
export interface GameFilter {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<GameFilter>>
  /** Filter by the object’s `authorId` field. */
  authorId?: InputMaybe<IntFilter>
  /** Filter by the object’s `charInstructions` field. */
  charInstructions?: InputMaybe<StringFilter>
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>
  /** Filter by the object’s `estimatedLength` field. */
  estimatedLength?: InputMaybe<StringFilter>
  /** Filter by the object’s `full` field. */
  full?: InputMaybe<BooleanFilter>
  /** Filter by the object’s `gameContactEmail` field. */
  gameContactEmail?: InputMaybe<StringFilter>
  /** Filter by the object’s `genre` field. */
  genre?: InputMaybe<StringFilter>
  /** Filter by the object’s `gmNames` field. */
  gmNames?: InputMaybe<StringFilter>
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>
  /** Filter by the object’s `lateFinish` field. */
  lateFinish?: InputMaybe<BooleanFilter>
  /** Filter by the object’s `lateStart` field. */
  lateStart?: InputMaybe<StringFilter>
  /** Filter by the object’s `message` field. */
  message?: InputMaybe<StringFilter>
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>
  /** Negates the expression. */
  not?: InputMaybe<GameFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<GameFilter>>
  /** Filter by the object’s `playerMax` field. */
  playerMax?: InputMaybe<IntFilter>
  /** Filter by the object’s `playerMin` field. */
  playerMin?: InputMaybe<IntFilter>
  /** Filter by the object’s `playerPreference` field. */
  playerPreference?: InputMaybe<StringFilter>
  /** Filter by the object’s `playersContactGm` field. */
  playersContactGm?: InputMaybe<BooleanFilter>
  /** Filter by the object’s `returningPlayers` field. */
  returningPlayers?: InputMaybe<StringFilter>
  /** Filter by the object’s `roomId` field. */
  roomId?: InputMaybe<IntFilter>
  /** Filter by the object’s `setting` field. */
  setting?: InputMaybe<StringFilter>
  /** Filter by the object’s `shortName` field. */
  shortName?: InputMaybe<StringFilter>
  /** Filter by the object’s `slotConflicts` field. */
  slotConflicts?: InputMaybe<StringFilter>
  /** Filter by the object’s `slotId` field. */
  slotId?: InputMaybe<IntFilter>
  /** Filter by the object’s `slotPreference` field. */
  slotPreference?: InputMaybe<IntFilter>
  /** Filter by the object’s `teenFriendly` field. */
  teenFriendly?: InputMaybe<BooleanFilter>
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<StringFilter>
  /** Filter by the object’s `year` field. */
  year?: InputMaybe<IntFilter>
}

/** An input for mutations affecting `Game` */
export interface GameInput {
  authorId?: InputMaybe<Scalars['Int']>
  charInstructions: Scalars['String']
  description: Scalars['String']
  estimatedLength: Scalars['String']
  full?: InputMaybe<Scalars['Boolean']>
  gameContactEmail: Scalars['String']
  genre: Scalars['String']
  gmNames?: InputMaybe<Scalars['String']>
  id?: InputMaybe<Scalars['Int']>
  lateFinish?: InputMaybe<Scalars['Boolean']>
  lateStart?: InputMaybe<Scalars['String']>
  message: Scalars['String']
  name: Scalars['String']
  playerMax: Scalars['Int']
  playerMin: Scalars['Int']
  playerPreference: Scalars['String']
  playersContactGm: Scalars['Boolean']
  returningPlayers: Scalars['String']
  roomId?: InputMaybe<Scalars['Int']>
  setting: Scalars['String']
  shortName?: InputMaybe<Scalars['String']>
  slotConflicts: Scalars['String']
  slotId?: InputMaybe<Scalars['Int']>
  slotPreference: Scalars['Int']
  teenFriendly: Scalars['Boolean']
  type: Scalars['String']
  year: Scalars['Int']
}

/** Represents an update to a `Game`. Fields that are set will be updated. */
export interface GamePatch {
  authorId?: InputMaybe<Scalars['Int']>
  charInstructions?: InputMaybe<Scalars['String']>
  description?: InputMaybe<Scalars['String']>
  estimatedLength?: InputMaybe<Scalars['String']>
  full?: InputMaybe<Scalars['Boolean']>
  gameContactEmail?: InputMaybe<Scalars['String']>
  genre?: InputMaybe<Scalars['String']>
  gmNames?: InputMaybe<Scalars['String']>
  id?: InputMaybe<Scalars['Int']>
  lateFinish?: InputMaybe<Scalars['Boolean']>
  lateStart?: InputMaybe<Scalars['String']>
  message?: InputMaybe<Scalars['String']>
  name?: InputMaybe<Scalars['String']>
  playerMax?: InputMaybe<Scalars['Int']>
  playerMin?: InputMaybe<Scalars['Int']>
  playerPreference?: InputMaybe<Scalars['String']>
  playersContactGm?: InputMaybe<Scalars['Boolean']>
  returningPlayers?: InputMaybe<Scalars['String']>
  roomId?: InputMaybe<Scalars['Int']>
  setting?: InputMaybe<Scalars['String']>
  shortName?: InputMaybe<Scalars['String']>
  slotConflicts?: InputMaybe<Scalars['String']>
  slotId?: InputMaybe<Scalars['Int']>
  slotPreference?: InputMaybe<Scalars['Int']>
  teenFriendly?: InputMaybe<Scalars['Boolean']>
  type?: InputMaybe<Scalars['String']>
  year?: InputMaybe<Scalars['Int']>
}

export interface GameSubmission extends Node {
  __typename: 'GameSubmission'
  id: Scalars['Int']
  /** Reads a single `Membership` that is related to this `GameSubmission`. */
  member?: Maybe<Membership>
  memberId: Scalars['Int']
  message: Scalars['String']
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']
  year: Scalars['Int']
}

/**
 * A condition to be used against `GameSubmission` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export interface GameSubmissionCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `memberId` field. */
  memberId?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `message` field. */
  message?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `year` field. */
  year?: InputMaybe<Scalars['Int']>
}

/** A filter to be used against `GameSubmission` object types. All fields are combined with a logical ‘and.’ */
export interface GameSubmissionFilter {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<GameSubmissionFilter>>
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>
  /** Filter by the object’s `memberId` field. */
  memberId?: InputMaybe<IntFilter>
  /** Filter by the object’s `message` field. */
  message?: InputMaybe<StringFilter>
  /** Negates the expression. */
  not?: InputMaybe<GameSubmissionFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<GameSubmissionFilter>>
  /** Filter by the object’s `year` field. */
  year?: InputMaybe<IntFilter>
}

/** An input for mutations affecting `GameSubmission` */
export interface GameSubmissionInput {
  id?: InputMaybe<Scalars['Int']>
  memberId: Scalars['Int']
  message: Scalars['String']
  year: Scalars['Int']
}

/** Represents an update to a `GameSubmission`. Fields that are set will be updated. */
export interface GameSubmissionPatch {
  id?: InputMaybe<Scalars['Int']>
  memberId?: InputMaybe<Scalars['Int']>
  message?: InputMaybe<Scalars['String']>
  year?: InputMaybe<Scalars['Int']>
}

/** A connection to a list of `GameSubmission` values. */
export interface GameSubmissionsConnection {
  __typename: 'GameSubmissionsConnection'
  /** A list of edges which contains the `GameSubmission` and cursor to aid in pagination. */
  edges: Array<GameSubmissionsEdge>
  /** A list of `GameSubmission` objects. */
  nodes: Array<Maybe<GameSubmission>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `GameSubmission` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `GameSubmission` edge in the connection. */
export interface GameSubmissionsEdge {
  __typename: 'GameSubmissionsEdge'
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `GameSubmission` at the end of the edge. */
  node?: Maybe<GameSubmission>
}

/** Methods to use when ordering `GameSubmission`. */
export enum GameSubmissionsOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  MembershipByMemberIdAmountOwedAsc = 'MEMBERSHIP_BY_MEMBER_ID__AMOUNT_OWED_ASC',
  MembershipByMemberIdAmountOwedDesc = 'MEMBERSHIP_BY_MEMBER_ID__AMOUNT_OWED_DESC',
  MembershipByMemberIdAmountPaidAsc = 'MEMBERSHIP_BY_MEMBER_ID__AMOUNT_PAID_ASC',
  MembershipByMemberIdAmountPaidDesc = 'MEMBERSHIP_BY_MEMBER_ID__AMOUNT_PAID_DESC',
  MembershipByMemberIdArrivalDateAsc = 'MEMBERSHIP_BY_MEMBER_ID__ARRIVAL_DATE_ASC',
  MembershipByMemberIdArrivalDateDesc = 'MEMBERSHIP_BY_MEMBER_ID__ARRIVAL_DATE_DESC',
  MembershipByMemberIdAttendanceAsc = 'MEMBERSHIP_BY_MEMBER_ID__ATTENDANCE_ASC',
  MembershipByMemberIdAttendanceDesc = 'MEMBERSHIP_BY_MEMBER_ID__ATTENDANCE_DESC',
  MembershipByMemberIdAttendingAsc = 'MEMBERSHIP_BY_MEMBER_ID__ATTENDING_ASC',
  MembershipByMemberIdAttendingDesc = 'MEMBERSHIP_BY_MEMBER_ID__ATTENDING_DESC',
  MembershipByMemberIdDepartureDateAsc = 'MEMBERSHIP_BY_MEMBER_ID__DEPARTURE_DATE_ASC',
  MembershipByMemberIdDepartureDateDesc = 'MEMBERSHIP_BY_MEMBER_ID__DEPARTURE_DATE_DESC',
  MembershipByMemberIdHotelRoomIdAsc = 'MEMBERSHIP_BY_MEMBER_ID__HOTEL_ROOM_ID_ASC',
  MembershipByMemberIdHotelRoomIdDesc = 'MEMBERSHIP_BY_MEMBER_ID__HOTEL_ROOM_ID_DESC',
  MembershipByMemberIdIdAsc = 'MEMBERSHIP_BY_MEMBER_ID__ID_ASC',
  MembershipByMemberIdIdDesc = 'MEMBERSHIP_BY_MEMBER_ID__ID_DESC',
  MembershipByMemberIdInterestLevelAsc = 'MEMBERSHIP_BY_MEMBER_ID__INTEREST_LEVEL_ASC',
  MembershipByMemberIdInterestLevelDesc = 'MEMBERSHIP_BY_MEMBER_ID__INTEREST_LEVEL_DESC',
  MembershipByMemberIdMessageAsc = 'MEMBERSHIP_BY_MEMBER_ID__MESSAGE_ASC',
  MembershipByMemberIdMessageDesc = 'MEMBERSHIP_BY_MEMBER_ID__MESSAGE_DESC',
  MembershipByMemberIdOfferSubsidyAsc = 'MEMBERSHIP_BY_MEMBER_ID__OFFER_SUBSIDY_ASC',
  MembershipByMemberIdOfferSubsidyDesc = 'MEMBERSHIP_BY_MEMBER_ID__OFFER_SUBSIDY_DESC',
  MembershipByMemberIdRequestOldPriceAsc = 'MEMBERSHIP_BY_MEMBER_ID__REQUEST_OLD_PRICE_ASC',
  MembershipByMemberIdRequestOldPriceDesc = 'MEMBERSHIP_BY_MEMBER_ID__REQUEST_OLD_PRICE_DESC',
  MembershipByMemberIdRoomingPreferencesAsc = 'MEMBERSHIP_BY_MEMBER_ID__ROOMING_PREFERENCES_ASC',
  MembershipByMemberIdRoomingPreferencesDesc = 'MEMBERSHIP_BY_MEMBER_ID__ROOMING_PREFERENCES_DESC',
  MembershipByMemberIdRoomingWithAsc = 'MEMBERSHIP_BY_MEMBER_ID__ROOMING_WITH_ASC',
  MembershipByMemberIdRoomingWithDesc = 'MEMBERSHIP_BY_MEMBER_ID__ROOMING_WITH_DESC',
  MembershipByMemberIdRoomPreferenceAndNotesAsc = 'MEMBERSHIP_BY_MEMBER_ID__ROOM_PREFERENCE_AND_NOTES_ASC',
  MembershipByMemberIdRoomPreferenceAndNotesDesc = 'MEMBERSHIP_BY_MEMBER_ID__ROOM_PREFERENCE_AND_NOTES_DESC',
  MembershipByMemberIdSlotsAttendingAsc = 'MEMBERSHIP_BY_MEMBER_ID__SLOTS_ATTENDING_ASC',
  MembershipByMemberIdSlotsAttendingDesc = 'MEMBERSHIP_BY_MEMBER_ID__SLOTS_ATTENDING_DESC',
  MembershipByMemberIdUserIdAsc = 'MEMBERSHIP_BY_MEMBER_ID__USER_ID_ASC',
  MembershipByMemberIdUserIdDesc = 'MEMBERSHIP_BY_MEMBER_ID__USER_ID_DESC',
  MembershipByMemberIdVolunteerAsc = 'MEMBERSHIP_BY_MEMBER_ID__VOLUNTEER_ASC',
  MembershipByMemberIdVolunteerDesc = 'MEMBERSHIP_BY_MEMBER_ID__VOLUNTEER_DESC',
  MembershipByMemberIdYearAsc = 'MEMBERSHIP_BY_MEMBER_ID__YEAR_ASC',
  MembershipByMemberIdYearDesc = 'MEMBERSHIP_BY_MEMBER_ID__YEAR_DESC',
  MemberIdAsc = 'MEMBER_ID_ASC',
  MemberIdDesc = 'MEMBER_ID_DESC',
  MessageAsc = 'MESSAGE_ASC',
  MessageDesc = 'MESSAGE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  YearAsc = 'YEAR_ASC',
  YearDesc = 'YEAR_DESC',
}

/** A connection to a list of `Game` values. */
export interface GamesConnection {
  __typename: 'GamesConnection'
  /** A list of edges which contains the `Game` and cursor to aid in pagination. */
  edges: Array<GamesEdge>
  /** A list of `Game` objects. */
  nodes: Array<Maybe<Game>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Game` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Game` edge in the connection. */
export interface GamesEdge {
  __typename: 'GamesEdge'
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Game` at the end of the edge. */
  node?: Maybe<Game>
}

/** Methods to use when ordering `Game`. */
export enum GamesOrderBy {
  AuthorIdAsc = 'AUTHOR_ID_ASC',
  AuthorIdDesc = 'AUTHOR_ID_DESC',
  CharInstructionsAsc = 'CHAR_INSTRUCTIONS_ASC',
  CharInstructionsDesc = 'CHAR_INSTRUCTIONS_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  EstimatedLengthAsc = 'ESTIMATED_LENGTH_ASC',
  EstimatedLengthDesc = 'ESTIMATED_LENGTH_DESC',
  FullAsc = 'FULL_ASC',
  FullDesc = 'FULL_DESC',
  GameAssignmentsByGameIdCountAsc = 'GAME_ASSIGNMENTS_BY_GAME_ID__COUNT_ASC',
  GameAssignmentsByGameIdCountDesc = 'GAME_ASSIGNMENTS_BY_GAME_ID__COUNT_DESC',
  GameChoicesByGameIdCountAsc = 'GAME_CHOICES_BY_GAME_ID__COUNT_ASC',
  GameChoicesByGameIdCountDesc = 'GAME_CHOICES_BY_GAME_ID__COUNT_DESC',
  GameContactEmailAsc = 'GAME_CONTACT_EMAIL_ASC',
  GameContactEmailDesc = 'GAME_CONTACT_EMAIL_DESC',
  GenreAsc = 'GENRE_ASC',
  GenreDesc = 'GENRE_DESC',
  GmNamesAsc = 'GM_NAMES_ASC',
  GmNamesDesc = 'GM_NAMES_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LateFinishAsc = 'LATE_FINISH_ASC',
  LateFinishDesc = 'LATE_FINISH_DESC',
  LateStartAsc = 'LATE_START_ASC',
  LateStartDesc = 'LATE_START_DESC',
  MessageAsc = 'MESSAGE_ASC',
  MessageDesc = 'MESSAGE_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PlayersContactGmAsc = 'PLAYERS_CONTACT_GM_ASC',
  PlayersContactGmDesc = 'PLAYERS_CONTACT_GM_DESC',
  PlayerMaxAsc = 'PLAYER_MAX_ASC',
  PlayerMaxDesc = 'PLAYER_MAX_DESC',
  PlayerMinAsc = 'PLAYER_MIN_ASC',
  PlayerMinDesc = 'PLAYER_MIN_DESC',
  PlayerPreferenceAsc = 'PLAYER_PREFERENCE_ASC',
  PlayerPreferenceDesc = 'PLAYER_PREFERENCE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ReturningPlayersAsc = 'RETURNING_PLAYERS_ASC',
  ReturningPlayersDesc = 'RETURNING_PLAYERS_DESC',
  RoomByRoomIdDescriptionAsc = 'ROOM_BY_ROOM_ID__DESCRIPTION_ASC',
  RoomByRoomIdDescriptionDesc = 'ROOM_BY_ROOM_ID__DESCRIPTION_DESC',
  RoomByRoomIdIdAsc = 'ROOM_BY_ROOM_ID__ID_ASC',
  RoomByRoomIdIdDesc = 'ROOM_BY_ROOM_ID__ID_DESC',
  RoomByRoomIdSizeAsc = 'ROOM_BY_ROOM_ID__SIZE_ASC',
  RoomByRoomIdSizeDesc = 'ROOM_BY_ROOM_ID__SIZE_DESC',
  RoomByRoomIdTypeAsc = 'ROOM_BY_ROOM_ID__TYPE_ASC',
  RoomByRoomIdTypeDesc = 'ROOM_BY_ROOM_ID__TYPE_DESC',
  RoomByRoomIdUpdatedAsc = 'ROOM_BY_ROOM_ID__UPDATED_ASC',
  RoomByRoomIdUpdatedDesc = 'ROOM_BY_ROOM_ID__UPDATED_DESC',
  RoomIdAsc = 'ROOM_ID_ASC',
  RoomIdDesc = 'ROOM_ID_DESC',
  SettingAsc = 'SETTING_ASC',
  SettingDesc = 'SETTING_DESC',
  ShortNameAsc = 'SHORT_NAME_ASC',
  ShortNameDesc = 'SHORT_NAME_DESC',
  SlotBySlotIdDayAsc = 'SLOT_BY_SLOT_ID__DAY_ASC',
  SlotBySlotIdDayDesc = 'SLOT_BY_SLOT_ID__DAY_DESC',
  SlotBySlotIdFormattedDateAsc = 'SLOT_BY_SLOT_ID__FORMATTED_DATE_ASC',
  SlotBySlotIdFormattedDateDesc = 'SLOT_BY_SLOT_ID__FORMATTED_DATE_DESC',
  SlotBySlotIdIdAsc = 'SLOT_BY_SLOT_ID__ID_ASC',
  SlotBySlotIdIdDesc = 'SLOT_BY_SLOT_ID__ID_DESC',
  SlotBySlotIdLengthAsc = 'SLOT_BY_SLOT_ID__LENGTH_ASC',
  SlotBySlotIdLengthDesc = 'SLOT_BY_SLOT_ID__LENGTH_DESC',
  SlotBySlotIdSlotAsc = 'SLOT_BY_SLOT_ID__SLOT_ASC',
  SlotBySlotIdSlotDesc = 'SLOT_BY_SLOT_ID__SLOT_DESC',
  SlotBySlotIdTimeAsc = 'SLOT_BY_SLOT_ID__TIME_ASC',
  SlotBySlotIdTimeDesc = 'SLOT_BY_SLOT_ID__TIME_DESC',
  SlotConflictsAsc = 'SLOT_CONFLICTS_ASC',
  SlotConflictsDesc = 'SLOT_CONFLICTS_DESC',
  SlotIdAsc = 'SLOT_ID_ASC',
  SlotIdDesc = 'SLOT_ID_DESC',
  SlotPreferenceAsc = 'SLOT_PREFERENCE_ASC',
  SlotPreferenceDesc = 'SLOT_PREFERENCE_DESC',
  TeenFriendlyAsc = 'TEEN_FRIENDLY_ASC',
  TeenFriendlyDesc = 'TEEN_FRIENDLY_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  UserByAuthorIdEmailAsc = 'USER_BY_AUTHOR_ID__EMAIL_ASC',
  UserByAuthorIdEmailDesc = 'USER_BY_AUTHOR_ID__EMAIL_DESC',
  UserByAuthorIdFirstNameAsc = 'USER_BY_AUTHOR_ID__FIRST_NAME_ASC',
  UserByAuthorIdFirstNameDesc = 'USER_BY_AUTHOR_ID__FIRST_NAME_DESC',
  UserByAuthorIdFullNameAsc = 'USER_BY_AUTHOR_ID__FULL_NAME_ASC',
  UserByAuthorIdFullNameDesc = 'USER_BY_AUTHOR_ID__FULL_NAME_DESC',
  UserByAuthorIdIdAsc = 'USER_BY_AUTHOR_ID__ID_ASC',
  UserByAuthorIdIdDesc = 'USER_BY_AUTHOR_ID__ID_DESC',
  UserByAuthorIdLastNameAsc = 'USER_BY_AUTHOR_ID__LAST_NAME_ASC',
  UserByAuthorIdLastNameDesc = 'USER_BY_AUTHOR_ID__LAST_NAME_DESC',
  YearAsc = 'YEAR_ASC',
  YearDesc = 'YEAR_DESC',
}

export interface HotelRoom extends Node {
  __typename: 'HotelRoom'
  bathroomType: Scalars['String']
  description: Scalars['String']
  gamingRoom: Scalars['Boolean']
  id: Scalars['Int']
  /** Reads and enables pagination through a set of `Membership`. */
  memberships: MembershipsConnection
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']
  occupancy: Scalars['String']
  quantity: Scalars['Int']
  rate: Scalars['String']
  type: Scalars['String']
}

export interface HotelRoomMembershipsArgs {
  after?: InputMaybe<Scalars['Cursor']>
  before?: InputMaybe<Scalars['Cursor']>
  condition?: InputMaybe<MembershipCondition>
  filter?: InputMaybe<MembershipFilter>
  first?: InputMaybe<Scalars['Int']>
  last?: InputMaybe<Scalars['Int']>
  offset?: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<MembershipsOrderBy>>
}

/**
 * A condition to be used against `HotelRoom` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export interface HotelRoomCondition {
  /** Checks for equality with the object’s `bathroomType` field. */
  bathroomType?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `gamingRoom` field. */
  gamingRoom?: InputMaybe<Scalars['Boolean']>
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `occupancy` field. */
  occupancy?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `rate` field. */
  rate?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<Scalars['String']>
}

export interface HotelRoomDetail extends Node {
  __typename: 'HotelRoomDetail'
  bathroomType: Scalars['String']
  comment: Scalars['String']
  enabled: Scalars['Boolean']
  formattedRoomType: Scalars['String']
  gamingRoom: Scalars['Boolean']
  id: Scalars['BigInt']
  internalRoomType: Scalars['String']
  name: Scalars['String']
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']
  reserved: Scalars['Boolean']
  reservedFor: Scalars['String']
  roomType: Scalars['String']
  version: Scalars['BigInt']
}

/**
 * A condition to be used against `HotelRoomDetail` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export interface HotelRoomDetailCondition {
  /** Checks for equality with the object’s `bathroomType` field. */
  bathroomType?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `comment` field. */
  comment?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `enabled` field. */
  enabled?: InputMaybe<Scalars['Boolean']>
  /** Checks for equality with the object’s `formattedRoomType` field. */
  formattedRoomType?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `gamingRoom` field. */
  gamingRoom?: InputMaybe<Scalars['Boolean']>
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>
  /** Checks for equality with the object’s `internalRoomType` field. */
  internalRoomType?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `reserved` field. */
  reserved?: InputMaybe<Scalars['Boolean']>
  /** Checks for equality with the object’s `reservedFor` field. */
  reservedFor?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `roomType` field. */
  roomType?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `version` field. */
  version?: InputMaybe<Scalars['BigInt']>
}

/** A filter to be used against `HotelRoomDetail` object types. All fields are combined with a logical ‘and.’ */
export interface HotelRoomDetailFilter {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<HotelRoomDetailFilter>>
  /** Filter by the object’s `bathroomType` field. */
  bathroomType?: InputMaybe<StringFilter>
  /** Filter by the object’s `comment` field. */
  comment?: InputMaybe<StringFilter>
  /** Filter by the object’s `enabled` field. */
  enabled?: InputMaybe<BooleanFilter>
  /** Filter by the object’s `formattedRoomType` field. */
  formattedRoomType?: InputMaybe<StringFilter>
  /** Filter by the object’s `gamingRoom` field. */
  gamingRoom?: InputMaybe<BooleanFilter>
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>
  /** Filter by the object’s `internalRoomType` field. */
  internalRoomType?: InputMaybe<StringFilter>
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>
  /** Negates the expression. */
  not?: InputMaybe<HotelRoomDetailFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<HotelRoomDetailFilter>>
  /** Filter by the object’s `reserved` field. */
  reserved?: InputMaybe<BooleanFilter>
  /** Filter by the object’s `reservedFor` field. */
  reservedFor?: InputMaybe<StringFilter>
  /** Filter by the object’s `roomType` field. */
  roomType?: InputMaybe<StringFilter>
  /** Filter by the object’s `version` field. */
  version?: InputMaybe<BigIntFilter>
}

/** An input for mutations affecting `HotelRoomDetail` */
export interface HotelRoomDetailInput {
  bathroomType: Scalars['String']
  comment: Scalars['String']
  enabled: Scalars['Boolean']
  formattedRoomType: Scalars['String']
  gamingRoom: Scalars['Boolean']
  id?: InputMaybe<Scalars['BigInt']>
  internalRoomType: Scalars['String']
  name: Scalars['String']
  reserved: Scalars['Boolean']
  reservedFor: Scalars['String']
  roomType: Scalars['String']
  version: Scalars['BigInt']
}

/** Represents an update to a `HotelRoomDetail`. Fields that are set will be updated. */
export interface HotelRoomDetailPatch {
  bathroomType?: InputMaybe<Scalars['String']>
  comment?: InputMaybe<Scalars['String']>
  enabled?: InputMaybe<Scalars['Boolean']>
  formattedRoomType?: InputMaybe<Scalars['String']>
  gamingRoom?: InputMaybe<Scalars['Boolean']>
  id?: InputMaybe<Scalars['BigInt']>
  internalRoomType?: InputMaybe<Scalars['String']>
  name?: InputMaybe<Scalars['String']>
  reserved?: InputMaybe<Scalars['Boolean']>
  reservedFor?: InputMaybe<Scalars['String']>
  roomType?: InputMaybe<Scalars['String']>
  version?: InputMaybe<Scalars['BigInt']>
}

/** A connection to a list of `HotelRoomDetail` values. */
export interface HotelRoomDetailsConnection {
  __typename: 'HotelRoomDetailsConnection'
  /** A list of edges which contains the `HotelRoomDetail` and cursor to aid in pagination. */
  edges: Array<HotelRoomDetailsEdge>
  /** A list of `HotelRoomDetail` objects. */
  nodes: Array<Maybe<HotelRoomDetail>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `HotelRoomDetail` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `HotelRoomDetail` edge in the connection. */
export interface HotelRoomDetailsEdge {
  __typename: 'HotelRoomDetailsEdge'
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `HotelRoomDetail` at the end of the edge. */
  node?: Maybe<HotelRoomDetail>
}

/** Methods to use when ordering `HotelRoomDetail`. */
export enum HotelRoomDetailsOrderBy {
  BathroomTypeAsc = 'BATHROOM_TYPE_ASC',
  BathroomTypeDesc = 'BATHROOM_TYPE_DESC',
  CommentAsc = 'COMMENT_ASC',
  CommentDesc = 'COMMENT_DESC',
  EnabledAsc = 'ENABLED_ASC',
  EnabledDesc = 'ENABLED_DESC',
  FormattedRoomTypeAsc = 'FORMATTED_ROOM_TYPE_ASC',
  FormattedRoomTypeDesc = 'FORMATTED_ROOM_TYPE_DESC',
  GamingRoomAsc = 'GAMING_ROOM_ASC',
  GamingRoomDesc = 'GAMING_ROOM_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InternalRoomTypeAsc = 'INTERNAL_ROOM_TYPE_ASC',
  InternalRoomTypeDesc = 'INTERNAL_ROOM_TYPE_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ReservedAsc = 'RESERVED_ASC',
  ReservedDesc = 'RESERVED_DESC',
  ReservedForAsc = 'RESERVED_FOR_ASC',
  ReservedForDesc = 'RESERVED_FOR_DESC',
  RoomTypeAsc = 'ROOM_TYPE_ASC',
  RoomTypeDesc = 'ROOM_TYPE_DESC',
  VersionAsc = 'VERSION_ASC',
  VersionDesc = 'VERSION_DESC',
}

/** A filter to be used against `HotelRoom` object types. All fields are combined with a logical ‘and.’ */
export interface HotelRoomFilter {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<HotelRoomFilter>>
  /** Filter by the object’s `bathroomType` field. */
  bathroomType?: InputMaybe<StringFilter>
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>
  /** Filter by the object’s `gamingRoom` field. */
  gamingRoom?: InputMaybe<BooleanFilter>
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>
  /** Negates the expression. */
  not?: InputMaybe<HotelRoomFilter>
  /** Filter by the object’s `occupancy` field. */
  occupancy?: InputMaybe<StringFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<HotelRoomFilter>>
  /** Filter by the object’s `quantity` field. */
  quantity?: InputMaybe<IntFilter>
  /** Filter by the object’s `rate` field. */
  rate?: InputMaybe<StringFilter>
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<StringFilter>
}

/** An input for mutations affecting `HotelRoom` */
export interface HotelRoomInput {
  bathroomType: Scalars['String']
  description: Scalars['String']
  gamingRoom: Scalars['Boolean']
  id?: InputMaybe<Scalars['Int']>
  occupancy: Scalars['String']
  quantity: Scalars['Int']
  rate: Scalars['String']
  type: Scalars['String']
}

/** Represents an update to a `HotelRoom`. Fields that are set will be updated. */
export interface HotelRoomPatch {
  bathroomType?: InputMaybe<Scalars['String']>
  description?: InputMaybe<Scalars['String']>
  gamingRoom?: InputMaybe<Scalars['Boolean']>
  id?: InputMaybe<Scalars['Int']>
  occupancy?: InputMaybe<Scalars['String']>
  quantity?: InputMaybe<Scalars['Int']>
  rate?: InputMaybe<Scalars['String']>
  type?: InputMaybe<Scalars['String']>
}

/** A connection to a list of `HotelRoom` values. */
export interface HotelRoomsConnection {
  __typename: 'HotelRoomsConnection'
  /** A list of edges which contains the `HotelRoom` and cursor to aid in pagination. */
  edges: Array<HotelRoomsEdge>
  /** A list of `HotelRoom` objects. */
  nodes: Array<Maybe<HotelRoom>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `HotelRoom` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `HotelRoom` edge in the connection. */
export interface HotelRoomsEdge {
  __typename: 'HotelRoomsEdge'
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `HotelRoom` at the end of the edge. */
  node?: Maybe<HotelRoom>
}

/** Methods to use when ordering `HotelRoom`. */
export enum HotelRoomsOrderBy {
  BathroomTypeAsc = 'BATHROOM_TYPE_ASC',
  BathroomTypeDesc = 'BATHROOM_TYPE_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  GamingRoomAsc = 'GAMING_ROOM_ASC',
  GamingRoomDesc = 'GAMING_ROOM_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  MembershipsByHotelRoomIdCountAsc = 'MEMBERSHIPS_BY_HOTEL_ROOM_ID__COUNT_ASC',
  MembershipsByHotelRoomIdCountDesc = 'MEMBERSHIPS_BY_HOTEL_ROOM_ID__COUNT_DESC',
  Natural = 'NATURAL',
  OccupancyAsc = 'OCCUPANCY_ASC',
  OccupancyDesc = 'OCCUPANCY_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuantityAsc = 'QUANTITY_ASC',
  QuantityDesc = 'QUANTITY_DESC',
  RateAsc = 'RATE_ASC',
  RateDesc = 'RATE_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
}

/** A filter to be used against Int fields. All fields are combined with a logical ‘and.’ */
export interface IntFilter {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Int']>
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Int']>
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Int']>
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Int']>
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Int']>>
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']>
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Int']>
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Int']>
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Int']>
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Int']>
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Int']>>
}

export interface Lookup extends Node {
  __typename: 'Lookup'
  codeMaximum?: Maybe<Scalars['String']>
  codeMinimum?: Maybe<Scalars['String']>
  codeScale?: Maybe<Scalars['Int']>
  codeType: Scalars['String']
  id: Scalars['Int']
  internationalize: Scalars['Boolean']
  /** Reads and enables pagination through a set of `LookupValue`. */
  lookupValues: LookupValuesConnection
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']
  ordering: Scalars['String']
  realm: Scalars['String']
  valueMaximum?: Maybe<Scalars['String']>
  valueMinimum?: Maybe<Scalars['String']>
  valueScale?: Maybe<Scalars['Int']>
  valueType: Scalars['String']
}

export interface LookupLookupValuesArgs {
  after?: InputMaybe<Scalars['Cursor']>
  before?: InputMaybe<Scalars['Cursor']>
  condition?: InputMaybe<LookupValueCondition>
  filter?: InputMaybe<LookupValueFilter>
  first?: InputMaybe<Scalars['Int']>
  last?: InputMaybe<Scalars['Int']>
  offset?: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<LookupValuesOrderBy>>
}

/** A condition to be used against `Lookup` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export interface LookupCondition {
  /** Checks for equality with the object’s `codeMaximum` field. */
  codeMaximum?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `codeMinimum` field. */
  codeMinimum?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `codeScale` field. */
  codeScale?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `codeType` field. */
  codeType?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `internationalize` field. */
  internationalize?: InputMaybe<Scalars['Boolean']>
  /** Checks for equality with the object’s `ordering` field. */
  ordering?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `realm` field. */
  realm?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `valueMaximum` field. */
  valueMaximum?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `valueMinimum` field. */
  valueMinimum?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `valueScale` field. */
  valueScale?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `valueType` field. */
  valueType?: InputMaybe<Scalars['String']>
}

/** A filter to be used against `Lookup` object types. All fields are combined with a logical ‘and.’ */
export interface LookupFilter {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<LookupFilter>>
  /** Filter by the object’s `codeMaximum` field. */
  codeMaximum?: InputMaybe<StringFilter>
  /** Filter by the object’s `codeMinimum` field. */
  codeMinimum?: InputMaybe<StringFilter>
  /** Filter by the object’s `codeScale` field. */
  codeScale?: InputMaybe<IntFilter>
  /** Filter by the object’s `codeType` field. */
  codeType?: InputMaybe<StringFilter>
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>
  /** Filter by the object’s `internationalize` field. */
  internationalize?: InputMaybe<BooleanFilter>
  /** Negates the expression. */
  not?: InputMaybe<LookupFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<LookupFilter>>
  /** Filter by the object’s `ordering` field. */
  ordering?: InputMaybe<StringFilter>
  /** Filter by the object’s `realm` field. */
  realm?: InputMaybe<StringFilter>
  /** Filter by the object’s `valueMaximum` field. */
  valueMaximum?: InputMaybe<StringFilter>
  /** Filter by the object’s `valueMinimum` field. */
  valueMinimum?: InputMaybe<StringFilter>
  /** Filter by the object’s `valueScale` field. */
  valueScale?: InputMaybe<IntFilter>
  /** Filter by the object’s `valueType` field. */
  valueType?: InputMaybe<StringFilter>
}

/** An input for mutations affecting `Lookup` */
export interface LookupInput {
  codeMaximum?: InputMaybe<Scalars['String']>
  codeMinimum?: InputMaybe<Scalars['String']>
  codeScale?: InputMaybe<Scalars['Int']>
  codeType: Scalars['String']
  id?: InputMaybe<Scalars['Int']>
  internationalize: Scalars['Boolean']
  ordering: Scalars['String']
  realm: Scalars['String']
  valueMaximum?: InputMaybe<Scalars['String']>
  valueMinimum?: InputMaybe<Scalars['String']>
  valueScale?: InputMaybe<Scalars['Int']>
  valueType: Scalars['String']
}

/** Represents an update to a `Lookup`. Fields that are set will be updated. */
export interface LookupPatch {
  codeMaximum?: InputMaybe<Scalars['String']>
  codeMinimum?: InputMaybe<Scalars['String']>
  codeScale?: InputMaybe<Scalars['Int']>
  codeType?: InputMaybe<Scalars['String']>
  id?: InputMaybe<Scalars['Int']>
  internationalize?: InputMaybe<Scalars['Boolean']>
  ordering?: InputMaybe<Scalars['String']>
  realm?: InputMaybe<Scalars['String']>
  valueMaximum?: InputMaybe<Scalars['String']>
  valueMinimum?: InputMaybe<Scalars['String']>
  valueScale?: InputMaybe<Scalars['Int']>
  valueType?: InputMaybe<Scalars['String']>
}

export interface LookupValue extends Node {
  __typename: 'LookupValue'
  code: Scalars['String']
  id: Scalars['Int']
  /** Reads a single `Lookup` that is related to this `LookupValue`. */
  lookup?: Maybe<Lookup>
  lookupId: Scalars['Int']
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']
  numericSequencer: Scalars['BigFloat']
  sequencer: Scalars['Int']
  stringSequencer: Scalars['String']
  value: Scalars['String']
}

/**
 * A condition to be used against `LookupValue` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export interface LookupValueCondition {
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `lookupId` field. */
  lookupId?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `numericSequencer` field. */
  numericSequencer?: InputMaybe<Scalars['BigFloat']>
  /** Checks for equality with the object’s `sequencer` field. */
  sequencer?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `stringSequencer` field. */
  stringSequencer?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `value` field. */
  value?: InputMaybe<Scalars['String']>
}

/** A filter to be used against `LookupValue` object types. All fields are combined with a logical ‘and.’ */
export interface LookupValueFilter {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<LookupValueFilter>>
  /** Filter by the object’s `code` field. */
  code?: InputMaybe<StringFilter>
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>
  /** Filter by the object’s `lookupId` field. */
  lookupId?: InputMaybe<IntFilter>
  /** Negates the expression. */
  not?: InputMaybe<LookupValueFilter>
  /** Filter by the object’s `numericSequencer` field. */
  numericSequencer?: InputMaybe<BigFloatFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<LookupValueFilter>>
  /** Filter by the object’s `sequencer` field. */
  sequencer?: InputMaybe<IntFilter>
  /** Filter by the object’s `stringSequencer` field. */
  stringSequencer?: InputMaybe<StringFilter>
  /** Filter by the object’s `value` field. */
  value?: InputMaybe<StringFilter>
}

/** An input for mutations affecting `LookupValue` */
export interface LookupValueInput {
  code: Scalars['String']
  id?: InputMaybe<Scalars['Int']>
  lookupId: Scalars['Int']
  numericSequencer: Scalars['BigFloat']
  sequencer: Scalars['Int']
  stringSequencer: Scalars['String']
  value: Scalars['String']
}

/** Represents an update to a `LookupValue`. Fields that are set will be updated. */
export interface LookupValuePatch {
  code?: InputMaybe<Scalars['String']>
  id?: InputMaybe<Scalars['Int']>
  lookupId?: InputMaybe<Scalars['Int']>
  numericSequencer?: InputMaybe<Scalars['BigFloat']>
  sequencer?: InputMaybe<Scalars['Int']>
  stringSequencer?: InputMaybe<Scalars['String']>
  value?: InputMaybe<Scalars['String']>
}

/** A connection to a list of `LookupValue` values. */
export interface LookupValuesConnection {
  __typename: 'LookupValuesConnection'
  /** A list of edges which contains the `LookupValue` and cursor to aid in pagination. */
  edges: Array<LookupValuesEdge>
  /** A list of `LookupValue` objects. */
  nodes: Array<Maybe<LookupValue>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `LookupValue` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `LookupValue` edge in the connection. */
export interface LookupValuesEdge {
  __typename: 'LookupValuesEdge'
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `LookupValue` at the end of the edge. */
  node?: Maybe<LookupValue>
}

/** Methods to use when ordering `LookupValue`. */
export enum LookupValuesOrderBy {
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LookupByLookupIdCodeMaximumAsc = 'LOOKUP_BY_LOOKUP_ID__CODE_MAXIMUM_ASC',
  LookupByLookupIdCodeMaximumDesc = 'LOOKUP_BY_LOOKUP_ID__CODE_MAXIMUM_DESC',
  LookupByLookupIdCodeMinimumAsc = 'LOOKUP_BY_LOOKUP_ID__CODE_MINIMUM_ASC',
  LookupByLookupIdCodeMinimumDesc = 'LOOKUP_BY_LOOKUP_ID__CODE_MINIMUM_DESC',
  LookupByLookupIdCodeScaleAsc = 'LOOKUP_BY_LOOKUP_ID__CODE_SCALE_ASC',
  LookupByLookupIdCodeScaleDesc = 'LOOKUP_BY_LOOKUP_ID__CODE_SCALE_DESC',
  LookupByLookupIdCodeTypeAsc = 'LOOKUP_BY_LOOKUP_ID__CODE_TYPE_ASC',
  LookupByLookupIdCodeTypeDesc = 'LOOKUP_BY_LOOKUP_ID__CODE_TYPE_DESC',
  LookupByLookupIdIdAsc = 'LOOKUP_BY_LOOKUP_ID__ID_ASC',
  LookupByLookupIdIdDesc = 'LOOKUP_BY_LOOKUP_ID__ID_DESC',
  LookupByLookupIdInternationalizeAsc = 'LOOKUP_BY_LOOKUP_ID__INTERNATIONALIZE_ASC',
  LookupByLookupIdInternationalizeDesc = 'LOOKUP_BY_LOOKUP_ID__INTERNATIONALIZE_DESC',
  LookupByLookupIdOrderingAsc = 'LOOKUP_BY_LOOKUP_ID__ORDERING_ASC',
  LookupByLookupIdOrderingDesc = 'LOOKUP_BY_LOOKUP_ID__ORDERING_DESC',
  LookupByLookupIdRealmAsc = 'LOOKUP_BY_LOOKUP_ID__REALM_ASC',
  LookupByLookupIdRealmDesc = 'LOOKUP_BY_LOOKUP_ID__REALM_DESC',
  LookupByLookupIdValueMaximumAsc = 'LOOKUP_BY_LOOKUP_ID__VALUE_MAXIMUM_ASC',
  LookupByLookupIdValueMaximumDesc = 'LOOKUP_BY_LOOKUP_ID__VALUE_MAXIMUM_DESC',
  LookupByLookupIdValueMinimumAsc = 'LOOKUP_BY_LOOKUP_ID__VALUE_MINIMUM_ASC',
  LookupByLookupIdValueMinimumDesc = 'LOOKUP_BY_LOOKUP_ID__VALUE_MINIMUM_DESC',
  LookupByLookupIdValueScaleAsc = 'LOOKUP_BY_LOOKUP_ID__VALUE_SCALE_ASC',
  LookupByLookupIdValueScaleDesc = 'LOOKUP_BY_LOOKUP_ID__VALUE_SCALE_DESC',
  LookupByLookupIdValueTypeAsc = 'LOOKUP_BY_LOOKUP_ID__VALUE_TYPE_ASC',
  LookupByLookupIdValueTypeDesc = 'LOOKUP_BY_LOOKUP_ID__VALUE_TYPE_DESC',
  LookupIdAsc = 'LOOKUP_ID_ASC',
  LookupIdDesc = 'LOOKUP_ID_DESC',
  Natural = 'NATURAL',
  NumericSequencerAsc = 'NUMERIC_SEQUENCER_ASC',
  NumericSequencerDesc = 'NUMERIC_SEQUENCER_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SequencerAsc = 'SEQUENCER_ASC',
  SequencerDesc = 'SEQUENCER_DESC',
  StringSequencerAsc = 'STRING_SEQUENCER_ASC',
  StringSequencerDesc = 'STRING_SEQUENCER_DESC',
  ValueAsc = 'VALUE_ASC',
  ValueDesc = 'VALUE_DESC',
}

/** A connection to a list of `Lookup` values. */
export interface LookupsConnection {
  __typename: 'LookupsConnection'
  /** A list of edges which contains the `Lookup` and cursor to aid in pagination. */
  edges: Array<LookupsEdge>
  /** A list of `Lookup` objects. */
  nodes: Array<Maybe<Lookup>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Lookup` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Lookup` edge in the connection. */
export interface LookupsEdge {
  __typename: 'LookupsEdge'
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Lookup` at the end of the edge. */
  node?: Maybe<Lookup>
}

/** Methods to use when ordering `Lookup`. */
export enum LookupsOrderBy {
  CodeMaximumAsc = 'CODE_MAXIMUM_ASC',
  CodeMaximumDesc = 'CODE_MAXIMUM_DESC',
  CodeMinimumAsc = 'CODE_MINIMUM_ASC',
  CodeMinimumDesc = 'CODE_MINIMUM_DESC',
  CodeScaleAsc = 'CODE_SCALE_ASC',
  CodeScaleDesc = 'CODE_SCALE_DESC',
  CodeTypeAsc = 'CODE_TYPE_ASC',
  CodeTypeDesc = 'CODE_TYPE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InternationalizeAsc = 'INTERNATIONALIZE_ASC',
  InternationalizeDesc = 'INTERNATIONALIZE_DESC',
  LookupValuesByLookupIdCountAsc = 'LOOKUP_VALUES_BY_LOOKUP_ID__COUNT_ASC',
  LookupValuesByLookupIdCountDesc = 'LOOKUP_VALUES_BY_LOOKUP_ID__COUNT_DESC',
  Natural = 'NATURAL',
  OrderingAsc = 'ORDERING_ASC',
  OrderingDesc = 'ORDERING_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RealmAsc = 'REALM_ASC',
  RealmDesc = 'REALM_DESC',
  ValueMaximumAsc = 'VALUE_MAXIMUM_ASC',
  ValueMaximumDesc = 'VALUE_MAXIMUM_DESC',
  ValueMinimumAsc = 'VALUE_MINIMUM_ASC',
  ValueMinimumDesc = 'VALUE_MINIMUM_DESC',
  ValueScaleAsc = 'VALUE_SCALE_ASC',
  ValueScaleDesc = 'VALUE_SCALE_DESC',
  ValueTypeAsc = 'VALUE_TYPE_ASC',
  ValueTypeDesc = 'VALUE_TYPE_DESC',
}

export interface Membership extends Node {
  __typename: 'Membership'
  amountOwed: Scalars['Float']
  amountPaid: Scalars['Float']
  arrivalDate: Scalars['Datetime']
  attendance: Scalars['String']
  attending: Scalars['Boolean']
  departureDate: Scalars['Datetime']
  /** Reads and enables pagination through a set of `GameAssignment`. */
  gameAssignmentsByMemberId: GameAssignmentsConnection
  /** Reads and enables pagination through a set of `GameChoice`. */
  gameChoicesByMemberId: GameChoicesConnection
  /** Reads and enables pagination through a set of `GameSubmission`. */
  gameSubmissionsByMemberId: GameSubmissionsConnection
  /** Reads a single `HotelRoom` that is related to this `Membership`. */
  hotelRoom?: Maybe<HotelRoom>
  hotelRoomId: Scalars['Int']
  id: Scalars['Int']
  interestLevel: Scalars['String']
  message: Scalars['String']
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']
  offerSubsidy: Scalars['Boolean']
  requestOldPrice: Scalars['Boolean']
  roomPreferenceAndNotes: Scalars['String']
  roomingPreferences: Scalars['String']
  roomingWith: Scalars['String']
  slotsAttending?: Maybe<Scalars['String']>
  /** Reads a single `User` that is related to this `Membership`. */
  user?: Maybe<User>
  userId: Scalars['Int']
  volunteer: Scalars['Boolean']
  year: Scalars['Int']
}

export interface MembershipGameAssignmentsByMemberIdArgs {
  after?: InputMaybe<Scalars['Cursor']>
  before?: InputMaybe<Scalars['Cursor']>
  condition?: InputMaybe<GameAssignmentCondition>
  filter?: InputMaybe<GameAssignmentFilter>
  first?: InputMaybe<Scalars['Int']>
  last?: InputMaybe<Scalars['Int']>
  offset?: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<GameAssignmentsOrderBy>>
}

export interface MembershipGameChoicesByMemberIdArgs {
  after?: InputMaybe<Scalars['Cursor']>
  before?: InputMaybe<Scalars['Cursor']>
  condition?: InputMaybe<GameChoiceCondition>
  filter?: InputMaybe<GameChoiceFilter>
  first?: InputMaybe<Scalars['Int']>
  last?: InputMaybe<Scalars['Int']>
  offset?: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<GameChoicesOrderBy>>
}

export interface MembershipGameSubmissionsByMemberIdArgs {
  after?: InputMaybe<Scalars['Cursor']>
  before?: InputMaybe<Scalars['Cursor']>
  condition?: InputMaybe<GameSubmissionCondition>
  filter?: InputMaybe<GameSubmissionFilter>
  first?: InputMaybe<Scalars['Int']>
  last?: InputMaybe<Scalars['Int']>
  offset?: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<GameSubmissionsOrderBy>>
}

/**
 * A condition to be used against `Membership` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export interface MembershipCondition {
  /** Checks for equality with the object’s `amountOwed` field. */
  amountOwed?: InputMaybe<Scalars['Float']>
  /** Checks for equality with the object’s `amountPaid` field. */
  amountPaid?: InputMaybe<Scalars['Float']>
  /** Checks for equality with the object’s `arrivalDate` field. */
  arrivalDate?: InputMaybe<Scalars['Datetime']>
  /** Checks for equality with the object’s `attendance` field. */
  attendance?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `attending` field. */
  attending?: InputMaybe<Scalars['Boolean']>
  /** Checks for equality with the object’s `departureDate` field. */
  departureDate?: InputMaybe<Scalars['Datetime']>
  /** Checks for equality with the object’s `hotelRoomId` field. */
  hotelRoomId?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `interestLevel` field. */
  interestLevel?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `message` field. */
  message?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `offerSubsidy` field. */
  offerSubsidy?: InputMaybe<Scalars['Boolean']>
  /** Checks for equality with the object’s `requestOldPrice` field. */
  requestOldPrice?: InputMaybe<Scalars['Boolean']>
  /** Checks for equality with the object’s `roomPreferenceAndNotes` field. */
  roomPreferenceAndNotes?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `roomingPreferences` field. */
  roomingPreferences?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `roomingWith` field. */
  roomingWith?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `slotsAttending` field. */
  slotsAttending?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `volunteer` field. */
  volunteer?: InputMaybe<Scalars['Boolean']>
  /** Checks for equality with the object’s `year` field. */
  year?: InputMaybe<Scalars['Int']>
}

/** A filter to be used against `Membership` object types. All fields are combined with a logical ‘and.’ */
export interface MembershipFilter {
  /** Filter by the object’s `amountOwed` field. */
  amountOwed?: InputMaybe<FloatFilter>
  /** Filter by the object’s `amountPaid` field. */
  amountPaid?: InputMaybe<FloatFilter>
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MembershipFilter>>
  /** Filter by the object’s `arrivalDate` field. */
  arrivalDate?: InputMaybe<DatetimeFilter>
  /** Filter by the object’s `attendance` field. */
  attendance?: InputMaybe<StringFilter>
  /** Filter by the object’s `attending` field. */
  attending?: InputMaybe<BooleanFilter>
  /** Filter by the object’s `departureDate` field. */
  departureDate?: InputMaybe<DatetimeFilter>
  /** Filter by the object’s `hotelRoomId` field. */
  hotelRoomId?: InputMaybe<IntFilter>
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>
  /** Filter by the object’s `interestLevel` field. */
  interestLevel?: InputMaybe<StringFilter>
  /** Filter by the object’s `message` field. */
  message?: InputMaybe<StringFilter>
  /** Negates the expression. */
  not?: InputMaybe<MembershipFilter>
  /** Filter by the object’s `offerSubsidy` field. */
  offerSubsidy?: InputMaybe<BooleanFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MembershipFilter>>
  /** Filter by the object’s `requestOldPrice` field. */
  requestOldPrice?: InputMaybe<BooleanFilter>
  /** Filter by the object’s `roomPreferenceAndNotes` field. */
  roomPreferenceAndNotes?: InputMaybe<StringFilter>
  /** Filter by the object’s `roomingPreferences` field. */
  roomingPreferences?: InputMaybe<StringFilter>
  /** Filter by the object’s `roomingWith` field. */
  roomingWith?: InputMaybe<StringFilter>
  /** Filter by the object’s `slotsAttending` field. */
  slotsAttending?: InputMaybe<StringFilter>
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>
  /** Filter by the object’s `volunteer` field. */
  volunteer?: InputMaybe<BooleanFilter>
  /** Filter by the object’s `year` field. */
  year?: InputMaybe<IntFilter>
}

/** An input for mutations affecting `Membership` */
export interface MembershipInput {
  amountOwed: Scalars['Float']
  amountPaid: Scalars['Float']
  arrivalDate: Scalars['Datetime']
  attendance: Scalars['String']
  attending: Scalars['Boolean']
  departureDate: Scalars['Datetime']
  hotelRoomId: Scalars['Int']
  id?: InputMaybe<Scalars['Int']>
  interestLevel: Scalars['String']
  message: Scalars['String']
  offerSubsidy: Scalars['Boolean']
  requestOldPrice: Scalars['Boolean']
  roomPreferenceAndNotes: Scalars['String']
  roomingPreferences: Scalars['String']
  roomingWith: Scalars['String']
  slotsAttending?: InputMaybe<Scalars['String']>
  userId: Scalars['Int']
  volunteer: Scalars['Boolean']
  year: Scalars['Int']
}

/** Represents an update to a `Membership`. Fields that are set will be updated. */
export interface MembershipPatch {
  amountOwed?: InputMaybe<Scalars['Float']>
  amountPaid?: InputMaybe<Scalars['Float']>
  arrivalDate?: InputMaybe<Scalars['Datetime']>
  attendance?: InputMaybe<Scalars['String']>
  attending?: InputMaybe<Scalars['Boolean']>
  departureDate?: InputMaybe<Scalars['Datetime']>
  hotelRoomId?: InputMaybe<Scalars['Int']>
  id?: InputMaybe<Scalars['Int']>
  interestLevel?: InputMaybe<Scalars['String']>
  message?: InputMaybe<Scalars['String']>
  offerSubsidy?: InputMaybe<Scalars['Boolean']>
  requestOldPrice?: InputMaybe<Scalars['Boolean']>
  roomPreferenceAndNotes?: InputMaybe<Scalars['String']>
  roomingPreferences?: InputMaybe<Scalars['String']>
  roomingWith?: InputMaybe<Scalars['String']>
  slotsAttending?: InputMaybe<Scalars['String']>
  userId?: InputMaybe<Scalars['Int']>
  volunteer?: InputMaybe<Scalars['Boolean']>
  year?: InputMaybe<Scalars['Int']>
}

/** A connection to a list of `Membership` values. */
export interface MembershipsConnection {
  __typename: 'MembershipsConnection'
  /** A list of edges which contains the `Membership` and cursor to aid in pagination. */
  edges: Array<MembershipsEdge>
  /** A list of `Membership` objects. */
  nodes: Array<Maybe<Membership>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Membership` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Membership` edge in the connection. */
export interface MembershipsEdge {
  __typename: 'MembershipsEdge'
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Membership` at the end of the edge. */
  node?: Maybe<Membership>
}

/** Methods to use when ordering `Membership`. */
export enum MembershipsOrderBy {
  AmountOwedAsc = 'AMOUNT_OWED_ASC',
  AmountOwedDesc = 'AMOUNT_OWED_DESC',
  AmountPaidAsc = 'AMOUNT_PAID_ASC',
  AmountPaidDesc = 'AMOUNT_PAID_DESC',
  ArrivalDateAsc = 'ARRIVAL_DATE_ASC',
  ArrivalDateDesc = 'ARRIVAL_DATE_DESC',
  AttendanceAsc = 'ATTENDANCE_ASC',
  AttendanceDesc = 'ATTENDANCE_DESC',
  AttendingAsc = 'ATTENDING_ASC',
  AttendingDesc = 'ATTENDING_DESC',
  DepartureDateAsc = 'DEPARTURE_DATE_ASC',
  DepartureDateDesc = 'DEPARTURE_DATE_DESC',
  GameAssignmentsByMemberIdCountAsc = 'GAME_ASSIGNMENTS_BY_MEMBER_ID__COUNT_ASC',
  GameAssignmentsByMemberIdCountDesc = 'GAME_ASSIGNMENTS_BY_MEMBER_ID__COUNT_DESC',
  GameChoicesByMemberIdCountAsc = 'GAME_CHOICES_BY_MEMBER_ID__COUNT_ASC',
  GameChoicesByMemberIdCountDesc = 'GAME_CHOICES_BY_MEMBER_ID__COUNT_DESC',
  GameSubmissionsByMemberIdCountAsc = 'GAME_SUBMISSIONS_BY_MEMBER_ID__COUNT_ASC',
  GameSubmissionsByMemberIdCountDesc = 'GAME_SUBMISSIONS_BY_MEMBER_ID__COUNT_DESC',
  HotelRoomByHotelRoomIdBathroomTypeAsc = 'HOTEL_ROOM_BY_HOTEL_ROOM_ID__BATHROOM_TYPE_ASC',
  HotelRoomByHotelRoomIdBathroomTypeDesc = 'HOTEL_ROOM_BY_HOTEL_ROOM_ID__BATHROOM_TYPE_DESC',
  HotelRoomByHotelRoomIdDescriptionAsc = 'HOTEL_ROOM_BY_HOTEL_ROOM_ID__DESCRIPTION_ASC',
  HotelRoomByHotelRoomIdDescriptionDesc = 'HOTEL_ROOM_BY_HOTEL_ROOM_ID__DESCRIPTION_DESC',
  HotelRoomByHotelRoomIdGamingRoomAsc = 'HOTEL_ROOM_BY_HOTEL_ROOM_ID__GAMING_ROOM_ASC',
  HotelRoomByHotelRoomIdGamingRoomDesc = 'HOTEL_ROOM_BY_HOTEL_ROOM_ID__GAMING_ROOM_DESC',
  HotelRoomByHotelRoomIdIdAsc = 'HOTEL_ROOM_BY_HOTEL_ROOM_ID__ID_ASC',
  HotelRoomByHotelRoomIdIdDesc = 'HOTEL_ROOM_BY_HOTEL_ROOM_ID__ID_DESC',
  HotelRoomByHotelRoomIdOccupancyAsc = 'HOTEL_ROOM_BY_HOTEL_ROOM_ID__OCCUPANCY_ASC',
  HotelRoomByHotelRoomIdOccupancyDesc = 'HOTEL_ROOM_BY_HOTEL_ROOM_ID__OCCUPANCY_DESC',
  HotelRoomByHotelRoomIdQuantityAsc = 'HOTEL_ROOM_BY_HOTEL_ROOM_ID__QUANTITY_ASC',
  HotelRoomByHotelRoomIdQuantityDesc = 'HOTEL_ROOM_BY_HOTEL_ROOM_ID__QUANTITY_DESC',
  HotelRoomByHotelRoomIdRateAsc = 'HOTEL_ROOM_BY_HOTEL_ROOM_ID__RATE_ASC',
  HotelRoomByHotelRoomIdRateDesc = 'HOTEL_ROOM_BY_HOTEL_ROOM_ID__RATE_DESC',
  HotelRoomByHotelRoomIdTypeAsc = 'HOTEL_ROOM_BY_HOTEL_ROOM_ID__TYPE_ASC',
  HotelRoomByHotelRoomIdTypeDesc = 'HOTEL_ROOM_BY_HOTEL_ROOM_ID__TYPE_DESC',
  HotelRoomIdAsc = 'HOTEL_ROOM_ID_ASC',
  HotelRoomIdDesc = 'HOTEL_ROOM_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InterestLevelAsc = 'INTEREST_LEVEL_ASC',
  InterestLevelDesc = 'INTEREST_LEVEL_DESC',
  MessageAsc = 'MESSAGE_ASC',
  MessageDesc = 'MESSAGE_DESC',
  Natural = 'NATURAL',
  OfferSubsidyAsc = 'OFFER_SUBSIDY_ASC',
  OfferSubsidyDesc = 'OFFER_SUBSIDY_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RequestOldPriceAsc = 'REQUEST_OLD_PRICE_ASC',
  RequestOldPriceDesc = 'REQUEST_OLD_PRICE_DESC',
  RoomingPreferencesAsc = 'ROOMING_PREFERENCES_ASC',
  RoomingPreferencesDesc = 'ROOMING_PREFERENCES_DESC',
  RoomingWithAsc = 'ROOMING_WITH_ASC',
  RoomingWithDesc = 'ROOMING_WITH_DESC',
  RoomPreferenceAndNotesAsc = 'ROOM_PREFERENCE_AND_NOTES_ASC',
  RoomPreferenceAndNotesDesc = 'ROOM_PREFERENCE_AND_NOTES_DESC',
  SlotsAttendingAsc = 'SLOTS_ATTENDING_ASC',
  SlotsAttendingDesc = 'SLOTS_ATTENDING_DESC',
  UserByUserIdEmailAsc = 'USER_BY_USER_ID__EMAIL_ASC',
  UserByUserIdEmailDesc = 'USER_BY_USER_ID__EMAIL_DESC',
  UserByUserIdFirstNameAsc = 'USER_BY_USER_ID__FIRST_NAME_ASC',
  UserByUserIdFirstNameDesc = 'USER_BY_USER_ID__FIRST_NAME_DESC',
  UserByUserIdFullNameAsc = 'USER_BY_USER_ID__FULL_NAME_ASC',
  UserByUserIdFullNameDesc = 'USER_BY_USER_ID__FULL_NAME_DESC',
  UserByUserIdIdAsc = 'USER_BY_USER_ID__ID_ASC',
  UserByUserIdIdDesc = 'USER_BY_USER_ID__ID_DESC',
  UserByUserIdLastNameAsc = 'USER_BY_USER_ID__LAST_NAME_ASC',
  UserByUserIdLastNameDesc = 'USER_BY_USER_ID__LAST_NAME_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  VolunteerAsc = 'VOLUNTEER_ASC',
  VolunteerDesc = 'VOLUNTEER_DESC',
  YearAsc = 'YEAR_ASC',
  YearDesc = 'YEAR_DESC',
}

/** The root mutation type which contains root level fields which mutate data. */
export interface Mutation {
  __typename: 'Mutation'
  createBareSlotChoices?: Maybe<CreateBareSlotChoicesPayload>
  /** Creates a single `Game`. */
  createGame?: Maybe<CreateGamePayload>
  /** Creates a single `GameAssignment`. */
  createGameAssignment?: Maybe<CreateGameAssignmentPayload>
  /** Creates a single `GameChoice`. */
  createGameChoice?: Maybe<CreateGameChoicePayload>
  /** Creates a single `GameSubmission`. */
  createGameSubmission?: Maybe<CreateGameSubmissionPayload>
  /** Creates a single `HotelRoom`. */
  createHotelRoom?: Maybe<CreateHotelRoomPayload>
  /** Creates a single `HotelRoomDetail`. */
  createHotelRoomDetail?: Maybe<CreateHotelRoomDetailPayload>
  /** Creates a single `Lookup`. */
  createLookup?: Maybe<CreateLookupPayload>
  /** Creates a single `LookupValue`. */
  createLookupValue?: Maybe<CreateLookupValuePayload>
  /** Creates a single `Membership`. */
  createMembership?: Maybe<CreateMembershipPayload>
  /** Creates a single `Profile`. */
  createProfile?: Maybe<CreateProfilePayload>
  /** Creates a single `Role`. */
  createRole?: Maybe<CreateRolePayload>
  /** Creates a single `Room`. */
  createRoom?: Maybe<CreateRoomPayload>
  /** Creates a single `Setting`. */
  createSetting?: Maybe<CreateSettingPayload>
  /** Creates a single `ShirtOrder`. */
  createShirtOrder?: Maybe<CreateShirtOrderPayload>
  /** Creates a single `ShirtOrderItem`. */
  createShirtOrderItem?: Maybe<CreateShirtOrderItemPayload>
  /** Creates a single `Slot`. */
  createSlot?: Maybe<CreateSlotPayload>
  /** Creates a single `User`. */
  createUser?: Maybe<CreateUserPayload>
  /** Creates a single `UserRole`. */
  createUserRole?: Maybe<CreateUserRolePayload>
  /** Deletes a single `Game` using a unique key. */
  deleteGame?: Maybe<DeleteGamePayload>
  /** Deletes a single `GameAssignment` using a unique key. */
  deleteGameAssignment?: Maybe<DeleteGameAssignmentPayload>
  /** Deletes a single `GameAssignment` using its globally unique id. */
  deleteGameAssignmentByNodeId?: Maybe<DeleteGameAssignmentPayload>
  /** Deletes a single `Game` using its globally unique id. */
  deleteGameByNodeId?: Maybe<DeleteGamePayload>
  /** Deletes a single `GameChoice` using a unique key. */
  deleteGameChoice?: Maybe<DeleteGameChoicePayload>
  /** Deletes a single `GameChoice` using its globally unique id. */
  deleteGameChoiceByNodeId?: Maybe<DeleteGameChoicePayload>
  /** Deletes a single `GameSubmission` using a unique key. */
  deleteGameSubmission?: Maybe<DeleteGameSubmissionPayload>
  /** Deletes a single `GameSubmission` using its globally unique id. */
  deleteGameSubmissionByNodeId?: Maybe<DeleteGameSubmissionPayload>
  /** Deletes a single `HotelRoom` using a unique key. */
  deleteHotelRoom?: Maybe<DeleteHotelRoomPayload>
  /** Deletes a single `HotelRoom` using its globally unique id. */
  deleteHotelRoomByNodeId?: Maybe<DeleteHotelRoomPayload>
  /** Deletes a single `HotelRoomDetail` using a unique key. */
  deleteHotelRoomDetail?: Maybe<DeleteHotelRoomDetailPayload>
  /** Deletes a single `HotelRoomDetail` using its globally unique id. */
  deleteHotelRoomDetailByNodeId?: Maybe<DeleteHotelRoomDetailPayload>
  /** Deletes a single `Lookup` using a unique key. */
  deleteLookup?: Maybe<DeleteLookupPayload>
  /** Deletes a single `Lookup` using its globally unique id. */
  deleteLookupByNodeId?: Maybe<DeleteLookupPayload>
  /** Deletes a single `Lookup` using a unique key. */
  deleteLookupByRealm?: Maybe<DeleteLookupPayload>
  /** Deletes a single `LookupValue` using a unique key. */
  deleteLookupValue?: Maybe<DeleteLookupValuePayload>
  /** Deletes a single `LookupValue` using a unique key. */
  deleteLookupValueByLookupIdAndCode?: Maybe<DeleteLookupValuePayload>
  /** Deletes a single `LookupValue` using its globally unique id. */
  deleteLookupValueByNodeId?: Maybe<DeleteLookupValuePayload>
  /** Deletes a single `Membership` using a unique key. */
  deleteMembership?: Maybe<DeleteMembershipPayload>
  /** Deletes a single `Membership` using its globally unique id. */
  deleteMembershipByNodeId?: Maybe<DeleteMembershipPayload>
  /** Deletes a single `Profile` using a unique key. */
  deleteProfile?: Maybe<DeleteProfilePayload>
  /** Deletes a single `Profile` using its globally unique id. */
  deleteProfileByNodeId?: Maybe<DeleteProfilePayload>
  /** Deletes a single `Role` using a unique key. */
  deleteRole?: Maybe<DeleteRolePayload>
  /** Deletes a single `Role` using a unique key. */
  deleteRoleByAuthority?: Maybe<DeleteRolePayload>
  /** Deletes a single `Role` using its globally unique id. */
  deleteRoleByNodeId?: Maybe<DeleteRolePayload>
  /** Deletes a single `Room` using a unique key. */
  deleteRoom?: Maybe<DeleteRoomPayload>
  /** Deletes a single `Room` using its globally unique id. */
  deleteRoomByNodeId?: Maybe<DeleteRoomPayload>
  /** Deletes a single `Setting` using a unique key. */
  deleteSetting?: Maybe<DeleteSettingPayload>
  /** Deletes a single `Setting` using its globally unique id. */
  deleteSettingByNodeId?: Maybe<DeleteSettingPayload>
  /** Deletes a single `ShirtOrder` using a unique key. */
  deleteShirtOrder?: Maybe<DeleteShirtOrderPayload>
  /** Deletes a single `ShirtOrder` using its globally unique id. */
  deleteShirtOrderByNodeId?: Maybe<DeleteShirtOrderPayload>
  /** Deletes a single `ShirtOrderItem` using a unique key. */
  deleteShirtOrderItem?: Maybe<DeleteShirtOrderItemPayload>
  /** Deletes a single `ShirtOrderItem` using its globally unique id. */
  deleteShirtOrderItemByNodeId?: Maybe<DeleteShirtOrderItemPayload>
  /** Deletes a single `Slot` using a unique key. */
  deleteSlot?: Maybe<DeleteSlotPayload>
  /** Deletes a single `Slot` using its globally unique id. */
  deleteSlotByNodeId?: Maybe<DeleteSlotPayload>
  /** Deletes a single `User` using a unique key. */
  deleteUser?: Maybe<DeleteUserPayload>
  /** Deletes a single `User` using a unique key. */
  deleteUserByEmail?: Maybe<DeleteUserPayload>
  /** Deletes a single `User` using its globally unique id. */
  deleteUserByNodeId?: Maybe<DeleteUserPayload>
  /** Deletes a single `UserRole` using a unique key. */
  deleteUserRole?: Maybe<DeleteUserRolePayload>
  /** Deletes a single `UserRole` using its globally unique id. */
  deleteUserRoleByNodeId?: Maybe<DeleteUserRolePayload>
  fTruncateTables?: Maybe<FTruncateTablesPayload>
  slotGmGame?: Maybe<SlotGmGamePayload>
  /** Updates a single `Game` using a unique key and a patch. */
  updateGame?: Maybe<UpdateGamePayload>
  /** Updates a single `GameAssignment` using a unique key and a patch. */
  updateGameAssignment?: Maybe<UpdateGameAssignmentPayload>
  /** Updates a single `GameAssignment` using its globally unique id and a patch. */
  updateGameAssignmentByNodeId?: Maybe<UpdateGameAssignmentPayload>
  /** Updates a single `Game` using its globally unique id and a patch. */
  updateGameByNodeId?: Maybe<UpdateGamePayload>
  /** Updates a single `GameChoice` using a unique key and a patch. */
  updateGameChoice?: Maybe<UpdateGameChoicePayload>
  /** Updates a single `GameChoice` using its globally unique id and a patch. */
  updateGameChoiceByNodeId?: Maybe<UpdateGameChoicePayload>
  /** Updates a single `GameSubmission` using a unique key and a patch. */
  updateGameSubmission?: Maybe<UpdateGameSubmissionPayload>
  /** Updates a single `GameSubmission` using its globally unique id and a patch. */
  updateGameSubmissionByNodeId?: Maybe<UpdateGameSubmissionPayload>
  /** Updates a single `HotelRoom` using a unique key and a patch. */
  updateHotelRoom?: Maybe<UpdateHotelRoomPayload>
  /** Updates a single `HotelRoom` using its globally unique id and a patch. */
  updateHotelRoomByNodeId?: Maybe<UpdateHotelRoomPayload>
  /** Updates a single `HotelRoomDetail` using a unique key and a patch. */
  updateHotelRoomDetail?: Maybe<UpdateHotelRoomDetailPayload>
  /** Updates a single `HotelRoomDetail` using its globally unique id and a patch. */
  updateHotelRoomDetailByNodeId?: Maybe<UpdateHotelRoomDetailPayload>
  /** Updates a single `Lookup` using a unique key and a patch. */
  updateLookup?: Maybe<UpdateLookupPayload>
  /** Updates a single `Lookup` using its globally unique id and a patch. */
  updateLookupByNodeId?: Maybe<UpdateLookupPayload>
  /** Updates a single `Lookup` using a unique key and a patch. */
  updateLookupByRealm?: Maybe<UpdateLookupPayload>
  /** Updates a single `LookupValue` using a unique key and a patch. */
  updateLookupValue?: Maybe<UpdateLookupValuePayload>
  /** Updates a single `LookupValue` using a unique key and a patch. */
  updateLookupValueByLookupIdAndCode?: Maybe<UpdateLookupValuePayload>
  /** Updates a single `LookupValue` using its globally unique id and a patch. */
  updateLookupValueByNodeId?: Maybe<UpdateLookupValuePayload>
  /** Updates a single `Membership` using a unique key and a patch. */
  updateMembership?: Maybe<UpdateMembershipPayload>
  /** Updates a single `Membership` using its globally unique id and a patch. */
  updateMembershipByNodeId?: Maybe<UpdateMembershipPayload>
  /** Updates a single `Profile` using a unique key and a patch. */
  updateProfile?: Maybe<UpdateProfilePayload>
  /** Updates a single `Profile` using its globally unique id and a patch. */
  updateProfileByNodeId?: Maybe<UpdateProfilePayload>
  /** Updates a single `Role` using a unique key and a patch. */
  updateRole?: Maybe<UpdateRolePayload>
  /** Updates a single `Role` using a unique key and a patch. */
  updateRoleByAuthority?: Maybe<UpdateRolePayload>
  /** Updates a single `Role` using its globally unique id and a patch. */
  updateRoleByNodeId?: Maybe<UpdateRolePayload>
  /** Updates a single `Room` using a unique key and a patch. */
  updateRoom?: Maybe<UpdateRoomPayload>
  /** Updates a single `Room` using its globally unique id and a patch. */
  updateRoomByNodeId?: Maybe<UpdateRoomPayload>
  /** Updates a single `Setting` using a unique key and a patch. */
  updateSetting?: Maybe<UpdateSettingPayload>
  /** Updates a single `Setting` using its globally unique id and a patch. */
  updateSettingByNodeId?: Maybe<UpdateSettingPayload>
  /** Updates a single `ShirtOrder` using a unique key and a patch. */
  updateShirtOrder?: Maybe<UpdateShirtOrderPayload>
  /** Updates a single `ShirtOrder` using its globally unique id and a patch. */
  updateShirtOrderByNodeId?: Maybe<UpdateShirtOrderPayload>
  /** Updates a single `ShirtOrderItem` using a unique key and a patch. */
  updateShirtOrderItem?: Maybe<UpdateShirtOrderItemPayload>
  /** Updates a single `ShirtOrderItem` using its globally unique id and a patch. */
  updateShirtOrderItemByNodeId?: Maybe<UpdateShirtOrderItemPayload>
  /** Updates a single `Slot` using a unique key and a patch. */
  updateSlot?: Maybe<UpdateSlotPayload>
  /** Updates a single `Slot` using its globally unique id and a patch. */
  updateSlotByNodeId?: Maybe<UpdateSlotPayload>
  /** Updates a single `User` using a unique key and a patch. */
  updateUser?: Maybe<UpdateUserPayload>
  /** Updates a single `User` using a unique key and a patch. */
  updateUserByEmail?: Maybe<UpdateUserPayload>
  /** Updates a single `User` using its globally unique id and a patch. */
  updateUserByNodeId?: Maybe<UpdateUserPayload>
  /** Updates a single `UserRole` using a unique key and a patch. */
  updateUserRole?: Maybe<UpdateUserRolePayload>
  /** Updates a single `UserRole` using its globally unique id and a patch. */
  updateUserRoleByNodeId?: Maybe<UpdateUserRolePayload>
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationCreateBareSlotChoicesArgs {
  input: CreateBareSlotChoicesInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationCreateGameArgs {
  input: CreateGameInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationCreateGameAssignmentArgs {
  input: CreateGameAssignmentInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationCreateGameChoiceArgs {
  input: CreateGameChoiceInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationCreateGameSubmissionArgs {
  input: CreateGameSubmissionInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationCreateHotelRoomArgs {
  input: CreateHotelRoomInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationCreateHotelRoomDetailArgs {
  input: CreateHotelRoomDetailInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationCreateLookupArgs {
  input: CreateLookupInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationCreateLookupValueArgs {
  input: CreateLookupValueInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationCreateMembershipArgs {
  input: CreateMembershipInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationCreateProfileArgs {
  input: CreateProfileInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationCreateRoleArgs {
  input: CreateRoleInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationCreateRoomArgs {
  input: CreateRoomInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationCreateSettingArgs {
  input: CreateSettingInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationCreateShirtOrderArgs {
  input: CreateShirtOrderInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationCreateShirtOrderItemArgs {
  input: CreateShirtOrderItemInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationCreateSlotArgs {
  input: CreateSlotInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationCreateUserArgs {
  input: CreateUserInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationCreateUserRoleArgs {
  input: CreateUserRoleInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteGameArgs {
  input: DeleteGameInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteGameAssignmentArgs {
  input: DeleteGameAssignmentInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteGameAssignmentByNodeIdArgs {
  input: DeleteGameAssignmentByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteGameByNodeIdArgs {
  input: DeleteGameByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteGameChoiceArgs {
  input: DeleteGameChoiceInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteGameChoiceByNodeIdArgs {
  input: DeleteGameChoiceByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteGameSubmissionArgs {
  input: DeleteGameSubmissionInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteGameSubmissionByNodeIdArgs {
  input: DeleteGameSubmissionByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteHotelRoomArgs {
  input: DeleteHotelRoomInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteHotelRoomByNodeIdArgs {
  input: DeleteHotelRoomByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteHotelRoomDetailArgs {
  input: DeleteHotelRoomDetailInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteHotelRoomDetailByNodeIdArgs {
  input: DeleteHotelRoomDetailByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteLookupArgs {
  input: DeleteLookupInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteLookupByNodeIdArgs {
  input: DeleteLookupByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteLookupByRealmArgs {
  input: DeleteLookupByRealmInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteLookupValueArgs {
  input: DeleteLookupValueInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteLookupValueByLookupIdAndCodeArgs {
  input: DeleteLookupValueByLookupIdAndCodeInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteLookupValueByNodeIdArgs {
  input: DeleteLookupValueByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteMembershipArgs {
  input: DeleteMembershipInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteMembershipByNodeIdArgs {
  input: DeleteMembershipByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteProfileArgs {
  input: DeleteProfileInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteProfileByNodeIdArgs {
  input: DeleteProfileByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteRoleArgs {
  input: DeleteRoleInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteRoleByAuthorityArgs {
  input: DeleteRoleByAuthorityInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteRoleByNodeIdArgs {
  input: DeleteRoleByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteRoomArgs {
  input: DeleteRoomInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteRoomByNodeIdArgs {
  input: DeleteRoomByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteSettingArgs {
  input: DeleteSettingInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteSettingByNodeIdArgs {
  input: DeleteSettingByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteShirtOrderArgs {
  input: DeleteShirtOrderInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteShirtOrderByNodeIdArgs {
  input: DeleteShirtOrderByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteShirtOrderItemArgs {
  input: DeleteShirtOrderItemInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteShirtOrderItemByNodeIdArgs {
  input: DeleteShirtOrderItemByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteSlotArgs {
  input: DeleteSlotInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteSlotByNodeIdArgs {
  input: DeleteSlotByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteUserArgs {
  input: DeleteUserInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteUserByEmailArgs {
  input: DeleteUserByEmailInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteUserByNodeIdArgs {
  input: DeleteUserByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteUserRoleArgs {
  input: DeleteUserRoleInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationDeleteUserRoleByNodeIdArgs {
  input: DeleteUserRoleByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationFTruncateTablesArgs {
  input: FTruncateTablesInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationSlotGmGameArgs {
  input: SlotGmGameInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateGameArgs {
  input: UpdateGameInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateGameAssignmentArgs {
  input: UpdateGameAssignmentInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateGameAssignmentByNodeIdArgs {
  input: UpdateGameAssignmentByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateGameByNodeIdArgs {
  input: UpdateGameByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateGameChoiceArgs {
  input: UpdateGameChoiceInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateGameChoiceByNodeIdArgs {
  input: UpdateGameChoiceByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateGameSubmissionArgs {
  input: UpdateGameSubmissionInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateGameSubmissionByNodeIdArgs {
  input: UpdateGameSubmissionByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateHotelRoomArgs {
  input: UpdateHotelRoomInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateHotelRoomByNodeIdArgs {
  input: UpdateHotelRoomByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateHotelRoomDetailArgs {
  input: UpdateHotelRoomDetailInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateHotelRoomDetailByNodeIdArgs {
  input: UpdateHotelRoomDetailByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateLookupArgs {
  input: UpdateLookupInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateLookupByNodeIdArgs {
  input: UpdateLookupByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateLookupByRealmArgs {
  input: UpdateLookupByRealmInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateLookupValueArgs {
  input: UpdateLookupValueInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateLookupValueByLookupIdAndCodeArgs {
  input: UpdateLookupValueByLookupIdAndCodeInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateLookupValueByNodeIdArgs {
  input: UpdateLookupValueByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateMembershipArgs {
  input: UpdateMembershipInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateMembershipByNodeIdArgs {
  input: UpdateMembershipByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateProfileArgs {
  input: UpdateProfileInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateProfileByNodeIdArgs {
  input: UpdateProfileByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateRoleArgs {
  input: UpdateRoleInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateRoleByAuthorityArgs {
  input: UpdateRoleByAuthorityInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateRoleByNodeIdArgs {
  input: UpdateRoleByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateRoomArgs {
  input: UpdateRoomInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateRoomByNodeIdArgs {
  input: UpdateRoomByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateSettingArgs {
  input: UpdateSettingInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateSettingByNodeIdArgs {
  input: UpdateSettingByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateShirtOrderArgs {
  input: UpdateShirtOrderInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateShirtOrderByNodeIdArgs {
  input: UpdateShirtOrderByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateShirtOrderItemArgs {
  input: UpdateShirtOrderItemInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateShirtOrderItemByNodeIdArgs {
  input: UpdateShirtOrderItemByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateSlotArgs {
  input: UpdateSlotInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateSlotByNodeIdArgs {
  input: UpdateSlotByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateUserArgs {
  input: UpdateUserInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateUserByEmailArgs {
  input: UpdateUserByEmailInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateUserByNodeIdArgs {
  input: UpdateUserByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateUserRoleArgs {
  input: UpdateUserRoleInput
}

/** The root mutation type which contains root level fields which mutate data. */
export interface MutationUpdateUserRoleByNodeIdArgs {
  input: UpdateUserRoleByNodeIdInput
}

/** An object with a globally unique `ID`. */
export interface Node {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']
}

/** Information about pagination in a connection. */
export interface PageInfo {
  __typename: 'PageInfo'
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']>
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']>
}

export interface Profile extends Node {
  __typename: 'Profile'
  id: Scalars['Int']
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']
  phoneNumber?: Maybe<Scalars['String']>
  snailMailAddress?: Maybe<Scalars['String']>
  /** Reads a single `User` that is related to this `Profile`. */
  user?: Maybe<User>
  userId: Scalars['Int']
}

/** A condition to be used against `Profile` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export interface ProfileCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `phoneNumber` field. */
  phoneNumber?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `snailMailAddress` field. */
  snailMailAddress?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']>
}

/** A filter to be used against `Profile` object types. All fields are combined with a logical ‘and.’ */
export interface ProfileFilter {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ProfileFilter>>
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>
  /** Negates the expression. */
  not?: InputMaybe<ProfileFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ProfileFilter>>
  /** Filter by the object’s `phoneNumber` field. */
  phoneNumber?: InputMaybe<StringFilter>
  /** Filter by the object’s `snailMailAddress` field. */
  snailMailAddress?: InputMaybe<StringFilter>
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>
}

/** An input for mutations affecting `Profile` */
export interface ProfileInput {
  id?: InputMaybe<Scalars['Int']>
  phoneNumber?: InputMaybe<Scalars['String']>
  snailMailAddress?: InputMaybe<Scalars['String']>
  userId: Scalars['Int']
}

/** Represents an update to a `Profile`. Fields that are set will be updated. */
export interface ProfilePatch {
  id?: InputMaybe<Scalars['Int']>
  phoneNumber?: InputMaybe<Scalars['String']>
  snailMailAddress?: InputMaybe<Scalars['String']>
  userId?: InputMaybe<Scalars['Int']>
}

/** A connection to a list of `Profile` values. */
export interface ProfilesConnection {
  __typename: 'ProfilesConnection'
  /** A list of edges which contains the `Profile` and cursor to aid in pagination. */
  edges: Array<ProfilesEdge>
  /** A list of `Profile` objects. */
  nodes: Array<Maybe<Profile>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Profile` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Profile` edge in the connection. */
export interface ProfilesEdge {
  __typename: 'ProfilesEdge'
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Profile` at the end of the edge. */
  node?: Maybe<Profile>
}

/** Methods to use when ordering `Profile`. */
export enum ProfilesOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PhoneNumberAsc = 'PHONE_NUMBER_ASC',
  PhoneNumberDesc = 'PHONE_NUMBER_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SnailMailAddressAsc = 'SNAIL_MAIL_ADDRESS_ASC',
  SnailMailAddressDesc = 'SNAIL_MAIL_ADDRESS_DESC',
  UserByUserIdEmailAsc = 'USER_BY_USER_ID__EMAIL_ASC',
  UserByUserIdEmailDesc = 'USER_BY_USER_ID__EMAIL_DESC',
  UserByUserIdFirstNameAsc = 'USER_BY_USER_ID__FIRST_NAME_ASC',
  UserByUserIdFirstNameDesc = 'USER_BY_USER_ID__FIRST_NAME_DESC',
  UserByUserIdFullNameAsc = 'USER_BY_USER_ID__FULL_NAME_ASC',
  UserByUserIdFullNameDesc = 'USER_BY_USER_ID__FULL_NAME_DESC',
  UserByUserIdIdAsc = 'USER_BY_USER_ID__ID_ASC',
  UserByUserIdIdDesc = 'USER_BY_USER_ID__ID_DESC',
  UserByUserIdLastNameAsc = 'USER_BY_USER_ID__LAST_NAME_ASC',
  UserByUserIdLastNameDesc = 'USER_BY_USER_ID__LAST_NAME_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
}

/** The root query type which gives access points into the data universe. */
export interface Query extends Node {
  __typename: 'Query'
  currentUserId?: Maybe<Scalars['Int']>
  currentUserIsAdmin?: Maybe<Scalars['Boolean']>
  game?: Maybe<Game>
  gameAssignment?: Maybe<GameAssignment>
  /** Reads a single `GameAssignment` using its globally unique `ID`. */
  gameAssignmentByNodeId?: Maybe<GameAssignment>
  /** Reads and enables pagination through a set of `GameAssignment`. */
  gameAssignments?: Maybe<GameAssignmentsConnection>
  /** Reads a single `Game` using its globally unique `ID`. */
  gameByNodeId?: Maybe<Game>
  gameChoice?: Maybe<GameChoice>
  /** Reads a single `GameChoice` using its globally unique `ID`. */
  gameChoiceByNodeId?: Maybe<GameChoice>
  /** Reads and enables pagination through a set of `GameChoice`. */
  gameChoices?: Maybe<GameChoicesConnection>
  gameSubmission?: Maybe<GameSubmission>
  /** Reads a single `GameSubmission` using its globally unique `ID`. */
  gameSubmissionByNodeId?: Maybe<GameSubmission>
  /** Reads and enables pagination through a set of `GameSubmission`. */
  gameSubmissions?: Maybe<GameSubmissionsConnection>
  /** Reads and enables pagination through a set of `Game`. */
  games?: Maybe<GamesConnection>
  hotelRoom?: Maybe<HotelRoom>
  /** Reads a single `HotelRoom` using its globally unique `ID`. */
  hotelRoomByNodeId?: Maybe<HotelRoom>
  hotelRoomDetail?: Maybe<HotelRoomDetail>
  /** Reads a single `HotelRoomDetail` using its globally unique `ID`. */
  hotelRoomDetailByNodeId?: Maybe<HotelRoomDetail>
  /** Reads and enables pagination through a set of `HotelRoomDetail`. */
  hotelRoomDetails?: Maybe<HotelRoomDetailsConnection>
  /** Reads and enables pagination through a set of `HotelRoom`. */
  hotelRooms?: Maybe<HotelRoomsConnection>
  lookup?: Maybe<Lookup>
  /** Reads a single `Lookup` using its globally unique `ID`. */
  lookupByNodeId?: Maybe<Lookup>
  lookupByRealm?: Maybe<Lookup>
  lookupValue?: Maybe<LookupValue>
  lookupValueByLookupIdAndCode?: Maybe<LookupValue>
  /** Reads a single `LookupValue` using its globally unique `ID`. */
  lookupValueByNodeId?: Maybe<LookupValue>
  /** Reads and enables pagination through a set of `LookupValue`. */
  lookupValues?: Maybe<LookupValuesConnection>
  /** Reads and enables pagination through a set of `Lookup`. */
  lookups?: Maybe<LookupsConnection>
  membership?: Maybe<Membership>
  /** Reads a single `Membership` using its globally unique `ID`. */
  membershipByNodeId?: Maybe<Membership>
  /** Reads and enables pagination through a set of `Membership`. */
  memberships?: Maybe<MembershipsConnection>
  /** Fetches an object given its globally unique `ID`. */
  node?: Maybe<Node>
  /** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. */
  nodeId: Scalars['ID']
  profile?: Maybe<Profile>
  /** Reads a single `Profile` using its globally unique `ID`. */
  profileByNodeId?: Maybe<Profile>
  /** Reads and enables pagination through a set of `Profile`. */
  profiles?: Maybe<ProfilesConnection>
  /**
   * Exposes the root query type nested one level down. This is helpful for Relay 1
   * which can only query top level fields if they are in a particular form.
   */
  query: Query
  role?: Maybe<Role>
  roleByAuthority?: Maybe<Role>
  /** Reads a single `Role` using its globally unique `ID`. */
  roleByNodeId?: Maybe<Role>
  /** Reads and enables pagination through a set of `Role`. */
  roles?: Maybe<RolesConnection>
  room?: Maybe<Room>
  /** Reads a single `Room` using its globally unique `ID`. */
  roomByNodeId?: Maybe<Room>
  /** Reads and enables pagination through a set of `Room`. */
  rooms?: Maybe<RoomsConnection>
  setting?: Maybe<Setting>
  /** Reads a single `Setting` using its globally unique `ID`. */
  settingByNodeId?: Maybe<Setting>
  /** Reads and enables pagination through a set of `Setting`. */
  settings?: Maybe<SettingsConnection>
  shirtOrder?: Maybe<ShirtOrder>
  /** Reads a single `ShirtOrder` using its globally unique `ID`. */
  shirtOrderByNodeId?: Maybe<ShirtOrder>
  shirtOrderItem?: Maybe<ShirtOrderItem>
  /** Reads a single `ShirtOrderItem` using its globally unique `ID`. */
  shirtOrderItemByNodeId?: Maybe<ShirtOrderItem>
  /** Reads and enables pagination through a set of `ShirtOrderItem`. */
  shirtOrderItems?: Maybe<ShirtOrderItemsConnection>
  /** Reads and enables pagination through a set of `ShirtOrder`. */
  shirtOrders?: Maybe<ShirtOrdersConnection>
  slot?: Maybe<Slot>
  /** Reads a single `Slot` using its globally unique `ID`. */
  slotByNodeId?: Maybe<Slot>
  /** Reads and enables pagination through a set of `Slot`. */
  slots?: Maybe<SlotsConnection>
  user?: Maybe<User>
  userByEmail?: Maybe<User>
  /** Reads a single `User` using its globally unique `ID`. */
  userByNodeId?: Maybe<User>
  userRole?: Maybe<UserRole>
  /** Reads a single `UserRole` using its globally unique `ID`. */
  userRoleByNodeId?: Maybe<UserRole>
  /** Reads and enables pagination through a set of `UserRole`. */
  userRoles?: Maybe<UserRolesConnection>
  /** Reads and enables pagination through a set of `User`. */
  users?: Maybe<UsersConnection>
}

/** The root query type which gives access points into the data universe. */
export interface QueryGameArgs {
  id: Scalars['Int']
}

/** The root query type which gives access points into the data universe. */
export interface QueryGameAssignmentArgs {
  gameId: Scalars['Int']
  gm: Scalars['Int']
  memberId: Scalars['Int']
}

/** The root query type which gives access points into the data universe. */
export interface QueryGameAssignmentByNodeIdArgs {
  nodeId: Scalars['ID']
}

/** The root query type which gives access points into the data universe. */
export interface QueryGameAssignmentsArgs {
  after?: InputMaybe<Scalars['Cursor']>
  before?: InputMaybe<Scalars['Cursor']>
  condition?: InputMaybe<GameAssignmentCondition>
  filter?: InputMaybe<GameAssignmentFilter>
  first?: InputMaybe<Scalars['Int']>
  last?: InputMaybe<Scalars['Int']>
  offset?: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<GameAssignmentsOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export interface QueryGameByNodeIdArgs {
  nodeId: Scalars['ID']
}

/** The root query type which gives access points into the data universe. */
export interface QueryGameChoiceArgs {
  id: Scalars['Int']
}

/** The root query type which gives access points into the data universe. */
export interface QueryGameChoiceByNodeIdArgs {
  nodeId: Scalars['ID']
}

/** The root query type which gives access points into the data universe. */
export interface QueryGameChoicesArgs {
  after?: InputMaybe<Scalars['Cursor']>
  before?: InputMaybe<Scalars['Cursor']>
  condition?: InputMaybe<GameChoiceCondition>
  filter?: InputMaybe<GameChoiceFilter>
  first?: InputMaybe<Scalars['Int']>
  last?: InputMaybe<Scalars['Int']>
  offset?: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<GameChoicesOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export interface QueryGameSubmissionArgs {
  id: Scalars['Int']
}

/** The root query type which gives access points into the data universe. */
export interface QueryGameSubmissionByNodeIdArgs {
  nodeId: Scalars['ID']
}

/** The root query type which gives access points into the data universe. */
export interface QueryGameSubmissionsArgs {
  after?: InputMaybe<Scalars['Cursor']>
  before?: InputMaybe<Scalars['Cursor']>
  condition?: InputMaybe<GameSubmissionCondition>
  filter?: InputMaybe<GameSubmissionFilter>
  first?: InputMaybe<Scalars['Int']>
  last?: InputMaybe<Scalars['Int']>
  offset?: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<GameSubmissionsOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export interface QueryGamesArgs {
  after?: InputMaybe<Scalars['Cursor']>
  before?: InputMaybe<Scalars['Cursor']>
  condition?: InputMaybe<GameCondition>
  filter?: InputMaybe<GameFilter>
  first?: InputMaybe<Scalars['Int']>
  last?: InputMaybe<Scalars['Int']>
  offset?: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<GamesOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export interface QueryHotelRoomArgs {
  id: Scalars['Int']
}

/** The root query type which gives access points into the data universe. */
export interface QueryHotelRoomByNodeIdArgs {
  nodeId: Scalars['ID']
}

/** The root query type which gives access points into the data universe. */
export interface QueryHotelRoomDetailArgs {
  id: Scalars['BigInt']
}

/** The root query type which gives access points into the data universe. */
export interface QueryHotelRoomDetailByNodeIdArgs {
  nodeId: Scalars['ID']
}

/** The root query type which gives access points into the data universe. */
export interface QueryHotelRoomDetailsArgs {
  after?: InputMaybe<Scalars['Cursor']>
  before?: InputMaybe<Scalars['Cursor']>
  condition?: InputMaybe<HotelRoomDetailCondition>
  filter?: InputMaybe<HotelRoomDetailFilter>
  first?: InputMaybe<Scalars['Int']>
  last?: InputMaybe<Scalars['Int']>
  offset?: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<HotelRoomDetailsOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export interface QueryHotelRoomsArgs {
  after?: InputMaybe<Scalars['Cursor']>
  before?: InputMaybe<Scalars['Cursor']>
  condition?: InputMaybe<HotelRoomCondition>
  filter?: InputMaybe<HotelRoomFilter>
  first?: InputMaybe<Scalars['Int']>
  last?: InputMaybe<Scalars['Int']>
  offset?: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<HotelRoomsOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export interface QueryLookupArgs {
  id: Scalars['Int']
}

/** The root query type which gives access points into the data universe. */
export interface QueryLookupByNodeIdArgs {
  nodeId: Scalars['ID']
}

/** The root query type which gives access points into the data universe. */
export interface QueryLookupByRealmArgs {
  realm: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export interface QueryLookupValueArgs {
  id: Scalars['Int']
}

/** The root query type which gives access points into the data universe. */
export interface QueryLookupValueByLookupIdAndCodeArgs {
  code: Scalars['String']
  lookupId: Scalars['Int']
}

/** The root query type which gives access points into the data universe. */
export interface QueryLookupValueByNodeIdArgs {
  nodeId: Scalars['ID']
}

/** The root query type which gives access points into the data universe. */
export interface QueryLookupValuesArgs {
  after?: InputMaybe<Scalars['Cursor']>
  before?: InputMaybe<Scalars['Cursor']>
  condition?: InputMaybe<LookupValueCondition>
  filter?: InputMaybe<LookupValueFilter>
  first?: InputMaybe<Scalars['Int']>
  last?: InputMaybe<Scalars['Int']>
  offset?: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<LookupValuesOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export interface QueryLookupsArgs {
  after?: InputMaybe<Scalars['Cursor']>
  before?: InputMaybe<Scalars['Cursor']>
  condition?: InputMaybe<LookupCondition>
  filter?: InputMaybe<LookupFilter>
  first?: InputMaybe<Scalars['Int']>
  last?: InputMaybe<Scalars['Int']>
  offset?: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<LookupsOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export interface QueryMembershipArgs {
  id: Scalars['Int']
}

/** The root query type which gives access points into the data universe. */
export interface QueryMembershipByNodeIdArgs {
  nodeId: Scalars['ID']
}

/** The root query type which gives access points into the data universe. */
export interface QueryMembershipsArgs {
  after?: InputMaybe<Scalars['Cursor']>
  before?: InputMaybe<Scalars['Cursor']>
  condition?: InputMaybe<MembershipCondition>
  filter?: InputMaybe<MembershipFilter>
  first?: InputMaybe<Scalars['Int']>
  last?: InputMaybe<Scalars['Int']>
  offset?: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<MembershipsOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export interface QueryNodeArgs {
  nodeId: Scalars['ID']
}

/** The root query type which gives access points into the data universe. */
export interface QueryProfileArgs {
  id: Scalars['Int']
}

/** The root query type which gives access points into the data universe. */
export interface QueryProfileByNodeIdArgs {
  nodeId: Scalars['ID']
}

/** The root query type which gives access points into the data universe. */
export interface QueryProfilesArgs {
  after?: InputMaybe<Scalars['Cursor']>
  before?: InputMaybe<Scalars['Cursor']>
  condition?: InputMaybe<ProfileCondition>
  filter?: InputMaybe<ProfileFilter>
  first?: InputMaybe<Scalars['Int']>
  last?: InputMaybe<Scalars['Int']>
  offset?: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ProfilesOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export interface QueryRoleArgs {
  id: Scalars['Int']
}

/** The root query type which gives access points into the data universe. */
export interface QueryRoleByAuthorityArgs {
  authority: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export interface QueryRoleByNodeIdArgs {
  nodeId: Scalars['ID']
}

/** The root query type which gives access points into the data universe. */
export interface QueryRolesArgs {
  after?: InputMaybe<Scalars['Cursor']>
  before?: InputMaybe<Scalars['Cursor']>
  condition?: InputMaybe<RoleCondition>
  filter?: InputMaybe<RoleFilter>
  first?: InputMaybe<Scalars['Int']>
  last?: InputMaybe<Scalars['Int']>
  offset?: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<RolesOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export interface QueryRoomArgs {
  id: Scalars['Int']
}

/** The root query type which gives access points into the data universe. */
export interface QueryRoomByNodeIdArgs {
  nodeId: Scalars['ID']
}

/** The root query type which gives access points into the data universe. */
export interface QueryRoomsArgs {
  after?: InputMaybe<Scalars['Cursor']>
  before?: InputMaybe<Scalars['Cursor']>
  condition?: InputMaybe<RoomCondition>
  filter?: InputMaybe<RoomFilter>
  first?: InputMaybe<Scalars['Int']>
  last?: InputMaybe<Scalars['Int']>
  offset?: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<RoomsOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export interface QuerySettingArgs {
  id: Scalars['Int']
}

/** The root query type which gives access points into the data universe. */
export interface QuerySettingByNodeIdArgs {
  nodeId: Scalars['ID']
}

/** The root query type which gives access points into the data universe. */
export interface QuerySettingsArgs {
  after?: InputMaybe<Scalars['Cursor']>
  before?: InputMaybe<Scalars['Cursor']>
  condition?: InputMaybe<SettingCondition>
  filter?: InputMaybe<SettingFilter>
  first?: InputMaybe<Scalars['Int']>
  last?: InputMaybe<Scalars['Int']>
  offset?: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<SettingsOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export interface QueryShirtOrderArgs {
  id: Scalars['Int']
}

/** The root query type which gives access points into the data universe. */
export interface QueryShirtOrderByNodeIdArgs {
  nodeId: Scalars['ID']
}

/** The root query type which gives access points into the data universe. */
export interface QueryShirtOrderItemArgs {
  id: Scalars['Int']
}

/** The root query type which gives access points into the data universe. */
export interface QueryShirtOrderItemByNodeIdArgs {
  nodeId: Scalars['ID']
}

/** The root query type which gives access points into the data universe. */
export interface QueryShirtOrderItemsArgs {
  after?: InputMaybe<Scalars['Cursor']>
  before?: InputMaybe<Scalars['Cursor']>
  condition?: InputMaybe<ShirtOrderItemCondition>
  filter?: InputMaybe<ShirtOrderItemFilter>
  first?: InputMaybe<Scalars['Int']>
  last?: InputMaybe<Scalars['Int']>
  offset?: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ShirtOrderItemsOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export interface QueryShirtOrdersArgs {
  after?: InputMaybe<Scalars['Cursor']>
  before?: InputMaybe<Scalars['Cursor']>
  condition?: InputMaybe<ShirtOrderCondition>
  filter?: InputMaybe<ShirtOrderFilter>
  first?: InputMaybe<Scalars['Int']>
  last?: InputMaybe<Scalars['Int']>
  offset?: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ShirtOrdersOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export interface QuerySlotArgs {
  id: Scalars['Int']
}

/** The root query type which gives access points into the data universe. */
export interface QuerySlotByNodeIdArgs {
  nodeId: Scalars['ID']
}

/** The root query type which gives access points into the data universe. */
export interface QuerySlotsArgs {
  after?: InputMaybe<Scalars['Cursor']>
  before?: InputMaybe<Scalars['Cursor']>
  condition?: InputMaybe<SlotCondition>
  filter?: InputMaybe<SlotFilter>
  first?: InputMaybe<Scalars['Int']>
  last?: InputMaybe<Scalars['Int']>
  offset?: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<SlotsOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export interface QueryUserArgs {
  id: Scalars['Int']
}

/** The root query type which gives access points into the data universe. */
export interface QueryUserByEmailArgs {
  email: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export interface QueryUserByNodeIdArgs {
  nodeId: Scalars['ID']
}

/** The root query type which gives access points into the data universe. */
export interface QueryUserRoleArgs {
  roleId: Scalars['Int']
  userId: Scalars['Int']
}

/** The root query type which gives access points into the data universe. */
export interface QueryUserRoleByNodeIdArgs {
  nodeId: Scalars['ID']
}

/** The root query type which gives access points into the data universe. */
export interface QueryUserRolesArgs {
  after?: InputMaybe<Scalars['Cursor']>
  before?: InputMaybe<Scalars['Cursor']>
  condition?: InputMaybe<UserRoleCondition>
  filter?: InputMaybe<UserRoleFilter>
  first?: InputMaybe<Scalars['Int']>
  last?: InputMaybe<Scalars['Int']>
  offset?: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<UserRolesOrderBy>>
}

/** The root query type which gives access points into the data universe. */
export interface QueryUsersArgs {
  after?: InputMaybe<Scalars['Cursor']>
  before?: InputMaybe<Scalars['Cursor']>
  condition?: InputMaybe<UserCondition>
  filter?: InputMaybe<UserFilter>
  first?: InputMaybe<Scalars['Int']>
  last?: InputMaybe<Scalars['Int']>
  offset?: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<UsersOrderBy>>
}

export interface Role extends Node {
  __typename: 'Role'
  authority: Scalars['String']
  id: Scalars['Int']
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']
  /** Reads and enables pagination through a set of `UserRole`. */
  userRoles: UserRolesConnection
}

export interface RoleUserRolesArgs {
  after?: InputMaybe<Scalars['Cursor']>
  before?: InputMaybe<Scalars['Cursor']>
  condition?: InputMaybe<UserRoleCondition>
  filter?: InputMaybe<UserRoleFilter>
  first?: InputMaybe<Scalars['Int']>
  last?: InputMaybe<Scalars['Int']>
  offset?: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<UserRolesOrderBy>>
}

/** A condition to be used against `Role` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export interface RoleCondition {
  /** Checks for equality with the object’s `authority` field. */
  authority?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>
}

/** A filter to be used against `Role` object types. All fields are combined with a logical ‘and.’ */
export interface RoleFilter {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<RoleFilter>>
  /** Filter by the object’s `authority` field. */
  authority?: InputMaybe<StringFilter>
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>
  /** Negates the expression. */
  not?: InputMaybe<RoleFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<RoleFilter>>
}

/** An input for mutations affecting `Role` */
export interface RoleInput {
  authority: Scalars['String']
  id?: InputMaybe<Scalars['Int']>
}

/** Represents an update to a `Role`. Fields that are set will be updated. */
export interface RolePatch {
  authority?: InputMaybe<Scalars['String']>
  id?: InputMaybe<Scalars['Int']>
}

/** A connection to a list of `Role` values. */
export interface RolesConnection {
  __typename: 'RolesConnection'
  /** A list of edges which contains the `Role` and cursor to aid in pagination. */
  edges: Array<RolesEdge>
  /** A list of `Role` objects. */
  nodes: Array<Maybe<Role>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Role` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Role` edge in the connection. */
export interface RolesEdge {
  __typename: 'RolesEdge'
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Role` at the end of the edge. */
  node?: Maybe<Role>
}

/** Methods to use when ordering `Role`. */
export enum RolesOrderBy {
  AuthorityAsc = 'AUTHORITY_ASC',
  AuthorityDesc = 'AUTHORITY_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserRolesByRoleIdCountAsc = 'USER_ROLES_BY_ROLE_ID__COUNT_ASC',
  UserRolesByRoleIdCountDesc = 'USER_ROLES_BY_ROLE_ID__COUNT_DESC',
}

export interface Room extends Node {
  __typename: 'Room'
  description: Scalars['String']
  /** Reads and enables pagination through a set of `Game`. */
  games: GamesConnection
  id: Scalars['Int']
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']
  size: Scalars['Int']
  type: Scalars['String']
  updated: Scalars['Boolean']
}

export interface RoomGamesArgs {
  after?: InputMaybe<Scalars['Cursor']>
  before?: InputMaybe<Scalars['Cursor']>
  condition?: InputMaybe<GameCondition>
  filter?: InputMaybe<GameFilter>
  first?: InputMaybe<Scalars['Int']>
  last?: InputMaybe<Scalars['Int']>
  offset?: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<GamesOrderBy>>
}

/** A condition to be used against `Room` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export interface RoomCondition {
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `size` field. */
  size?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `updated` field. */
  updated?: InputMaybe<Scalars['Boolean']>
}

/** A filter to be used against `Room` object types. All fields are combined with a logical ‘and.’ */
export interface RoomFilter {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<RoomFilter>>
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>
  /** Negates the expression. */
  not?: InputMaybe<RoomFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<RoomFilter>>
  /** Filter by the object’s `size` field. */
  size?: InputMaybe<IntFilter>
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<StringFilter>
  /** Filter by the object’s `updated` field. */
  updated?: InputMaybe<BooleanFilter>
}

/** An input for mutations affecting `Room` */
export interface RoomInput {
  description: Scalars['String']
  id?: InputMaybe<Scalars['Int']>
  size: Scalars['Int']
  type: Scalars['String']
  updated: Scalars['Boolean']
}

/** Represents an update to a `Room`. Fields that are set will be updated. */
export interface RoomPatch {
  description?: InputMaybe<Scalars['String']>
  id?: InputMaybe<Scalars['Int']>
  size?: InputMaybe<Scalars['Int']>
  type?: InputMaybe<Scalars['String']>
  updated?: InputMaybe<Scalars['Boolean']>
}

/** A connection to a list of `Room` values. */
export interface RoomsConnection {
  __typename: 'RoomsConnection'
  /** A list of edges which contains the `Room` and cursor to aid in pagination. */
  edges: Array<RoomsEdge>
  /** A list of `Room` objects. */
  nodes: Array<Maybe<Room>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Room` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Room` edge in the connection. */
export interface RoomsEdge {
  __typename: 'RoomsEdge'
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Room` at the end of the edge. */
  node?: Maybe<Room>
}

/** Methods to use when ordering `Room`. */
export enum RoomsOrderBy {
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  GamesByRoomIdCountAsc = 'GAMES_BY_ROOM_ID__COUNT_ASC',
  GamesByRoomIdCountDesc = 'GAMES_BY_ROOM_ID__COUNT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SizeAsc = 'SIZE_ASC',
  SizeDesc = 'SIZE_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  UpdatedAsc = 'UPDATED_ASC',
  UpdatedDesc = 'UPDATED_DESC',
}

export interface Setting extends Node {
  __typename: 'Setting'
  code: Scalars['String']
  id: Scalars['Int']
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']
  type: Scalars['String']
  value: Scalars['String']
}

/** A condition to be used against `Setting` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export interface SettingCondition {
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `value` field. */
  value?: InputMaybe<Scalars['String']>
}

/** A filter to be used against `Setting` object types. All fields are combined with a logical ‘and.’ */
export interface SettingFilter {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SettingFilter>>
  /** Filter by the object’s `code` field. */
  code?: InputMaybe<StringFilter>
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>
  /** Negates the expression. */
  not?: InputMaybe<SettingFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SettingFilter>>
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<StringFilter>
  /** Filter by the object’s `value` field. */
  value?: InputMaybe<StringFilter>
}

/** An input for mutations affecting `Setting` */
export interface SettingInput {
  code: Scalars['String']
  id?: InputMaybe<Scalars['Int']>
  type: Scalars['String']
  value: Scalars['String']
}

/** Represents an update to a `Setting`. Fields that are set will be updated. */
export interface SettingPatch {
  code?: InputMaybe<Scalars['String']>
  id?: InputMaybe<Scalars['Int']>
  type?: InputMaybe<Scalars['String']>
  value?: InputMaybe<Scalars['String']>
}

/** A connection to a list of `Setting` values. */
export interface SettingsConnection {
  __typename: 'SettingsConnection'
  /** A list of edges which contains the `Setting` and cursor to aid in pagination. */
  edges: Array<SettingsEdge>
  /** A list of `Setting` objects. */
  nodes: Array<Maybe<Setting>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Setting` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Setting` edge in the connection. */
export interface SettingsEdge {
  __typename: 'SettingsEdge'
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Setting` at the end of the edge. */
  node?: Maybe<Setting>
}

/** Methods to use when ordering `Setting`. */
export enum SettingsOrderBy {
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  ValueAsc = 'VALUE_ASC',
  ValueDesc = 'VALUE_DESC',
}

export interface ShirtOrder extends Node {
  __typename: 'ShirtOrder'
  deliveryMethod: Scalars['String']
  id: Scalars['Int']
  message: Scalars['String']
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']
  /** Reads and enables pagination through a set of `ShirtOrderItem`. */
  shirtOrderItemsByOrderId: ShirtOrderItemsConnection
  /** Reads a single `User` that is related to this `ShirtOrder`. */
  user?: Maybe<User>
  userId: Scalars['Int']
  year: Scalars['Int']
}

export interface ShirtOrderShirtOrderItemsByOrderIdArgs {
  after?: InputMaybe<Scalars['Cursor']>
  before?: InputMaybe<Scalars['Cursor']>
  condition?: InputMaybe<ShirtOrderItemCondition>
  filter?: InputMaybe<ShirtOrderItemFilter>
  first?: InputMaybe<Scalars['Int']>
  last?: InputMaybe<Scalars['Int']>
  offset?: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ShirtOrderItemsOrderBy>>
}

/**
 * A condition to be used against `ShirtOrder` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export interface ShirtOrderCondition {
  /** Checks for equality with the object’s `deliveryMethod` field. */
  deliveryMethod?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `message` field. */
  message?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `year` field. */
  year?: InputMaybe<Scalars['Int']>
}

/** A filter to be used against `ShirtOrder` object types. All fields are combined with a logical ‘and.’ */
export interface ShirtOrderFilter {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ShirtOrderFilter>>
  /** Filter by the object’s `deliveryMethod` field. */
  deliveryMethod?: InputMaybe<StringFilter>
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>
  /** Filter by the object’s `message` field. */
  message?: InputMaybe<StringFilter>
  /** Negates the expression. */
  not?: InputMaybe<ShirtOrderFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ShirtOrderFilter>>
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>
  /** Filter by the object’s `year` field. */
  year?: InputMaybe<IntFilter>
}

/** An input for mutations affecting `ShirtOrder` */
export interface ShirtOrderInput {
  deliveryMethod: Scalars['String']
  id?: InputMaybe<Scalars['Int']>
  message: Scalars['String']
  userId: Scalars['Int']
  year: Scalars['Int']
}

export interface ShirtOrderItem extends Node {
  __typename: 'ShirtOrderItem'
  id: Scalars['Int']
  itemsIdx?: Maybe<Scalars['Int']>
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']
  /** Reads a single `ShirtOrder` that is related to this `ShirtOrderItem`. */
  order?: Maybe<ShirtOrder>
  orderId: Scalars['Int']
  quantity: Scalars['Int']
  size: Scalars['String']
  style: Scalars['String']
}

/**
 * A condition to be used against `ShirtOrderItem` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export interface ShirtOrderItemCondition {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `itemsIdx` field. */
  itemsIdx?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `orderId` field. */
  orderId?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `size` field. */
  size?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `style` field. */
  style?: InputMaybe<Scalars['String']>
}

/** A filter to be used against `ShirtOrderItem` object types. All fields are combined with a logical ‘and.’ */
export interface ShirtOrderItemFilter {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ShirtOrderItemFilter>>
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>
  /** Filter by the object’s `itemsIdx` field. */
  itemsIdx?: InputMaybe<IntFilter>
  /** Negates the expression. */
  not?: InputMaybe<ShirtOrderItemFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ShirtOrderItemFilter>>
  /** Filter by the object’s `orderId` field. */
  orderId?: InputMaybe<IntFilter>
  /** Filter by the object’s `quantity` field. */
  quantity?: InputMaybe<IntFilter>
  /** Filter by the object’s `size` field. */
  size?: InputMaybe<StringFilter>
  /** Filter by the object’s `style` field. */
  style?: InputMaybe<StringFilter>
}

/** An input for mutations affecting `ShirtOrderItem` */
export interface ShirtOrderItemInput {
  id?: InputMaybe<Scalars['Int']>
  itemsIdx?: InputMaybe<Scalars['Int']>
  orderId: Scalars['Int']
  quantity: Scalars['Int']
  size: Scalars['String']
  style: Scalars['String']
}

/** Represents an update to a `ShirtOrderItem`. Fields that are set will be updated. */
export interface ShirtOrderItemPatch {
  id?: InputMaybe<Scalars['Int']>
  itemsIdx?: InputMaybe<Scalars['Int']>
  orderId?: InputMaybe<Scalars['Int']>
  quantity?: InputMaybe<Scalars['Int']>
  size?: InputMaybe<Scalars['String']>
  style?: InputMaybe<Scalars['String']>
}

/** A connection to a list of `ShirtOrderItem` values. */
export interface ShirtOrderItemsConnection {
  __typename: 'ShirtOrderItemsConnection'
  /** A list of edges which contains the `ShirtOrderItem` and cursor to aid in pagination. */
  edges: Array<ShirtOrderItemsEdge>
  /** A list of `ShirtOrderItem` objects. */
  nodes: Array<Maybe<ShirtOrderItem>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `ShirtOrderItem` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `ShirtOrderItem` edge in the connection. */
export interface ShirtOrderItemsEdge {
  __typename: 'ShirtOrderItemsEdge'
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `ShirtOrderItem` at the end of the edge. */
  node?: Maybe<ShirtOrderItem>
}

/** Methods to use when ordering `ShirtOrderItem`. */
export enum ShirtOrderItemsOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ItemsIdxAsc = 'ITEMS_IDX_ASC',
  ItemsIdxDesc = 'ITEMS_IDX_DESC',
  Natural = 'NATURAL',
  OrderIdAsc = 'ORDER_ID_ASC',
  OrderIdDesc = 'ORDER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuantityAsc = 'QUANTITY_ASC',
  QuantityDesc = 'QUANTITY_DESC',
  ShirtOrderByOrderIdDeliveryMethodAsc = 'SHIRT_ORDER_BY_ORDER_ID__DELIVERY_METHOD_ASC',
  ShirtOrderByOrderIdDeliveryMethodDesc = 'SHIRT_ORDER_BY_ORDER_ID__DELIVERY_METHOD_DESC',
  ShirtOrderByOrderIdIdAsc = 'SHIRT_ORDER_BY_ORDER_ID__ID_ASC',
  ShirtOrderByOrderIdIdDesc = 'SHIRT_ORDER_BY_ORDER_ID__ID_DESC',
  ShirtOrderByOrderIdMessageAsc = 'SHIRT_ORDER_BY_ORDER_ID__MESSAGE_ASC',
  ShirtOrderByOrderIdMessageDesc = 'SHIRT_ORDER_BY_ORDER_ID__MESSAGE_DESC',
  ShirtOrderByOrderIdUserIdAsc = 'SHIRT_ORDER_BY_ORDER_ID__USER_ID_ASC',
  ShirtOrderByOrderIdUserIdDesc = 'SHIRT_ORDER_BY_ORDER_ID__USER_ID_DESC',
  ShirtOrderByOrderIdYearAsc = 'SHIRT_ORDER_BY_ORDER_ID__YEAR_ASC',
  ShirtOrderByOrderIdYearDesc = 'SHIRT_ORDER_BY_ORDER_ID__YEAR_DESC',
  SizeAsc = 'SIZE_ASC',
  SizeDesc = 'SIZE_DESC',
  StyleAsc = 'STYLE_ASC',
  StyleDesc = 'STYLE_DESC',
}

/** Represents an update to a `ShirtOrder`. Fields that are set will be updated. */
export interface ShirtOrderPatch {
  deliveryMethod?: InputMaybe<Scalars['String']>
  id?: InputMaybe<Scalars['Int']>
  message?: InputMaybe<Scalars['String']>
  userId?: InputMaybe<Scalars['Int']>
  year?: InputMaybe<Scalars['Int']>
}

/** A connection to a list of `ShirtOrder` values. */
export interface ShirtOrdersConnection {
  __typename: 'ShirtOrdersConnection'
  /** A list of edges which contains the `ShirtOrder` and cursor to aid in pagination. */
  edges: Array<ShirtOrdersEdge>
  /** A list of `ShirtOrder` objects. */
  nodes: Array<Maybe<ShirtOrder>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `ShirtOrder` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `ShirtOrder` edge in the connection. */
export interface ShirtOrdersEdge {
  __typename: 'ShirtOrdersEdge'
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `ShirtOrder` at the end of the edge. */
  node?: Maybe<ShirtOrder>
}

/** Methods to use when ordering `ShirtOrder`. */
export enum ShirtOrdersOrderBy {
  DeliveryMethodAsc = 'DELIVERY_METHOD_ASC',
  DeliveryMethodDesc = 'DELIVERY_METHOD_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  MessageAsc = 'MESSAGE_ASC',
  MessageDesc = 'MESSAGE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ShirtOrderItemsByOrderIdCountAsc = 'SHIRT_ORDER_ITEMS_BY_ORDER_ID__COUNT_ASC',
  ShirtOrderItemsByOrderIdCountDesc = 'SHIRT_ORDER_ITEMS_BY_ORDER_ID__COUNT_DESC',
  UserByUserIdEmailAsc = 'USER_BY_USER_ID__EMAIL_ASC',
  UserByUserIdEmailDesc = 'USER_BY_USER_ID__EMAIL_DESC',
  UserByUserIdFirstNameAsc = 'USER_BY_USER_ID__FIRST_NAME_ASC',
  UserByUserIdFirstNameDesc = 'USER_BY_USER_ID__FIRST_NAME_DESC',
  UserByUserIdFullNameAsc = 'USER_BY_USER_ID__FULL_NAME_ASC',
  UserByUserIdFullNameDesc = 'USER_BY_USER_ID__FULL_NAME_DESC',
  UserByUserIdIdAsc = 'USER_BY_USER_ID__ID_ASC',
  UserByUserIdIdDesc = 'USER_BY_USER_ID__ID_DESC',
  UserByUserIdLastNameAsc = 'USER_BY_USER_ID__LAST_NAME_ASC',
  UserByUserIdLastNameDesc = 'USER_BY_USER_ID__LAST_NAME_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  YearAsc = 'YEAR_ASC',
  YearDesc = 'YEAR_DESC',
}

export interface Slot extends Node {
  __typename: 'Slot'
  day: Scalars['String']
  formattedDate: Scalars['String']
  /** Reads and enables pagination through a set of `GameChoice`. */
  gameChoices: GameChoicesConnection
  /** Reads and enables pagination through a set of `Game`. */
  games: GamesConnection
  id: Scalars['Int']
  length: Scalars['String']
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']
  slot: Scalars['Int']
  time: Scalars['String']
}

export interface SlotGameChoicesArgs {
  after?: InputMaybe<Scalars['Cursor']>
  before?: InputMaybe<Scalars['Cursor']>
  condition?: InputMaybe<GameChoiceCondition>
  filter?: InputMaybe<GameChoiceFilter>
  first?: InputMaybe<Scalars['Int']>
  last?: InputMaybe<Scalars['Int']>
  offset?: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<GameChoicesOrderBy>>
}

export interface SlotGamesArgs {
  after?: InputMaybe<Scalars['Cursor']>
  before?: InputMaybe<Scalars['Cursor']>
  condition?: InputMaybe<GameCondition>
  filter?: InputMaybe<GameFilter>
  first?: InputMaybe<Scalars['Int']>
  last?: InputMaybe<Scalars['Int']>
  offset?: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<GamesOrderBy>>
}

/** A condition to be used against `Slot` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export interface SlotCondition {
  /** Checks for equality with the object’s `day` field. */
  day?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `formattedDate` field. */
  formattedDate?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `length` field. */
  length?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `slot` field. */
  slot?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `time` field. */
  time?: InputMaybe<Scalars['String']>
}

/** A filter to be used against `Slot` object types. All fields are combined with a logical ‘and.’ */
export interface SlotFilter {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SlotFilter>>
  /** Filter by the object’s `day` field. */
  day?: InputMaybe<StringFilter>
  /** Filter by the object’s `formattedDate` field. */
  formattedDate?: InputMaybe<StringFilter>
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>
  /** Filter by the object’s `length` field. */
  length?: InputMaybe<StringFilter>
  /** Negates the expression. */
  not?: InputMaybe<SlotFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SlotFilter>>
  /** Filter by the object’s `slot` field. */
  slot?: InputMaybe<IntFilter>
  /** Filter by the object’s `time` field. */
  time?: InputMaybe<StringFilter>
}

/** All input for the `slotGmGame` mutation. */
export interface SlotGmGameInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  memberId?: InputMaybe<Scalars['Int']>
  slotId?: InputMaybe<Scalars['Int']>
  yearno?: InputMaybe<Scalars['Int']>
}

/** The output of our `slotGmGame` mutation. */
export interface SlotGmGamePayload {
  __typename: 'SlotGmGamePayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  integer?: Maybe<Scalars['Int']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
}

/** An input for mutations affecting `Slot` */
export interface SlotInput {
  day: Scalars['String']
  formattedDate: Scalars['String']
  id?: InputMaybe<Scalars['Int']>
  length: Scalars['String']
  slot: Scalars['Int']
  time: Scalars['String']
}

/** Represents an update to a `Slot`. Fields that are set will be updated. */
export interface SlotPatch {
  day?: InputMaybe<Scalars['String']>
  formattedDate?: InputMaybe<Scalars['String']>
  id?: InputMaybe<Scalars['Int']>
  length?: InputMaybe<Scalars['String']>
  slot?: InputMaybe<Scalars['Int']>
  time?: InputMaybe<Scalars['String']>
}

/** A connection to a list of `Slot` values. */
export interface SlotsConnection {
  __typename: 'SlotsConnection'
  /** A list of edges which contains the `Slot` and cursor to aid in pagination. */
  edges: Array<SlotsEdge>
  /** A list of `Slot` objects. */
  nodes: Array<Maybe<Slot>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Slot` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Slot` edge in the connection. */
export interface SlotsEdge {
  __typename: 'SlotsEdge'
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Slot` at the end of the edge. */
  node?: Maybe<Slot>
}

/** Methods to use when ordering `Slot`. */
export enum SlotsOrderBy {
  DayAsc = 'DAY_ASC',
  DayDesc = 'DAY_DESC',
  FormattedDateAsc = 'FORMATTED_DATE_ASC',
  FormattedDateDesc = 'FORMATTED_DATE_DESC',
  GamesBySlotIdCountAsc = 'GAMES_BY_SLOT_ID__COUNT_ASC',
  GamesBySlotIdCountDesc = 'GAMES_BY_SLOT_ID__COUNT_DESC',
  GameChoicesBySlotIdCountAsc = 'GAME_CHOICES_BY_SLOT_ID__COUNT_ASC',
  GameChoicesBySlotIdCountDesc = 'GAME_CHOICES_BY_SLOT_ID__COUNT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LengthAsc = 'LENGTH_ASC',
  LengthDesc = 'LENGTH_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SlotAsc = 'SLOT_ASC',
  SlotDesc = 'SLOT_DESC',
  TimeAsc = 'TIME_ASC',
  TimeDesc = 'TIME_DESC',
}

/** A filter to be used against String fields. All fields are combined with a logical ‘and.’ */
export interface StringFilter {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['String']>
  /** Not equal to the specified value, treating null like an ordinary value (case-insensitive). */
  distinctFromInsensitive?: InputMaybe<Scalars['String']>
  /** Ends with the specified string (case-sensitive). */
  endsWith?: InputMaybe<Scalars['String']>
  /** Ends with the specified string (case-insensitive). */
  endsWithInsensitive?: InputMaybe<Scalars['String']>
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['String']>
  /** Equal to the specified value (case-insensitive). */
  equalToInsensitive?: InputMaybe<Scalars['String']>
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['String']>
  /** Greater than the specified value (case-insensitive). */
  greaterThanInsensitive?: InputMaybe<Scalars['String']>
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['String']>
  /** Greater than or equal to the specified value (case-insensitive). */
  greaterThanOrEqualToInsensitive?: InputMaybe<Scalars['String']>
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['String']>>
  /** Included in the specified list (case-insensitive). */
  inInsensitive?: InputMaybe<Array<Scalars['String']>>
  /** Contains the specified string (case-sensitive). */
  includes?: InputMaybe<Scalars['String']>
  /** Contains the specified string (case-insensitive). */
  includesInsensitive?: InputMaybe<Scalars['String']>
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']>
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['String']>
  /** Less than the specified value (case-insensitive). */
  lessThanInsensitive?: InputMaybe<Scalars['String']>
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['String']>
  /** Less than or equal to the specified value (case-insensitive). */
  lessThanOrEqualToInsensitive?: InputMaybe<Scalars['String']>
  /** Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  like?: InputMaybe<Scalars['String']>
  /** Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  likeInsensitive?: InputMaybe<Scalars['String']>
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['String']>
  /** Equal to the specified value, treating null like an ordinary value (case-insensitive). */
  notDistinctFromInsensitive?: InputMaybe<Scalars['String']>
  /** Does not end with the specified string (case-sensitive). */
  notEndsWith?: InputMaybe<Scalars['String']>
  /** Does not end with the specified string (case-insensitive). */
  notEndsWithInsensitive?: InputMaybe<Scalars['String']>
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['String']>
  /** Not equal to the specified value (case-insensitive). */
  notEqualToInsensitive?: InputMaybe<Scalars['String']>
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['String']>>
  /** Not included in the specified list (case-insensitive). */
  notInInsensitive?: InputMaybe<Array<Scalars['String']>>
  /** Does not contain the specified string (case-sensitive). */
  notIncludes?: InputMaybe<Scalars['String']>
  /** Does not contain the specified string (case-insensitive). */
  notIncludesInsensitive?: InputMaybe<Scalars['String']>
  /** Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLike?: InputMaybe<Scalars['String']>
  /** Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLikeInsensitive?: InputMaybe<Scalars['String']>
  /** Does not start with the specified string (case-sensitive). */
  notStartsWith?: InputMaybe<Scalars['String']>
  /** Does not start with the specified string (case-insensitive). */
  notStartsWithInsensitive?: InputMaybe<Scalars['String']>
  /** Starts with the specified string (case-sensitive). */
  startsWith?: InputMaybe<Scalars['String']>
  /** Starts with the specified string (case-insensitive). */
  startsWithInsensitive?: InputMaybe<Scalars['String']>
}

/** All input for the `updateGameAssignmentByNodeId` mutation. */
export interface UpdateGameAssignmentByNodeIdInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `GameAssignment` to be updated. */
  nodeId: Scalars['ID']
  /** An object where the defined keys will be set on the `GameAssignment` being updated. */
  patch: GameAssignmentPatch
}

/** All input for the `updateGameAssignment` mutation. */
export interface UpdateGameAssignmentInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  gameId: Scalars['Int']
  gm: Scalars['Int']
  memberId: Scalars['Int']
  /** An object where the defined keys will be set on the `GameAssignment` being updated. */
  patch: GameAssignmentPatch
}

/** The output of our update `GameAssignment` mutation. */
export interface UpdateGameAssignmentPayload {
  __typename: 'UpdateGameAssignmentPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** Reads a single `Game` that is related to this `GameAssignment`. */
  game?: Maybe<Game>
  /** The `GameAssignment` that was updated by this mutation. */
  gameAssignment?: Maybe<GameAssignment>
  /** An edge for our `GameAssignment`. May be used by Relay 1. */
  gameAssignmentEdge?: Maybe<GameAssignmentsEdge>
  /** Reads a single `Membership` that is related to this `GameAssignment`. */
  member?: Maybe<Membership>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
}

/** The output of our update `GameAssignment` mutation. */
export interface UpdateGameAssignmentPayloadGameAssignmentEdgeArgs {
  orderBy?: InputMaybe<Array<GameAssignmentsOrderBy>>
}

/** All input for the `updateGameByNodeId` mutation. */
export interface UpdateGameByNodeIdInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `Game` to be updated. */
  nodeId: Scalars['ID']
  /** An object where the defined keys will be set on the `Game` being updated. */
  patch: GamePatch
}

/** All input for the `updateGameChoiceByNodeId` mutation. */
export interface UpdateGameChoiceByNodeIdInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `GameChoice` to be updated. */
  nodeId: Scalars['ID']
  /** An object where the defined keys will be set on the `GameChoice` being updated. */
  patch: GameChoicePatch
}

/** All input for the `updateGameChoice` mutation. */
export interface UpdateGameChoiceInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  id: Scalars['Int']
  /** An object where the defined keys will be set on the `GameChoice` being updated. */
  patch: GameChoicePatch
}

/** The output of our update `GameChoice` mutation. */
export interface UpdateGameChoicePayload {
  __typename: 'UpdateGameChoicePayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** Reads a single `Game` that is related to this `GameChoice`. */
  game?: Maybe<Game>
  /** The `GameChoice` that was updated by this mutation. */
  gameChoice?: Maybe<GameChoice>
  /** An edge for our `GameChoice`. May be used by Relay 1. */
  gameChoiceEdge?: Maybe<GameChoicesEdge>
  /** Reads a single `Membership` that is related to this `GameChoice`. */
  member?: Maybe<Membership>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `Slot` that is related to this `GameChoice`. */
  slot?: Maybe<Slot>
}

/** The output of our update `GameChoice` mutation. */
export interface UpdateGameChoicePayloadGameChoiceEdgeArgs {
  orderBy?: InputMaybe<Array<GameChoicesOrderBy>>
}

/** All input for the `updateGame` mutation. */
export interface UpdateGameInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  id: Scalars['Int']
  /** An object where the defined keys will be set on the `Game` being updated. */
  patch: GamePatch
}

/** The output of our update `Game` mutation. */
export interface UpdateGamePayload {
  __typename: 'UpdateGamePayload'
  /** Reads a single `User` that is related to this `Game`. */
  author?: Maybe<User>
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `Game` that was updated by this mutation. */
  game?: Maybe<Game>
  /** An edge for our `Game`. May be used by Relay 1. */
  gameEdge?: Maybe<GamesEdge>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `Room` that is related to this `Game`. */
  room?: Maybe<Room>
  /** Reads a single `Slot` that is related to this `Game`. */
  slot?: Maybe<Slot>
}

/** The output of our update `Game` mutation. */
export interface UpdateGamePayloadGameEdgeArgs {
  orderBy?: InputMaybe<Array<GamesOrderBy>>
}

/** All input for the `updateGameSubmissionByNodeId` mutation. */
export interface UpdateGameSubmissionByNodeIdInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `GameSubmission` to be updated. */
  nodeId: Scalars['ID']
  /** An object where the defined keys will be set on the `GameSubmission` being updated. */
  patch: GameSubmissionPatch
}

/** All input for the `updateGameSubmission` mutation. */
export interface UpdateGameSubmissionInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  id: Scalars['Int']
  /** An object where the defined keys will be set on the `GameSubmission` being updated. */
  patch: GameSubmissionPatch
}

/** The output of our update `GameSubmission` mutation. */
export interface UpdateGameSubmissionPayload {
  __typename: 'UpdateGameSubmissionPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `GameSubmission` that was updated by this mutation. */
  gameSubmission?: Maybe<GameSubmission>
  /** An edge for our `GameSubmission`. May be used by Relay 1. */
  gameSubmissionEdge?: Maybe<GameSubmissionsEdge>
  /** Reads a single `Membership` that is related to this `GameSubmission`. */
  member?: Maybe<Membership>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
}

/** The output of our update `GameSubmission` mutation. */
export interface UpdateGameSubmissionPayloadGameSubmissionEdgeArgs {
  orderBy?: InputMaybe<Array<GameSubmissionsOrderBy>>
}

/** All input for the `updateHotelRoomByNodeId` mutation. */
export interface UpdateHotelRoomByNodeIdInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `HotelRoom` to be updated. */
  nodeId: Scalars['ID']
  /** An object where the defined keys will be set on the `HotelRoom` being updated. */
  patch: HotelRoomPatch
}

/** All input for the `updateHotelRoomDetailByNodeId` mutation. */
export interface UpdateHotelRoomDetailByNodeIdInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `HotelRoomDetail` to be updated. */
  nodeId: Scalars['ID']
  /** An object where the defined keys will be set on the `HotelRoomDetail` being updated. */
  patch: HotelRoomDetailPatch
}

/** All input for the `updateHotelRoomDetail` mutation. */
export interface UpdateHotelRoomDetailInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  id: Scalars['BigInt']
  /** An object where the defined keys will be set on the `HotelRoomDetail` being updated. */
  patch: HotelRoomDetailPatch
}

/** The output of our update `HotelRoomDetail` mutation. */
export interface UpdateHotelRoomDetailPayload {
  __typename: 'UpdateHotelRoomDetailPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `HotelRoomDetail` that was updated by this mutation. */
  hotelRoomDetail?: Maybe<HotelRoomDetail>
  /** An edge for our `HotelRoomDetail`. May be used by Relay 1. */
  hotelRoomDetailEdge?: Maybe<HotelRoomDetailsEdge>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
}

/** The output of our update `HotelRoomDetail` mutation. */
export interface UpdateHotelRoomDetailPayloadHotelRoomDetailEdgeArgs {
  orderBy?: InputMaybe<Array<HotelRoomDetailsOrderBy>>
}

/** All input for the `updateHotelRoom` mutation. */
export interface UpdateHotelRoomInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  id: Scalars['Int']
  /** An object where the defined keys will be set on the `HotelRoom` being updated. */
  patch: HotelRoomPatch
}

/** The output of our update `HotelRoom` mutation. */
export interface UpdateHotelRoomPayload {
  __typename: 'UpdateHotelRoomPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `HotelRoom` that was updated by this mutation. */
  hotelRoom?: Maybe<HotelRoom>
  /** An edge for our `HotelRoom`. May be used by Relay 1. */
  hotelRoomEdge?: Maybe<HotelRoomsEdge>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
}

/** The output of our update `HotelRoom` mutation. */
export interface UpdateHotelRoomPayloadHotelRoomEdgeArgs {
  orderBy?: InputMaybe<Array<HotelRoomsOrderBy>>
}

/** All input for the `updateLookupByNodeId` mutation. */
export interface UpdateLookupByNodeIdInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `Lookup` to be updated. */
  nodeId: Scalars['ID']
  /** An object where the defined keys will be set on the `Lookup` being updated. */
  patch: LookupPatch
}

/** All input for the `updateLookupByRealm` mutation. */
export interface UpdateLookupByRealmInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** An object where the defined keys will be set on the `Lookup` being updated. */
  patch: LookupPatch
  realm: Scalars['String']
}

/** All input for the `updateLookup` mutation. */
export interface UpdateLookupInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  id: Scalars['Int']
  /** An object where the defined keys will be set on the `Lookup` being updated. */
  patch: LookupPatch
}

/** The output of our update `Lookup` mutation. */
export interface UpdateLookupPayload {
  __typename: 'UpdateLookupPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `Lookup` that was updated by this mutation. */
  lookup?: Maybe<Lookup>
  /** An edge for our `Lookup`. May be used by Relay 1. */
  lookupEdge?: Maybe<LookupsEdge>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
}

/** The output of our update `Lookup` mutation. */
export interface UpdateLookupPayloadLookupEdgeArgs {
  orderBy?: InputMaybe<Array<LookupsOrderBy>>
}

/** All input for the `updateLookupValueByLookupIdAndCode` mutation. */
export interface UpdateLookupValueByLookupIdAndCodeInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  code: Scalars['String']
  lookupId: Scalars['Int']
  /** An object where the defined keys will be set on the `LookupValue` being updated. */
  patch: LookupValuePatch
}

/** All input for the `updateLookupValueByNodeId` mutation. */
export interface UpdateLookupValueByNodeIdInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `LookupValue` to be updated. */
  nodeId: Scalars['ID']
  /** An object where the defined keys will be set on the `LookupValue` being updated. */
  patch: LookupValuePatch
}

/** All input for the `updateLookupValue` mutation. */
export interface UpdateLookupValueInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  id: Scalars['Int']
  /** An object where the defined keys will be set on the `LookupValue` being updated. */
  patch: LookupValuePatch
}

/** The output of our update `LookupValue` mutation. */
export interface UpdateLookupValuePayload {
  __typename: 'UpdateLookupValuePayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** Reads a single `Lookup` that is related to this `LookupValue`. */
  lookup?: Maybe<Lookup>
  /** The `LookupValue` that was updated by this mutation. */
  lookupValue?: Maybe<LookupValue>
  /** An edge for our `LookupValue`. May be used by Relay 1. */
  lookupValueEdge?: Maybe<LookupValuesEdge>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
}

/** The output of our update `LookupValue` mutation. */
export interface UpdateLookupValuePayloadLookupValueEdgeArgs {
  orderBy?: InputMaybe<Array<LookupValuesOrderBy>>
}

/** All input for the `updateMembershipByNodeId` mutation. */
export interface UpdateMembershipByNodeIdInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `Membership` to be updated. */
  nodeId: Scalars['ID']
  /** An object where the defined keys will be set on the `Membership` being updated. */
  patch: MembershipPatch
}

/** All input for the `updateMembership` mutation. */
export interface UpdateMembershipInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  id: Scalars['Int']
  /** An object where the defined keys will be set on the `Membership` being updated. */
  patch: MembershipPatch
}

/** The output of our update `Membership` mutation. */
export interface UpdateMembershipPayload {
  __typename: 'UpdateMembershipPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** Reads a single `HotelRoom` that is related to this `Membership`. */
  hotelRoom?: Maybe<HotelRoom>
  /** The `Membership` that was updated by this mutation. */
  membership?: Maybe<Membership>
  /** An edge for our `Membership`. May be used by Relay 1. */
  membershipEdge?: Maybe<MembershipsEdge>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `User` that is related to this `Membership`. */
  user?: Maybe<User>
}

/** The output of our update `Membership` mutation. */
export interface UpdateMembershipPayloadMembershipEdgeArgs {
  orderBy?: InputMaybe<Array<MembershipsOrderBy>>
}

/** All input for the `updateProfileByNodeId` mutation. */
export interface UpdateProfileByNodeIdInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `Profile` to be updated. */
  nodeId: Scalars['ID']
  /** An object where the defined keys will be set on the `Profile` being updated. */
  patch: ProfilePatch
}

/** All input for the `updateProfile` mutation. */
export interface UpdateProfileInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  id: Scalars['Int']
  /** An object where the defined keys will be set on the `Profile` being updated. */
  patch: ProfilePatch
}

/** The output of our update `Profile` mutation. */
export interface UpdateProfilePayload {
  __typename: 'UpdateProfilePayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `Profile` that was updated by this mutation. */
  profile?: Maybe<Profile>
  /** An edge for our `Profile`. May be used by Relay 1. */
  profileEdge?: Maybe<ProfilesEdge>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `User` that is related to this `Profile`. */
  user?: Maybe<User>
}

/** The output of our update `Profile` mutation. */
export interface UpdateProfilePayloadProfileEdgeArgs {
  orderBy?: InputMaybe<Array<ProfilesOrderBy>>
}

/** All input for the `updateRoleByAuthority` mutation. */
export interface UpdateRoleByAuthorityInput {
  authority: Scalars['String']
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** An object where the defined keys will be set on the `Role` being updated. */
  patch: RolePatch
}

/** All input for the `updateRoleByNodeId` mutation. */
export interface UpdateRoleByNodeIdInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `Role` to be updated. */
  nodeId: Scalars['ID']
  /** An object where the defined keys will be set on the `Role` being updated. */
  patch: RolePatch
}

/** All input for the `updateRole` mutation. */
export interface UpdateRoleInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  id: Scalars['Int']
  /** An object where the defined keys will be set on the `Role` being updated. */
  patch: RolePatch
}

/** The output of our update `Role` mutation. */
export interface UpdateRolePayload {
  __typename: 'UpdateRolePayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** The `Role` that was updated by this mutation. */
  role?: Maybe<Role>
  /** An edge for our `Role`. May be used by Relay 1. */
  roleEdge?: Maybe<RolesEdge>
}

/** The output of our update `Role` mutation. */
export interface UpdateRolePayloadRoleEdgeArgs {
  orderBy?: InputMaybe<Array<RolesOrderBy>>
}

/** All input for the `updateRoomByNodeId` mutation. */
export interface UpdateRoomByNodeIdInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `Room` to be updated. */
  nodeId: Scalars['ID']
  /** An object where the defined keys will be set on the `Room` being updated. */
  patch: RoomPatch
}

/** All input for the `updateRoom` mutation. */
export interface UpdateRoomInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  id: Scalars['Int']
  /** An object where the defined keys will be set on the `Room` being updated. */
  patch: RoomPatch
}

/** The output of our update `Room` mutation. */
export interface UpdateRoomPayload {
  __typename: 'UpdateRoomPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** The `Room` that was updated by this mutation. */
  room?: Maybe<Room>
  /** An edge for our `Room`. May be used by Relay 1. */
  roomEdge?: Maybe<RoomsEdge>
}

/** The output of our update `Room` mutation. */
export interface UpdateRoomPayloadRoomEdgeArgs {
  orderBy?: InputMaybe<Array<RoomsOrderBy>>
}

/** All input for the `updateSettingByNodeId` mutation. */
export interface UpdateSettingByNodeIdInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `Setting` to be updated. */
  nodeId: Scalars['ID']
  /** An object where the defined keys will be set on the `Setting` being updated. */
  patch: SettingPatch
}

/** All input for the `updateSetting` mutation. */
export interface UpdateSettingInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  id: Scalars['Int']
  /** An object where the defined keys will be set on the `Setting` being updated. */
  patch: SettingPatch
}

/** The output of our update `Setting` mutation. */
export interface UpdateSettingPayload {
  __typename: 'UpdateSettingPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** The `Setting` that was updated by this mutation. */
  setting?: Maybe<Setting>
  /** An edge for our `Setting`. May be used by Relay 1. */
  settingEdge?: Maybe<SettingsEdge>
}

/** The output of our update `Setting` mutation. */
export interface UpdateSettingPayloadSettingEdgeArgs {
  orderBy?: InputMaybe<Array<SettingsOrderBy>>
}

/** All input for the `updateShirtOrderByNodeId` mutation. */
export interface UpdateShirtOrderByNodeIdInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `ShirtOrder` to be updated. */
  nodeId: Scalars['ID']
  /** An object where the defined keys will be set on the `ShirtOrder` being updated. */
  patch: ShirtOrderPatch
}

/** All input for the `updateShirtOrder` mutation. */
export interface UpdateShirtOrderInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  id: Scalars['Int']
  /** An object where the defined keys will be set on the `ShirtOrder` being updated. */
  patch: ShirtOrderPatch
}

/** All input for the `updateShirtOrderItemByNodeId` mutation. */
export interface UpdateShirtOrderItemByNodeIdInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `ShirtOrderItem` to be updated. */
  nodeId: Scalars['ID']
  /** An object where the defined keys will be set on the `ShirtOrderItem` being updated. */
  patch: ShirtOrderItemPatch
}

/** All input for the `updateShirtOrderItem` mutation. */
export interface UpdateShirtOrderItemInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  id: Scalars['Int']
  /** An object where the defined keys will be set on the `ShirtOrderItem` being updated. */
  patch: ShirtOrderItemPatch
}

/** The output of our update `ShirtOrderItem` mutation. */
export interface UpdateShirtOrderItemPayload {
  __typename: 'UpdateShirtOrderItemPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** Reads a single `ShirtOrder` that is related to this `ShirtOrderItem`. */
  order?: Maybe<ShirtOrder>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** The `ShirtOrderItem` that was updated by this mutation. */
  shirtOrderItem?: Maybe<ShirtOrderItem>
  /** An edge for our `ShirtOrderItem`. May be used by Relay 1. */
  shirtOrderItemEdge?: Maybe<ShirtOrderItemsEdge>
}

/** The output of our update `ShirtOrderItem` mutation. */
export interface UpdateShirtOrderItemPayloadShirtOrderItemEdgeArgs {
  orderBy?: InputMaybe<Array<ShirtOrderItemsOrderBy>>
}

/** The output of our update `ShirtOrder` mutation. */
export interface UpdateShirtOrderPayload {
  __typename: 'UpdateShirtOrderPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** The `ShirtOrder` that was updated by this mutation. */
  shirtOrder?: Maybe<ShirtOrder>
  /** An edge for our `ShirtOrder`. May be used by Relay 1. */
  shirtOrderEdge?: Maybe<ShirtOrdersEdge>
  /** Reads a single `User` that is related to this `ShirtOrder`. */
  user?: Maybe<User>
}

/** The output of our update `ShirtOrder` mutation. */
export interface UpdateShirtOrderPayloadShirtOrderEdgeArgs {
  orderBy?: InputMaybe<Array<ShirtOrdersOrderBy>>
}

/** All input for the `updateSlotByNodeId` mutation. */
export interface UpdateSlotByNodeIdInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `Slot` to be updated. */
  nodeId: Scalars['ID']
  /** An object where the defined keys will be set on the `Slot` being updated. */
  patch: SlotPatch
}

/** All input for the `updateSlot` mutation. */
export interface UpdateSlotInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  id: Scalars['Int']
  /** An object where the defined keys will be set on the `Slot` being updated. */
  patch: SlotPatch
}

/** The output of our update `Slot` mutation. */
export interface UpdateSlotPayload {
  __typename: 'UpdateSlotPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** The `Slot` that was updated by this mutation. */
  slot?: Maybe<Slot>
  /** An edge for our `Slot`. May be used by Relay 1. */
  slotEdge?: Maybe<SlotsEdge>
}

/** The output of our update `Slot` mutation. */
export interface UpdateSlotPayloadSlotEdgeArgs {
  orderBy?: InputMaybe<Array<SlotsOrderBy>>
}

/** All input for the `updateUserByEmail` mutation. */
export interface UpdateUserByEmailInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  email: Scalars['String']
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch
}

/** All input for the `updateUserByNodeId` mutation. */
export interface UpdateUserByNodeIdInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `User` to be updated. */
  nodeId: Scalars['ID']
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch
}

/** All input for the `updateUser` mutation. */
export interface UpdateUserInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  id: Scalars['Int']
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch
}

/** The output of our update `User` mutation. */
export interface UpdateUserPayload {
  __typename: 'UpdateUserPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** The `User` that was updated by this mutation. */
  user?: Maybe<User>
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>
}

/** The output of our update `User` mutation. */
export interface UpdateUserPayloadUserEdgeArgs {
  orderBy?: InputMaybe<Array<UsersOrderBy>>
}

/** All input for the `updateUserRoleByNodeId` mutation. */
export interface UpdateUserRoleByNodeIdInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `UserRole` to be updated. */
  nodeId: Scalars['ID']
  /** An object where the defined keys will be set on the `UserRole` being updated. */
  patch: UserRolePatch
}

/** All input for the `updateUserRole` mutation. */
export interface UpdateUserRoleInput {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** An object where the defined keys will be set on the `UserRole` being updated. */
  patch: UserRolePatch
  roleId: Scalars['Int']
  userId: Scalars['Int']
}

/** The output of our update `UserRole` mutation. */
export interface UpdateUserRolePayload {
  __typename: 'UpdateUserRolePayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `Role` that is related to this `UserRole`. */
  role?: Maybe<Role>
  /** Reads a single `User` that is related to this `UserRole`. */
  user?: Maybe<User>
  /** The `UserRole` that was updated by this mutation. */
  userRole?: Maybe<UserRole>
  /** An edge for our `UserRole`. May be used by Relay 1. */
  userRoleEdge?: Maybe<UserRolesEdge>
}

/** The output of our update `UserRole` mutation. */
export interface UpdateUserRolePayloadUserRoleEdgeArgs {
  orderBy?: InputMaybe<Array<UserRolesOrderBy>>
}

export interface User extends Node {
  __typename: 'User'
  /** Reads and enables pagination through a set of `Game`. */
  authoredGames: GamesConnection
  email: Scalars['String']
  firstName?: Maybe<Scalars['String']>
  fullName?: Maybe<Scalars['String']>
  id: Scalars['Int']
  lastName?: Maybe<Scalars['String']>
  /** Reads and enables pagination through a set of `Membership`. */
  memberships: MembershipsConnection
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']
  /** Reads and enables pagination through a set of `Profile`. */
  profiles: ProfilesConnection
  /** Reads and enables pagination through a set of `ShirtOrder`. */
  shirtOrders: ShirtOrdersConnection
  /** Reads and enables pagination through a set of `UserRole`. */
  userRoles: UserRolesConnection
}

export interface UserAuthoredGamesArgs {
  after?: InputMaybe<Scalars['Cursor']>
  before?: InputMaybe<Scalars['Cursor']>
  condition?: InputMaybe<GameCondition>
  filter?: InputMaybe<GameFilter>
  first?: InputMaybe<Scalars['Int']>
  last?: InputMaybe<Scalars['Int']>
  offset?: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<GamesOrderBy>>
}

export interface UserMembershipsArgs {
  after?: InputMaybe<Scalars['Cursor']>
  before?: InputMaybe<Scalars['Cursor']>
  condition?: InputMaybe<MembershipCondition>
  filter?: InputMaybe<MembershipFilter>
  first?: InputMaybe<Scalars['Int']>
  last?: InputMaybe<Scalars['Int']>
  offset?: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<MembershipsOrderBy>>
}

export interface UserProfilesArgs {
  after?: InputMaybe<Scalars['Cursor']>
  before?: InputMaybe<Scalars['Cursor']>
  condition?: InputMaybe<ProfileCondition>
  filter?: InputMaybe<ProfileFilter>
  first?: InputMaybe<Scalars['Int']>
  last?: InputMaybe<Scalars['Int']>
  offset?: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ProfilesOrderBy>>
}

export interface UserShirtOrdersArgs {
  after?: InputMaybe<Scalars['Cursor']>
  before?: InputMaybe<Scalars['Cursor']>
  condition?: InputMaybe<ShirtOrderCondition>
  filter?: InputMaybe<ShirtOrderFilter>
  first?: InputMaybe<Scalars['Int']>
  last?: InputMaybe<Scalars['Int']>
  offset?: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<ShirtOrdersOrderBy>>
}

export interface UserUserRolesArgs {
  after?: InputMaybe<Scalars['Cursor']>
  before?: InputMaybe<Scalars['Cursor']>
  condition?: InputMaybe<UserRoleCondition>
  filter?: InputMaybe<UserRoleFilter>
  first?: InputMaybe<Scalars['Int']>
  last?: InputMaybe<Scalars['Int']>
  offset?: InputMaybe<Scalars['Int']>
  orderBy?: InputMaybe<Array<UserRolesOrderBy>>
}

/** A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export interface UserCondition {
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `firstName` field. */
  firstName?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `fullName` field. */
  fullName?: InputMaybe<Scalars['String']>
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `lastName` field. */
  lastName?: InputMaybe<Scalars['String']>
}

/** A filter to be used against `User` object types. All fields are combined with a logical ‘and.’ */
export interface UserFilter {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<UserFilter>>
  /** Filter by the object’s `email` field. */
  email?: InputMaybe<StringFilter>
  /** Filter by the object’s `firstName` field. */
  firstName?: InputMaybe<StringFilter>
  /** Filter by the object’s `fullName` field. */
  fullName?: InputMaybe<StringFilter>
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>
  /** Filter by the object’s `lastName` field. */
  lastName?: InputMaybe<StringFilter>
  /** Negates the expression. */
  not?: InputMaybe<UserFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<UserFilter>>
}

/** An input for mutations affecting `User` */
export interface UserInput {
  email: Scalars['String']
  firstName?: InputMaybe<Scalars['String']>
  fullName?: InputMaybe<Scalars['String']>
  id?: InputMaybe<Scalars['Int']>
  lastName?: InputMaybe<Scalars['String']>
}

/** Represents an update to a `User`. Fields that are set will be updated. */
export interface UserPatch {
  email?: InputMaybe<Scalars['String']>
  firstName?: InputMaybe<Scalars['String']>
  fullName?: InputMaybe<Scalars['String']>
  id?: InputMaybe<Scalars['Int']>
  lastName?: InputMaybe<Scalars['String']>
}

export interface UserRole extends Node {
  __typename: 'UserRole'
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']
  /** Reads a single `Role` that is related to this `UserRole`. */
  role?: Maybe<Role>
  roleId: Scalars['Int']
  /** Reads a single `User` that is related to this `UserRole`. */
  user?: Maybe<User>
  userId: Scalars['Int']
}

/**
 * A condition to be used against `UserRole` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export interface UserRoleCondition {
  /** Checks for equality with the object’s `roleId` field. */
  roleId?: InputMaybe<Scalars['Int']>
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']>
}

/** A filter to be used against `UserRole` object types. All fields are combined with a logical ‘and.’ */
export interface UserRoleFilter {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<UserRoleFilter>>
  /** Negates the expression. */
  not?: InputMaybe<UserRoleFilter>
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<UserRoleFilter>>
  /** Filter by the object’s `roleId` field. */
  roleId?: InputMaybe<IntFilter>
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>
}

/** An input for mutations affecting `UserRole` */
export interface UserRoleInput {
  roleId: Scalars['Int']
  userId: Scalars['Int']
}

/** Represents an update to a `UserRole`. Fields that are set will be updated. */
export interface UserRolePatch {
  roleId?: InputMaybe<Scalars['Int']>
  userId?: InputMaybe<Scalars['Int']>
}

/** A connection to a list of `UserRole` values. */
export interface UserRolesConnection {
  __typename: 'UserRolesConnection'
  /** A list of edges which contains the `UserRole` and cursor to aid in pagination. */
  edges: Array<UserRolesEdge>
  /** A list of `UserRole` objects. */
  nodes: Array<Maybe<UserRole>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `UserRole` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `UserRole` edge in the connection. */
export interface UserRolesEdge {
  __typename: 'UserRolesEdge'
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `UserRole` at the end of the edge. */
  node?: Maybe<UserRole>
}

/** Methods to use when ordering `UserRole`. */
export enum UserRolesOrderBy {
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RoleByRoleIdAuthorityAsc = 'ROLE_BY_ROLE_ID__AUTHORITY_ASC',
  RoleByRoleIdAuthorityDesc = 'ROLE_BY_ROLE_ID__AUTHORITY_DESC',
  RoleByRoleIdIdAsc = 'ROLE_BY_ROLE_ID__ID_ASC',
  RoleByRoleIdIdDesc = 'ROLE_BY_ROLE_ID__ID_DESC',
  RoleIdAsc = 'ROLE_ID_ASC',
  RoleIdDesc = 'ROLE_ID_DESC',
  UserByUserIdEmailAsc = 'USER_BY_USER_ID__EMAIL_ASC',
  UserByUserIdEmailDesc = 'USER_BY_USER_ID__EMAIL_DESC',
  UserByUserIdFirstNameAsc = 'USER_BY_USER_ID__FIRST_NAME_ASC',
  UserByUserIdFirstNameDesc = 'USER_BY_USER_ID__FIRST_NAME_DESC',
  UserByUserIdFullNameAsc = 'USER_BY_USER_ID__FULL_NAME_ASC',
  UserByUserIdFullNameDesc = 'USER_BY_USER_ID__FULL_NAME_DESC',
  UserByUserIdIdAsc = 'USER_BY_USER_ID__ID_ASC',
  UserByUserIdIdDesc = 'USER_BY_USER_ID__ID_DESC',
  UserByUserIdLastNameAsc = 'USER_BY_USER_ID__LAST_NAME_ASC',
  UserByUserIdLastNameDesc = 'USER_BY_USER_ID__LAST_NAME_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
}

/** A connection to a list of `User` values. */
export interface UsersConnection {
  __typename: 'UsersConnection'
  /** A list of edges which contains the `User` and cursor to aid in pagination. */
  edges: Array<UsersEdge>
  /** A list of `User` objects. */
  nodes: Array<Maybe<User>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `User` edge in the connection. */
export interface UsersEdge {
  __typename: 'UsersEdge'
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `User` at the end of the edge. */
  node?: Maybe<User>
}

/** Methods to use when ordering `User`. */
export enum UsersOrderBy {
  EmailAsc = 'EMAIL_ASC',
  EmailDesc = 'EMAIL_DESC',
  FirstNameAsc = 'FIRST_NAME_ASC',
  FirstNameDesc = 'FIRST_NAME_DESC',
  FullNameAsc = 'FULL_NAME_ASC',
  FullNameDesc = 'FULL_NAME_DESC',
  GamesByAuthorIdCountAsc = 'GAMES_BY_AUTHOR_ID__COUNT_ASC',
  GamesByAuthorIdCountDesc = 'GAMES_BY_AUTHOR_ID__COUNT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LastNameAsc = 'LAST_NAME_ASC',
  LastNameDesc = 'LAST_NAME_DESC',
  MembershipsByUserIdCountAsc = 'MEMBERSHIPS_BY_USER_ID__COUNT_ASC',
  MembershipsByUserIdCountDesc = 'MEMBERSHIPS_BY_USER_ID__COUNT_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ProfilesByUserIdCountAsc = 'PROFILES_BY_USER_ID__COUNT_ASC',
  ProfilesByUserIdCountDesc = 'PROFILES_BY_USER_ID__COUNT_DESC',
  ShirtOrdersByUserIdCountAsc = 'SHIRT_ORDERS_BY_USER_ID__COUNT_ASC',
  ShirtOrdersByUserIdCountDesc = 'SHIRT_ORDERS_BY_USER_ID__COUNT_DESC',
  UserRolesByUserIdCountAsc = 'USER_ROLES_BY_USER_ID__COUNT_ASC',
  UserRolesByUserIdCountDesc = 'USER_ROLES_BY_USER_ID__COUNT_DESC',
}

export type GetGamesBySlotForSignupQueryVariables = Exact<{
  year: Scalars['Int']
  slotId: Scalars['Int']
}>

export type GetGamesBySlotForSignupQuery = {
  __typename: 'Query'
  games?: {
    __typename: 'GamesConnection'
    edges: Array<{
      __typename: 'GamesEdge'
      node?: {
        __typename: 'Game'
        nodeId: string
        id: number
        name: string
        gmNames?: string | null
        description: string
        genre: string
        type: string
        setting: string
        charInstructions: string
        playerMax: number
        playerMin: number
        playerPreference: string
        returningPlayers: string
        playersContactGm: boolean
        gameContactEmail: string
        estimatedLength: string
        slotPreference: number
        lateStart?: string | null
        lateFinish?: boolean | null
        slotConflicts: string
        message: string
        slotId?: number | null
        teenFriendly: boolean
        year: number
        full?: boolean | null
        roomId?: number | null
        room?: { __typename: 'Room'; description: string } | null
        gameAssignments: {
          __typename: 'GameAssignmentsConnection'
          nodes: Array<{
            __typename: 'GameAssignment'
            gameId: number
            gm: number
            memberId: number
            nodeId: string
            year: number
            member?: {
              __typename: 'Membership'
              user?: { __typename: 'User'; email: string; fullName?: string | null } | null
            } | null
          } | null>
        }
      } | null
    }>
  } | null
}

export type GetGamesBySlotQueryVariables = Exact<{
  year: Scalars['Int']
  slotId: Scalars['Int']
}>

export type GetGamesBySlotQuery = {
  __typename: 'Query'
  games?: {
    __typename: 'GamesConnection'
    edges: Array<{
      __typename: 'GamesEdge'
      node?: {
        __typename: 'Game'
        nodeId: string
        id: number
        name: string
        gmNames?: string | null
        description: string
        genre: string
        type: string
        setting: string
        charInstructions: string
        playerMax: number
        playerMin: number
        playerPreference: string
        returningPlayers: string
        playersContactGm: boolean
        gameContactEmail: string
        estimatedLength: string
        slotPreference: number
        lateStart?: string | null
        lateFinish?: boolean | null
        slotConflicts: string
        message: string
        slotId?: number | null
        teenFriendly: boolean
        year: number
        full?: boolean | null
        roomId?: number | null
        room?: { __typename: 'Room'; description: string } | null
        gameAssignments: {
          __typename: 'GameAssignmentsConnection'
          nodes: Array<{
            __typename: 'GameAssignment'
            gameId: number
            gm: number
            memberId: number
            nodeId: string
            year: number
            member?: {
              __typename: 'Membership'
              user?: { __typename: 'User'; email: string; fullName?: string | null } | null
            } | null
          } | null>
        }
      } | null
    }>
  } | null
}

export type GetGamesByYearQueryVariables = Exact<{
  year: Scalars['Int']
}>

export type GetGamesByYearQuery = {
  __typename: 'Query'
  games?: {
    __typename: 'GamesConnection'
    edges: Array<{
      __typename: 'GamesEdge'
      node?: {
        __typename: 'Game'
        nodeId: string
        id: number
        name: string
        gmNames?: string | null
        description: string
        genre: string
        type: string
        setting: string
        charInstructions: string
        playerMax: number
        playerMin: number
        playerPreference: string
        returningPlayers: string
        playersContactGm: boolean
        gameContactEmail: string
        estimatedLength: string
        slotPreference: number
        lateStart?: string | null
        lateFinish?: boolean | null
        slotConflicts: string
        message: string
        slotId?: number | null
        teenFriendly: boolean
        year: number
        full?: boolean | null
        roomId?: number | null
        room?: {
          __typename: 'Room'
          description: string
          id: number
          size: number
          type: string
          updated: boolean
        } | null
        gameAssignments: {
          __typename: 'GameAssignmentsConnection'
          nodes: Array<{
            __typename: 'GameAssignment'
            gameId: number
            gm: number
            memberId: number
            nodeId: string
            year: number
            member?: {
              __typename: 'Membership'
              user?: { __typename: 'User'; email: string; fullName?: string | null } | null
            } | null
          } | null>
        }
      } | null
    }>
  } | null
}

export type GetSmallGamesByYearQueryVariables = Exact<{
  year: Scalars['Int']
}>

export type GetSmallGamesByYearQuery = {
  __typename: 'Query'
  games?: {
    __typename: 'GamesConnection'
    edges: Array<{
      __typename: 'GamesEdge'
      node?: {
        __typename: 'Game'
        nodeId: string
        id: number
        name: string
        gmNames?: string | null
        description: string
        genre: string
        type: string
        setting: string
        charInstructions: string
        playerMax: number
        playerMin: number
        playerPreference: string
        returningPlayers: string
        playersContactGm: boolean
        gameContactEmail: string
        estimatedLength: string
        slotPreference: number
        lateStart?: string | null
        lateFinish?: boolean | null
        slotConflicts: string
        message: string
        slotId?: number | null
        teenFriendly: boolean
        year: number
        full?: boolean | null
        roomId?: number | null
        room?: { __typename: 'Room'; description: string } | null
        gameAssignments: {
          __typename: 'GameAssignmentsConnection'
          nodes: Array<{
            __typename: 'GameAssignment'
            gameId: number
            gm: number
            memberId: number
            nodeId: string
            year: number
            member?: {
              __typename: 'Membership'
              user?: { __typename: 'User'; email: string; fullName?: string | null } | null
            } | null
          } | null>
        }
      } | null
    }>
  } | null
}

export type UpdateGameByNodeIdMutationVariables = Exact<{
  input: UpdateGameByNodeIdInput
}>

export type UpdateGameByNodeIdMutation = {
  __typename: 'Mutation'
  updateGameByNodeId?: {
    __typename: 'UpdateGamePayload'
    game?: {
      __typename: 'Game'
      nodeId: string
      id: number
      name: string
      gmNames?: string | null
      description: string
      genre: string
      type: string
      setting: string
      charInstructions: string
      playerMax: number
      playerMin: number
      playerPreference: string
      returningPlayers: string
      playersContactGm: boolean
      gameContactEmail: string
      estimatedLength: string
      slotPreference: number
      lateStart?: string | null
      lateFinish?: boolean | null
      slotConflicts: string
      message: string
      slotId?: number | null
      teenFriendly: boolean
      year: number
      full?: boolean | null
      roomId?: number | null
      room?: { __typename: 'Room'; description: string } | null
      gameAssignments: {
        __typename: 'GameAssignmentsConnection'
        nodes: Array<{
          __typename: 'GameAssignment'
          gameId: number
          gm: number
          memberId: number
          nodeId: string
          year: number
          member?: {
            __typename: 'Membership'
            user?: { __typename: 'User'; email: string; fullName?: string | null } | null
          } | null
        } | null>
      }
    } | null
  } | null
}

export type UpdateGameMutationVariables = Exact<{
  input: UpdateGameInput
}>

export type UpdateGameMutation = {
  __typename: 'Mutation'
  updateGame?: {
    __typename: 'UpdateGamePayload'
    game?: {
      __typename: 'Game'
      nodeId: string
      id: number
      name: string
      gmNames?: string | null
      description: string
      genre: string
      type: string
      setting: string
      charInstructions: string
      playerMax: number
      playerMin: number
      playerPreference: string
      returningPlayers: string
      playersContactGm: boolean
      gameContactEmail: string
      estimatedLength: string
      slotPreference: number
      lateStart?: string | null
      lateFinish?: boolean | null
      slotConflicts: string
      message: string
      slotId?: number | null
      teenFriendly: boolean
      year: number
      full?: boolean | null
      roomId?: number | null
      room?: { __typename: 'Room'; description: string } | null
      gameAssignments: {
        __typename: 'GameAssignmentsConnection'
        nodes: Array<{
          __typename: 'GameAssignment'
          gameId: number
          gm: number
          memberId: number
          nodeId: string
          year: number
          member?: {
            __typename: 'Membership'
            user?: { __typename: 'User'; email: string; fullName?: string | null } | null
          } | null
        } | null>
      }
    } | null
  } | null
}

export type CreateGameMutationVariables = Exact<{
  input: CreateGameInput
}>

export type CreateGameMutation = {
  __typename: 'Mutation'
  createGame?: {
    __typename: 'CreateGamePayload'
    game?: {
      __typename: 'Game'
      nodeId: string
      id: number
      name: string
      gmNames?: string | null
      description: string
      genre: string
      type: string
      setting: string
      charInstructions: string
      playerMax: number
      playerMin: number
      playerPreference: string
      returningPlayers: string
      playersContactGm: boolean
      gameContactEmail: string
      estimatedLength: string
      slotPreference: number
      lateStart?: string | null
      lateFinish?: boolean | null
      slotConflicts: string
      message: string
      slotId?: number | null
      teenFriendly: boolean
      year: number
      full?: boolean | null
      roomId?: number | null
      room?: { __typename: 'Room'; description: string } | null
      gameAssignments: {
        __typename: 'GameAssignmentsConnection'
        nodes: Array<{
          __typename: 'GameAssignment'
          gameId: number
          gm: number
          memberId: number
          nodeId: string
          year: number
          member?: {
            __typename: 'Membership'
            user?: { __typename: 'User'; email: string; fullName?: string | null } | null
          } | null
        } | null>
      }
    } | null
  } | null
}

export type DeleteGameMutationVariables = Exact<{
  input: DeleteGameInput
}>

export type DeleteGameMutation = {
  __typename: 'Mutation'
  deleteGame?: {
    __typename: 'DeleteGamePayload'
    clientMutationId?: string | null
    deletedGameNodeId?: string | null
  } | null
}

export type GetFirstGameOfSlotQueryVariables = Exact<{
  year: Scalars['Int']
}>

export type GetFirstGameOfSlotQuery = {
  __typename: 'Query'
  games?: {
    __typename: 'GamesConnection'
    nodes: Array<{
      __typename: 'Game'
      nodeId: string
      id: number
      name: string
      gmNames?: string | null
      description: string
      genre: string
      type: string
      setting: string
      charInstructions: string
      playerMax: number
      playerMin: number
      playerPreference: string
      returningPlayers: string
      playersContactGm: boolean
      gameContactEmail: string
      estimatedLength: string
      slotPreference: number
      lateStart?: string | null
      lateFinish?: boolean | null
      slotConflicts: string
      message: string
      slotId?: number | null
      teenFriendly: boolean
      year: number
      full?: boolean | null
      roomId?: number | null
      gameAssignments: {
        __typename: 'GameAssignmentsConnection'
        nodes: Array<{
          __typename: 'GameAssignment'
          nodeId: string
          gm: number
          member?: {
            __typename: 'Membership'
            user?: { __typename: 'User'; email: string; fullName?: string | null } | null
          } | null
        } | null>
      }
      room?: { __typename: 'Room'; description: string } | null
    } | null>
  } | null
}

export type GetGamesByAuthorQueryVariables = Exact<{
  id: Scalars['Int']
}>

export type GetGamesByAuthorQuery = {
  __typename: 'Query'
  user?: {
    __typename: 'User'
    authoredGames: {
      __typename: 'GamesConnection'
      nodes: Array<{
        __typename: 'Game'
        nodeId: string
        id: number
        name: string
        gmNames?: string | null
        description: string
        genre: string
        type: string
        setting: string
        charInstructions: string
        playerMax: number
        playerMin: number
        playerPreference: string
        returningPlayers: string
        playersContactGm: boolean
        gameContactEmail: string
        estimatedLength: string
        slotPreference: number
        lateStart?: string | null
        lateFinish?: boolean | null
        slotConflicts: string
        message: string
        slotId?: number | null
        teenFriendly: boolean
        year: number
        full?: boolean | null
        roomId?: number | null
        room?: { __typename: 'Room'; description: string } | null
        gameAssignments: {
          __typename: 'GameAssignmentsConnection'
          nodes: Array<{
            __typename: 'GameAssignment'
            gameId: number
            gm: number
            memberId: number
            nodeId: string
            year: number
            member?: {
              __typename: 'Membership'
              user?: { __typename: 'User'; email: string; fullName?: string | null } | null
            } | null
          } | null>
        }
      } | null>
    }
  } | null
}

export type GetGamesByYearAndAuthorQueryVariables = Exact<{
  year: Scalars['Int']
  id: Scalars['Int']
}>

export type GetGamesByYearAndAuthorQuery = {
  __typename: 'Query'
  games?: {
    __typename: 'GamesConnection'
    nodes: Array<{
      __typename: 'Game'
      nodeId: string
      id: number
      name: string
      gmNames?: string | null
      description: string
      genre: string
      type: string
      setting: string
      charInstructions: string
      playerMax: number
      playerMin: number
      playerPreference: string
      returningPlayers: string
      playersContactGm: boolean
      gameContactEmail: string
      estimatedLength: string
      slotPreference: number
      lateStart?: string | null
      lateFinish?: boolean | null
      slotConflicts: string
      message: string
      slotId?: number | null
      teenFriendly: boolean
      year: number
      full?: boolean | null
      roomId?: number | null
      room?: { __typename: 'Room'; description: string } | null
      gameAssignments: {
        __typename: 'GameAssignmentsConnection'
        nodes: Array<{
          __typename: 'GameAssignment'
          gameId: number
          gm: number
          memberId: number
          nodeId: string
          year: number
          member?: {
            __typename: 'Membership'
            user?: { __typename: 'User'; email: string; fullName?: string | null } | null
          } | null
        } | null>
      }
    } | null>
  } | null
}

export type GetGameByIdQueryVariables = Exact<{
  id: Scalars['Int']
}>

export type GetGameByIdQuery = {
  __typename: 'Query'
  game?: {
    __typename: 'Game'
    nodeId: string
    id: number
    name: string
    gmNames?: string | null
    description: string
    genre: string
    type: string
    setting: string
    charInstructions: string
    playerMax: number
    playerMin: number
    playerPreference: string
    returningPlayers: string
    playersContactGm: boolean
    gameContactEmail: string
    estimatedLength: string
    slotPreference: number
    lateStart?: string | null
    lateFinish?: boolean | null
    slotConflicts: string
    message: string
    slotId?: number | null
    teenFriendly: boolean
    year: number
    full?: boolean | null
    roomId?: number | null
    room?: { __typename: 'Room'; description: string } | null
    gameAssignments: {
      __typename: 'GameAssignmentsConnection'
      nodes: Array<{
        __typename: 'GameAssignment'
        gameId: number
        gm: number
        memberId: number
        nodeId: string
        year: number
        member?: {
          __typename: 'Membership'
          user?: { __typename: 'User'; email: string; fullName?: string | null } | null
        } | null
      } | null>
    }
  } | null
}

export type GameAssignmentFieldsFragment = {
  __typename: 'GameAssignment'
  gameId: number
  gm: number
  memberId: number
  nodeId: string
  year: number
}

export type GetGameAssignmentsByYearQueryVariables = Exact<{
  year: Scalars['Int']
}>

export type GetGameAssignmentsByYearQuery = {
  __typename: 'Query'
  gameAssignments?: {
    __typename: 'GameAssignmentsConnection'
    nodes: Array<{
      __typename: 'GameAssignment'
      gameId: number
      gm: number
      memberId: number
      nodeId: string
      year: number
    } | null>
  } | null
}

export type GetGameAssignmentsByGameIdQueryVariables = Exact<{
  gameId: Scalars['Int']
}>

export type GetGameAssignmentsByGameIdQuery = {
  __typename: 'Query'
  gameAssignments?: {
    __typename: 'GameAssignmentsConnection'
    nodes: Array<{
      __typename: 'GameAssignment'
      gameId: number
      gm: number
      memberId: number
      nodeId: string
      year: number
    } | null>
  } | null
}

export type GetGameAssignmentsByMemberIdQueryVariables = Exact<{
  memberId: Scalars['Int']
}>

export type GetGameAssignmentsByMemberIdQuery = {
  __typename: 'Query'
  gameAssignments?: {
    __typename: 'GameAssignmentsConnection'
    nodes: Array<{
      __typename: 'GameAssignment'
      gameId: number
      gm: number
      memberId: number
      nodeId: string
      year: number
    } | null>
  } | null
}

export type UpdateGameAssignmentByNodeIdMutationVariables = Exact<{
  input: UpdateGameAssignmentByNodeIdInput
}>

export type UpdateGameAssignmentByNodeIdMutation = {
  __typename: 'Mutation'
  updateGameAssignmentByNodeId?: {
    __typename: 'UpdateGameAssignmentPayload'
    gameAssignment?: {
      __typename: 'GameAssignment'
      gameId: number
      gm: number
      memberId: number
      nodeId: string
      year: number
    } | null
  } | null
}

export type CreateGameAssignmentMutationVariables = Exact<{
  input: CreateGameAssignmentInput
}>

export type CreateGameAssignmentMutation = {
  __typename: 'Mutation'
  createGameAssignment?: {
    __typename: 'CreateGameAssignmentPayload'
    gameAssignment?: {
      __typename: 'GameAssignment'
      gameId: number
      gm: number
      memberId: number
      nodeId: string
      year: number
    } | null
  } | null
}

export type DeleteGameAssignmentMutationVariables = Exact<{
  input: DeleteGameAssignmentByNodeIdInput
}>

export type DeleteGameAssignmentMutation = {
  __typename: 'Mutation'
  deleteGameAssignmentByNodeId?: {
    __typename: 'DeleteGameAssignmentPayload'
    clientMutationId?: string | null
    deletedGameAssignmentNodeId?: string | null
  } | null
}

export type GetScheduleQueryVariables = Exact<{
  memberId: Scalars['Int']
}>

export type GetScheduleQuery = {
  __typename: 'Query'
  gameAssignments?: {
    __typename: 'GameAssignmentsConnection'
    nodes: Array<{
      __typename: 'GameAssignment'
      gameId: number
      gm: number
      memberId: number
      nodeId: string
      year: number
      game?: {
        __typename: 'Game'
        nodeId: string
        id: number
        name: string
        gmNames?: string | null
        description: string
        genre: string
        type: string
        setting: string
        charInstructions: string
        playerMax: number
        playerMin: number
        playerPreference: string
        returningPlayers: string
        playersContactGm: boolean
        gameContactEmail: string
        estimatedLength: string
        slotPreference: number
        lateStart?: string | null
        lateFinish?: boolean | null
        slotConflicts: string
        message: string
        slotId?: number | null
        teenFriendly: boolean
        year: number
        full?: boolean | null
        roomId?: number | null
        gameAssignments: {
          __typename: 'GameAssignmentsConnection'
          nodes: Array<{
            __typename: 'GameAssignment'
            gameId: number
            gm: number
            memberId: number
            nodeId: string
            year: number
            member?: {
              __typename: 'Membership'
              user?: { __typename: 'User'; email: string; fullName?: string | null } | null
            } | null
          } | null>
        }
        room?: { __typename: 'Room'; description: string } | null
      } | null
    } | null>
  } | null
}

export type GameSubmissionFieldsFragment = {
  __typename: 'GameSubmission'
  id: number
  memberId: number
  message: string
  nodeId: string
  year: number
}

export type GameChoiceFieldsFragment = {
  __typename: 'GameChoice'
  gameId?: number | null
  id: number
  memberId: number
  nodeId: string
  rank: number
  returningPlayer: boolean
  slotId: number
  year: number
}

export type CreateGameChoicesMutationVariables = Exact<{
  year: Scalars['Int']
  memberId: Scalars['Int']
}>

export type CreateGameChoicesMutation = {
  __typename: 'Mutation'
  createBareSlotChoices?: { __typename: 'CreateBareSlotChoicesPayload'; clientMutationId?: string | null } | null
}

export type GetGameChoicesQueryVariables = Exact<{
  year: Scalars['Int']
  memberId: Scalars['Int']
}>

export type GetGameChoicesQuery = {
  __typename: 'Query'
  gameSubmissions?: {
    __typename: 'GameSubmissionsConnection'
    nodes: Array<{
      __typename: 'GameSubmission'
      id: number
      memberId: number
      message: string
      nodeId: string
      year: number
    } | null>
  } | null
  gameChoices?: {
    __typename: 'GameChoicesConnection'
    nodes: Array<{
      __typename: 'GameChoice'
      gameId?: number | null
      id: number
      memberId: number
      nodeId: string
      rank: number
      returningPlayer: boolean
      slotId: number
      year: number
    } | null>
  } | null
}

export type ReadGameChoiceQueryVariables = Exact<{
  id: Scalars['Int']
}>

export type ReadGameChoiceQuery = {
  __typename: 'Query'
  gameChoice?: {
    __typename: 'GameChoice'
    gameId?: number | null
    id: number
    memberId: number
    nodeId: string
    rank: number
    returningPlayer: boolean
    slotId: number
    year: number
  } | null
}

export type CreateGameSubmissionMutationVariables = Exact<{
  input: CreateGameSubmissionInput
}>

export type CreateGameSubmissionMutation = {
  __typename: 'Mutation'
  createGameSubmission?: {
    __typename: 'CreateGameSubmissionPayload'
    clientMutationId?: string | null
    gameSubmission?: {
      __typename: 'GameSubmission'
      id: number
      memberId: number
      message: string
      nodeId: string
      year: number
    } | null
  } | null
}

export type UpdateGameSubmissionByNodeIdMutationVariables = Exact<{
  input: UpdateGameSubmissionByNodeIdInput
}>

export type UpdateGameSubmissionByNodeIdMutation = {
  __typename: 'Mutation'
  updateGameSubmissionByNodeId?: {
    __typename: 'UpdateGameSubmissionPayload'
    clientMutationId?: string | null
    gameSubmission?: {
      __typename: 'GameSubmission'
      id: number
      memberId: number
      message: string
      nodeId: string
      year: number
    } | null
  } | null
}

export type CreateGameChoiceMutationVariables = Exact<{
  input: CreateGameChoiceInput
}>

export type CreateGameChoiceMutation = {
  __typename: 'Mutation'
  createGameChoice?: {
    __typename: 'CreateGameChoicePayload'
    clientMutationId?: string | null
    gameChoice?: {
      __typename: 'GameChoice'
      gameId?: number | null
      id: number
      memberId: number
      nodeId: string
      rank: number
      returningPlayer: boolean
      slotId: number
      year: number
    } | null
  } | null
}

export type UpdateGameChoiceByNodeIdMutationVariables = Exact<{
  input: UpdateGameChoiceByNodeIdInput
}>

export type UpdateGameChoiceByNodeIdMutation = {
  __typename: 'Mutation'
  updateGameChoiceByNodeId?: {
    __typename: 'UpdateGameChoicePayload'
    clientMutationId?: string | null
    gameChoice?: {
      __typename: 'GameChoice'
      gameId?: number | null
      id: number
      memberId: number
      nodeId: string
      rank: number
      returningPlayer: boolean
      slotId: number
      year: number
    } | null
  } | null
}

export type GameFieldsFragment = {
  __typename: 'Game'
  nodeId: string
  id: number
  name: string
  gmNames?: string | null
  description: string
  genre: string
  type: string
  setting: string
  charInstructions: string
  playerMax: number
  playerMin: number
  playerPreference: string
  returningPlayers: string
  playersContactGm: boolean
  gameContactEmail: string
  estimatedLength: string
  slotPreference: number
  lateStart?: string | null
  lateFinish?: boolean | null
  slotConflicts: string
  message: string
  slotId?: number | null
  teenFriendly: boolean
  year: number
  full?: boolean | null
  roomId?: number | null
  room?: { __typename: 'Room'; description: string } | null
}

export type AssignmentFieldsFragment = {
  __typename: 'GameAssignment'
  gameId: number
  gm: number
  memberId: number
  nodeId: string
  year: number
  member?: {
    __typename: 'Membership'
    user?: { __typename: 'User'; email: string; fullName?: string | null } | null
  } | null
}

export type GameGmsFragment = {
  __typename: 'Game'
  gameAssignments: {
    __typename: 'GameAssignmentsConnection'
    nodes: Array<{
      __typename: 'GameAssignment'
      gameId: number
      gm: number
      memberId: number
      nodeId: string
      year: number
      member?: {
        __typename: 'Membership'
        user?: { __typename: 'User'; email: string; fullName?: string | null } | null
      } | null
    } | null>
  }
}

export type GameRoomFieldsFragment = {
  __typename: 'Room'
  id: number
  description: string
  size: number
  type: string
  updated: boolean
}

export type GetGameRoomsQueryVariables = Exact<{ [key: string]: never }>

export type GetGameRoomsQuery = {
  __typename: 'Query'
  rooms?: {
    __typename: 'RoomsConnection'
    nodes: Array<{
      __typename: 'Room'
      id: number
      description: string
      size: number
      type: string
      updated: boolean
    } | null>
  } | null
}

export type UpdateGameRoomMutationVariables = Exact<{
  input: UpdateRoomInput
}>

export type UpdateGameRoomMutation = {
  __typename: 'Mutation'
  updateRoom?: {
    __typename: 'UpdateRoomPayload'
    room?: { __typename: 'Room'; id: number; description: string; size: number; type: string; updated: boolean } | null
  } | null
}

export type CreateGameRoomMutationVariables = Exact<{
  input: CreateRoomInput
}>

export type CreateGameRoomMutation = {
  __typename: 'Mutation'
  createRoom?: {
    __typename: 'CreateRoomPayload'
    room?: { __typename: 'Room'; id: number; description: string; size: number; type: string; updated: boolean } | null
  } | null
}

export type DeleteGameRoomMutationVariables = Exact<{
  input: DeleteRoomInput
}>

export type DeleteGameRoomMutation = {
  __typename: 'Mutation'
  deleteRoom?: {
    __typename: 'DeleteRoomPayload'
    clientMutationId?: string | null
    deletedRoomNodeId?: string | null
  } | null
}

export type GetGameRoomAndGamesQueryVariables = Exact<{
  year?: InputMaybe<Scalars['Int']>
}>

export type GetGameRoomAndGamesQuery = {
  __typename: 'Query'
  rooms?: {
    __typename: 'RoomsConnection'
    nodes: Array<{
      __typename: 'Room'
      id: number
      description: string
      games: {
        __typename: 'GamesConnection'
        nodes: Array<{
          __typename: 'Game'
          id: number
          name: string
          slotId?: number | null
          gmNames?: string | null
        } | null>
      }
    } | null>
  } | null
}

export type HotelRoomFieldsFragment = {
  __typename: 'HotelRoom'
  id: number
  nodeId: string
  description: string
  gamingRoom: boolean
  bathroomType: string
  occupancy: string
  rate: string
  type: string
  quantity: number
}

export type GetHotelRoomsQueryVariables = Exact<{ [key: string]: never }>

export type GetHotelRoomsQuery = {
  __typename: 'Query'
  hotelRooms?: {
    __typename: 'HotelRoomsConnection'
    edges: Array<{
      __typename: 'HotelRoomsEdge'
      node?: {
        __typename: 'HotelRoom'
        id: number
        nodeId: string
        description: string
        gamingRoom: boolean
        bathroomType: string
        occupancy: string
        rate: string
        type: string
        quantity: number
      } | null
    }>
  } | null
}

export type UpdateHotelRoomByNodeIdMutationVariables = Exact<{
  input: UpdateHotelRoomByNodeIdInput
}>

export type UpdateHotelRoomByNodeIdMutation = {
  __typename: 'Mutation'
  updateHotelRoomByNodeId?: {
    __typename: 'UpdateHotelRoomPayload'
    hotelRoom?: {
      __typename: 'HotelRoom'
      id: number
      nodeId: string
      description: string
      gamingRoom: boolean
      bathroomType: string
      occupancy: string
      rate: string
      type: string
      quantity: number
    } | null
  } | null
}

export type CreateHotelRoomMutationVariables = Exact<{
  input: CreateHotelRoomInput
}>

export type CreateHotelRoomMutation = {
  __typename: 'Mutation'
  createHotelRoom?: {
    __typename: 'CreateHotelRoomPayload'
    hotelRoom?: {
      __typename: 'HotelRoom'
      id: number
      nodeId: string
      description: string
      gamingRoom: boolean
      bathroomType: string
      occupancy: string
      rate: string
      type: string
      quantity: number
    } | null
  } | null
}

export type DeleteHotelRoomMutationVariables = Exact<{
  input: DeleteHotelRoomInput
}>

export type DeleteHotelRoomMutation = {
  __typename: 'Mutation'
  deleteHotelRoom?: {
    __typename: 'DeleteHotelRoomPayload'
    clientMutationId?: string | null
    deletedHotelRoomNodeId?: string | null
  } | null
}

export type HotelRoomDetailsFieldsFragment = {
  __typename: 'HotelRoomDetail'
  id: any
  nodeId: string
  name: string
  roomType: string
  comment: string
  reservedFor: string
  bathroomType: string
  gamingRoom: boolean
  enabled: boolean
  formattedRoomType: string
  internalRoomType: string
  reserved: boolean
}

export type GetHotelRoomDetailsQueryVariables = Exact<{ [key: string]: never }>

export type GetHotelRoomDetailsQuery = {
  __typename: 'Query'
  hotelRoomDetails?: {
    __typename: 'HotelRoomDetailsConnection'
    edges: Array<{
      __typename: 'HotelRoomDetailsEdge'
      node?: {
        __typename: 'HotelRoomDetail'
        id: any
        nodeId: string
        name: string
        roomType: string
        comment: string
        reservedFor: string
        bathroomType: string
        gamingRoom: boolean
        enabled: boolean
        formattedRoomType: string
        internalRoomType: string
        reserved: boolean
      } | null
    }>
  } | null
}

export type UpdateHotelRoomDetailByNodeIdMutationVariables = Exact<{
  input: UpdateHotelRoomDetailByNodeIdInput
}>

export type UpdateHotelRoomDetailByNodeIdMutation = {
  __typename: 'Mutation'
  updateHotelRoomDetailByNodeId?: {
    __typename: 'UpdateHotelRoomDetailPayload'
    hotelRoomDetail?: {
      __typename: 'HotelRoomDetail'
      id: any
      nodeId: string
      name: string
      roomType: string
      comment: string
      reservedFor: string
      bathroomType: string
      gamingRoom: boolean
      enabled: boolean
      formattedRoomType: string
      internalRoomType: string
      reserved: boolean
    } | null
  } | null
}

export type CreateHotelRoomDetailMutationVariables = Exact<{
  input: CreateHotelRoomDetailInput
}>

export type CreateHotelRoomDetailMutation = {
  __typename: 'Mutation'
  createHotelRoomDetail?: {
    __typename: 'CreateHotelRoomDetailPayload'
    hotelRoomDetail?: {
      __typename: 'HotelRoomDetail'
      id: any
      nodeId: string
      name: string
      roomType: string
      comment: string
      reservedFor: string
      bathroomType: string
      gamingRoom: boolean
      enabled: boolean
      formattedRoomType: string
      internalRoomType: string
      reserved: boolean
    } | null
  } | null
}

export type DeleteHotelRoomDetailMutationVariables = Exact<{
  input: DeleteHotelRoomDetailInput
}>

export type DeleteHotelRoomDetailMutation = {
  __typename: 'Mutation'
  deleteHotelRoomDetail?: {
    __typename: 'DeleteHotelRoomDetailPayload'
    clientMutationId?: string | null
    deletedHotelRoomDetailNodeId?: string | null
  } | null
}

export type LookupFieldsFragment = { __typename: 'Lookup'; nodeId: string; id: number; realm: string }

export type LookupValuesFieldsFragment = {
  __typename: 'LookupValue'
  nodeId: string
  id: number
  code: string
  sequencer: number
  value: string
}

export type GetLookupsQueryVariables = Exact<{ [key: string]: never }>

export type GetLookupsQuery = {
  __typename: 'Query'
  lookups?: {
    __typename: 'LookupsConnection'
    edges: Array<{
      __typename: 'LookupsEdge'
      node?: {
        __typename: 'Lookup'
        nodeId: string
        id: number
        realm: string
        lookupValues: {
          __typename: 'LookupValuesConnection'
          nodes: Array<{
            __typename: 'LookupValue'
            nodeId: string
            id: number
            code: string
            sequencer: number
            value: string
          } | null>
        }
      } | null
    }>
  } | null
}

export type GetLookupValuesQueryVariables = Exact<{
  realm: Scalars['String']
}>

export type GetLookupValuesQuery = {
  __typename: 'Query'
  lookups?: {
    __typename: 'LookupsConnection'
    edges: Array<{
      __typename: 'LookupsEdge'
      node?: {
        __typename: 'Lookup'
        nodeId: string
        id: number
        realm: string
        lookupValues: {
          __typename: 'LookupValuesConnection'
          nodes: Array<{
            __typename: 'LookupValue'
            nodeId: string
            id: number
            code: string
            sequencer: number
            value: string
          } | null>
        }
      } | null
    }>
  } | null
}

export type GetSingleLookupValueQueryVariables = Exact<{
  realm: Scalars['String']
  code: Scalars['String']
}>

export type GetSingleLookupValueQuery = {
  __typename: 'Query'
  lookups?: {
    __typename: 'LookupsConnection'
    edges: Array<{
      __typename: 'LookupsEdge'
      node?: {
        __typename: 'Lookup'
        nodeId: string
        id: number
        realm: string
        lookupValues: {
          __typename: 'LookupValuesConnection'
          nodes: Array<{
            __typename: 'LookupValue'
            nodeId: string
            id: number
            code: string
            sequencer: number
            value: string
          } | null>
        }
      } | null
    }>
  } | null
}

export type UpdateLookupByNodeIdMutationVariables = Exact<{
  input: UpdateLookupByNodeIdInput
}>

export type UpdateLookupByNodeIdMutation = {
  __typename: 'Mutation'
  updateLookupByNodeId?: {
    __typename: 'UpdateLookupPayload'
    lookup?: { __typename: 'Lookup'; nodeId: string; id: number; realm: string } | null
  } | null
}

export type CreateLookupMutationVariables = Exact<{
  input: CreateLookupInput
}>

export type CreateLookupMutation = {
  __typename: 'Mutation'
  createLookup?: {
    __typename: 'CreateLookupPayload'
    lookup?: { __typename: 'Lookup'; nodeId: string; id: number; realm: string } | null
  } | null
}

export type DeleteLookupMutationVariables = Exact<{
  input: DeleteLookupInput
}>

export type DeleteLookupMutation = {
  __typename: 'Mutation'
  deleteLookup?: {
    __typename: 'DeleteLookupPayload'
    clientMutationId?: string | null
    deletedLookupNodeId?: string | null
  } | null
}

export type UpdateLookupValueByNodeIdMutationVariables = Exact<{
  input: UpdateLookupValueByNodeIdInput
}>

export type UpdateLookupValueByNodeIdMutation = {
  __typename: 'Mutation'
  updateLookupValueByNodeId?: {
    __typename: 'UpdateLookupValuePayload'
    lookupValue?: {
      __typename: 'LookupValue'
      nodeId: string
      id: number
      code: string
      sequencer: number
      value: string
    } | null
  } | null
}

export type CreateLookupValueMutationVariables = Exact<{
  input: CreateLookupValueInput
}>

export type CreateLookupValueMutation = {
  __typename: 'Mutation'
  createLookupValue?: {
    __typename: 'CreateLookupValuePayload'
    lookupValue?: {
      __typename: 'LookupValue'
      nodeId: string
      id: number
      code: string
      sequencer: number
      value: string
    } | null
  } | null
}

export type DeleteLookupValueMutationVariables = Exact<{
  input: DeleteLookupValueInput
}>

export type DeleteLookupValueMutation = {
  __typename: 'Mutation'
  deleteLookupValue?: {
    __typename: 'DeleteLookupValuePayload'
    clientMutationId?: string | null
    deletedLookupValueNodeId?: string | null
  } | null
}

export type GetMembershipByYearAndIdQueryVariables = Exact<{
  year: Scalars['Int']
  userId: Scalars['Int']
}>

export type GetMembershipByYearAndIdQuery = {
  __typename: 'Query'
  memberships?: {
    __typename: 'MembershipsConnection'
    nodes: Array<{
      __typename: 'Membership'
      nodeId: string
      id: number
      arrivalDate: string
      attendance: string
      attending: boolean
      hotelRoomId: number
      departureDate: string
      interestLevel: string
      message: string
      offerSubsidy: boolean
      requestOldPrice: boolean
      roomPreferenceAndNotes: string
      roomingPreferences: string
      roomingWith: string
      userId: number
      volunteer: boolean
      year: number
      slotsAttending?: string | null
      amountOwed: number
      amountPaid: number
      user?: {
        __typename: 'User'
        nodeId: string
        id: number
        email: string
        fullName?: string | null
        firstName?: string | null
        lastName?: string | null
      } | null
      hotelRoom?: { __typename: 'HotelRoom'; type: string } | null
    } | null>
  } | null
}

export type GetMembershipsByYearQueryVariables = Exact<{
  year: Scalars['Int']
}>

export type GetMembershipsByYearQuery = {
  __typename: 'Query'
  memberships?: {
    __typename: 'MembershipsConnection'
    nodes: Array<{
      __typename: 'Membership'
      nodeId: string
      id: number
      arrivalDate: string
      attendance: string
      attending: boolean
      hotelRoomId: number
      departureDate: string
      interestLevel: string
      message: string
      offerSubsidy: boolean
      requestOldPrice: boolean
      roomPreferenceAndNotes: string
      roomingPreferences: string
      roomingWith: string
      userId: number
      volunteer: boolean
      year: number
      slotsAttending?: string | null
      amountOwed: number
      amountPaid: number
      user?: {
        __typename: 'User'
        nodeId: string
        id: number
        email: string
        fullName?: string | null
        firstName?: string | null
        lastName?: string | null
      } | null
      hotelRoom?: { __typename: 'HotelRoom'; type: string } | null
    } | null>
  } | null
}

export type GetMembershipRoomsByYearQueryVariables = Exact<{
  year: Scalars['Int']
}>

export type GetMembershipRoomsByYearQuery = {
  __typename: 'Query'
  memberships?: {
    __typename: 'MembershipsConnection'
    nodes: Array<{
      __typename: 'Membership'
      hotelRoom?: {
        __typename: 'HotelRoom'
        id: number
        type: string
        gamingRoom: boolean
        bathroomType: string
      } | null
    } | null>
  } | null
}

export type GetMembershipsByIdQueryVariables = Exact<{
  id: Scalars['Int']
}>

export type GetMembershipsByIdQuery = {
  __typename: 'Query'
  memberships?: {
    __typename: 'MembershipsConnection'
    nodes: Array<{
      __typename: 'Membership'
      nodeId: string
      id: number
      arrivalDate: string
      attendance: string
      attending: boolean
      hotelRoomId: number
      departureDate: string
      interestLevel: string
      message: string
      offerSubsidy: boolean
      requestOldPrice: boolean
      roomPreferenceAndNotes: string
      roomingPreferences: string
      roomingWith: string
      userId: number
      volunteer: boolean
      year: number
      slotsAttending?: string | null
      amountOwed: number
      amountPaid: number
      user?: {
        __typename: 'User'
        nodeId: string
        id: number
        email: string
        fullName?: string | null
        firstName?: string | null
        lastName?: string | null
      } | null
      hotelRoom?: { __typename: 'HotelRoom'; type: string } | null
    } | null>
  } | null
}

export type GetMembershipByYearAndRoomQueryVariables = Exact<{
  year: Scalars['Int']
  hotelRoomId: Scalars['Int']
}>

export type GetMembershipByYearAndRoomQuery = {
  __typename: 'Query'
  memberships?: {
    __typename: 'MembershipsConnection'
    nodes: Array<{
      __typename: 'Membership'
      nodeId: string
      id: number
      arrivalDate: string
      attendance: string
      attending: boolean
      hotelRoomId: number
      departureDate: string
      interestLevel: string
      message: string
      offerSubsidy: boolean
      requestOldPrice: boolean
      roomPreferenceAndNotes: string
      roomingPreferences: string
      roomingWith: string
      userId: number
      volunteer: boolean
      year: number
      slotsAttending?: string | null
      amountOwed: number
      amountPaid: number
      user?: {
        __typename: 'User'
        nodeId: string
        id: number
        email: string
        fullName?: string | null
        firstName?: string | null
        lastName?: string | null
      } | null
      hotelRoom?: { __typename: 'HotelRoom'; type: string } | null
    } | null>
  } | null
}

export type UpdateMembershipByNodeIdMutationVariables = Exact<{
  input: UpdateMembershipByNodeIdInput
}>

export type UpdateMembershipByNodeIdMutation = {
  __typename: 'Mutation'
  updateMembershipByNodeId?: {
    __typename: 'UpdateMembershipPayload'
    membership?: {
      __typename: 'Membership'
      nodeId: string
      id: number
      arrivalDate: string
      attendance: string
      attending: boolean
      hotelRoomId: number
      departureDate: string
      interestLevel: string
      message: string
      offerSubsidy: boolean
      requestOldPrice: boolean
      roomPreferenceAndNotes: string
      roomingPreferences: string
      roomingWith: string
      userId: number
      volunteer: boolean
      year: number
      slotsAttending?: string | null
      amountOwed: number
      amountPaid: number
      user?: {
        __typename: 'User'
        nodeId: string
        id: number
        email: string
        fullName?: string | null
        firstName?: string | null
        lastName?: string | null
      } | null
      hotelRoom?: { __typename: 'HotelRoom'; type: string } | null
    } | null
  } | null
}

export type CreateMembershipMutationVariables = Exact<{
  input: CreateMembershipInput
}>

export type CreateMembershipMutation = {
  __typename: 'Mutation'
  createMembership?: {
    __typename: 'CreateMembershipPayload'
    membership?: {
      __typename: 'Membership'
      nodeId: string
      id: number
      arrivalDate: string
      attendance: string
      attending: boolean
      hotelRoomId: number
      departureDate: string
      interestLevel: string
      message: string
      offerSubsidy: boolean
      requestOldPrice: boolean
      roomPreferenceAndNotes: string
      roomingPreferences: string
      roomingWith: string
      userId: number
      volunteer: boolean
      year: number
      slotsAttending?: string | null
      amountOwed: number
      amountPaid: number
      user?: {
        __typename: 'User'
        nodeId: string
        id: number
        email: string
        fullName?: string | null
        firstName?: string | null
        lastName?: string | null
      } | null
      hotelRoom?: { __typename: 'HotelRoom'; type: string } | null
    } | null
  } | null
}

export type DeleteMembershipMutationVariables = Exact<{
  input: DeleteMembershipInput
}>

export type DeleteMembershipMutation = {
  __typename: 'Mutation'
  deleteMembership?: {
    __typename: 'DeleteMembershipPayload'
    clientMutationId?: string | null
    deletedMembershipNodeId?: string | null
  } | null
}

export type MembershipFieldsFragment = {
  __typename: 'Membership'
  nodeId: string
  id: number
  arrivalDate: string
  attendance: string
  attending: boolean
  hotelRoomId: number
  departureDate: string
  interestLevel: string
  message: string
  offerSubsidy: boolean
  requestOldPrice: boolean
  roomPreferenceAndNotes: string
  roomingPreferences: string
  roomingWith: string
  userId: number
  volunteer: boolean
  year: number
  slotsAttending?: string | null
  amountOwed: number
  amountPaid: number
  user?: {
    __typename: 'User'
    nodeId: string
    id: number
    email: string
    fullName?: string | null
    firstName?: string | null
    lastName?: string | null
  } | null
  hotelRoom?: { __typename: 'HotelRoom'; type: string } | null
}

export type SettingFieldsFragment = {
  __typename: 'Setting'
  nodeId: string
  id: number
  code: string
  type: string
  value: string
}

export type GetSettingsQueryVariables = Exact<{ [key: string]: never }>

export type GetSettingsQuery = {
  __typename: 'Query'
  settings?: {
    __typename: 'SettingsConnection'
    nodes: Array<{
      __typename: 'Setting'
      nodeId: string
      id: number
      code: string
      type: string
      value: string
    } | null>
  } | null
}

export type CreateSettingMutationVariables = Exact<{
  input: CreateSettingInput
}>

export type CreateSettingMutation = {
  __typename: 'Mutation'
  createSetting?: {
    __typename: 'CreateSettingPayload'
    setting?: { __typename: 'Setting'; nodeId: string; id: number; code: string; type: string; value: string } | null
  } | null
}

export type DeleteSettingMutationVariables = Exact<{
  input: DeleteSettingInput
}>

export type DeleteSettingMutation = {
  __typename: 'Mutation'
  deleteSetting?: {
    __typename: 'DeleteSettingPayload'
    clientMutationId?: string | null
    deletedSettingNodeId?: string | null
  } | null
}

export type UpdateSettingByNodeIdMutationVariables = Exact<{
  input: UpdateSettingByNodeIdInput
}>

export type UpdateSettingByNodeIdMutation = {
  __typename: 'Mutation'
  updateSettingByNodeId?: {
    __typename: 'UpdateSettingPayload'
    setting?: { __typename: 'Setting'; nodeId: string; id: number; code: string; type: string; value: string } | null
  } | null
}

export type GetSlotsQueryVariables = Exact<{ [key: string]: never }>

export type GetSlotsQuery = {
  __typename: 'Query'
  slots?: {
    __typename: 'SlotsConnection'
    nodes: Array<{
      __typename: 'Slot'
      nodeId: string
      id: number
      slot: number
      day: string
      length: string
      time: string
    } | null>
  } | null
}

export type SlotFieldsFragment = {
  __typename: 'Slot'
  nodeId: string
  id: number
  slot: number
  day: string
  length: string
  time: string
}

export type GetUserByEmailQueryVariables = Exact<{
  email: Scalars['String']
}>

export type GetUserByEmailQuery = {
  __typename: 'Query'
  userByEmail?: {
    __typename: 'User'
    nodeId: string
    id: number
    email: string
    fullName?: string | null
    firstName?: string | null
    lastName?: string | null
    profiles: {
      __typename: 'ProfilesConnection'
      nodes: Array<{
        __typename: 'Profile'
        nodeId: string
        userId: number
        phoneNumber?: string | null
        snailMailAddress?: string | null
      } | null>
    }
  } | null
}

export type GetUserByIdQueryVariables = Exact<{
  id: Scalars['Int']
}>

export type GetUserByIdQuery = {
  __typename: 'Query'
  user?: {
    __typename: 'User'
    nodeId: string
    id: number
    email: string
    fullName?: string | null
    firstName?: string | null
    lastName?: string | null
  } | null
}

export type UpdateUserMutationVariables = Exact<{
  input: UpdateUserInput
}>

export type UpdateUserMutation = {
  __typename: 'Mutation'
  updateUser?: {
    __typename: 'UpdateUserPayload'
    user?: {
      __typename: 'User'
      nodeId: string
      id: number
      email: string
      fullName?: string | null
      firstName?: string | null
      lastName?: string | null
    } | null
  } | null
}

export type GetAllUsersQueryVariables = Exact<{ [key: string]: never }>

export type GetAllUsersQuery = {
  __typename: 'Query'
  users?: {
    __typename: 'UsersConnection'
    nodes: Array<{
      __typename: 'User'
      nodeId: string
      id: number
      email: string
      fullName?: string | null
      firstName?: string | null
      lastName?: string | null
    } | null>
  } | null
}

export type GetAllUsersAndProfilesQueryVariables = Exact<{ [key: string]: never }>

export type GetAllUsersAndProfilesQuery = {
  __typename: 'Query'
  users?: {
    __typename: 'UsersConnection'
    nodes: Array<{
      __typename: 'User'
      nodeId: string
      id: number
      email: string
      fullName?: string | null
      firstName?: string | null
      lastName?: string | null
      profiles: {
        __typename: 'ProfilesConnection'
        nodes: Array<{
          __typename: 'Profile'
          nodeId: string
          userId: number
          phoneNumber?: string | null
          snailMailAddress?: string | null
        } | null>
      }
    } | null>
  } | null
}

export type GetAllUsersByQueryVariables = Exact<{
  query: Scalars['String']
}>

export type GetAllUsersByQuery = {
  __typename: 'Query'
  users?: {
    __typename: 'UsersConnection'
    nodes: Array<{
      __typename: 'User'
      nodeId: string
      id: number
      email: string
      fullName?: string | null
      firstName?: string | null
      lastName?: string | null
      memberships: {
        __typename: 'MembershipsConnection'
        nodes: Array<{ __typename: 'Membership'; id: number; year: number } | null>
      }
    } | null>
  } | null
}

export type CreateProfileMutationVariables = Exact<{
  input: CreateProfileInput
}>

export type CreateProfileMutation = {
  __typename: 'Mutation'
  createProfile?: { __typename: 'CreateProfilePayload'; clientMutationId?: string | null } | null
}

export type UpdateProfileByNodeIdMutationVariables = Exact<{
  input: UpdateProfileByNodeIdInput
}>

export type UpdateProfileByNodeIdMutation = {
  __typename: 'Mutation'
  updateProfileByNodeId?: { __typename: 'UpdateProfilePayload'; clientMutationId?: string | null } | null
}

export type UserFieldsFragment = {
  __typename: 'User'
  nodeId: string
  id: number
  email: string
  fullName?: string | null
  firstName?: string | null
  lastName?: string | null
}

export type ProfileFieldsFragment = {
  __typename: 'Profile'
  nodeId: string
  userId: number
  phoneNumber?: string | null
  snailMailAddress?: string | null
}

export type UserAndProfileFieldsFragment = {
  __typename: 'User'
  nodeId: string
  id: number
  email: string
  fullName?: string | null
  firstName?: string | null
  lastName?: string | null
  profiles: {
    __typename: 'ProfilesConnection'
    nodes: Array<{
      __typename: 'Profile'
      nodeId: string
      userId: number
      phoneNumber?: string | null
      snailMailAddress?: string | null
    } | null>
  }
}

export const GameSubmissionFieldsFragmentDoc = `
    fragment gameSubmissionFields on GameSubmission {
  id
  memberId
  message
  nodeId
  year
}
    `
export const GameChoiceFieldsFragmentDoc = `
    fragment gameChoiceFields on GameChoice {
  gameId
  id
  memberId
  nodeId
  rank
  returningPlayer
  slotId
  year
}
    `
export const GameFieldsFragmentDoc = `
    fragment gameFields on Game {
  nodeId
  id
  name
  gmNames
  description
  genre
  type
  setting
  charInstructions
  playerMax
  playerMin
  playerPreference
  returningPlayers
  playersContactGm
  gameContactEmail
  estimatedLength
  slotPreference
  lateStart
  lateFinish
  slotConflicts
  message
  slotId
  teenFriendly
  year
  full
  roomId
  room {
    description
  }
}
    `
export const GameAssignmentFieldsFragmentDoc = `
    fragment gameAssignmentFields on GameAssignment {
  gameId
  gm
  memberId
  nodeId
  year
}
    `
export const AssignmentFieldsFragmentDoc = `
    fragment assignmentFields on GameAssignment {
  ...gameAssignmentFields
  member {
    user {
      email
      fullName
    }
  }
}
    ${GameAssignmentFieldsFragmentDoc}`
export const GameGmsFragmentDoc = `
    fragment gameGms on Game {
  gameAssignments(filter: {gm: {lessThan: 0}}) {
    nodes {
      ...assignmentFields
    }
  }
}
    ${AssignmentFieldsFragmentDoc}`
export const GameRoomFieldsFragmentDoc = `
    fragment gameRoomFields on Room {
  id
  description
  size
  type
  updated
}
    `
export const HotelRoomFieldsFragmentDoc = `
    fragment hotelRoomFields on HotelRoom {
  id
  nodeId
  description
  gamingRoom
  bathroomType
  occupancy
  rate
  type
  quantity
}
    `
export const HotelRoomDetailsFieldsFragmentDoc = `
    fragment hotelRoomDetailsFields on HotelRoomDetail {
  id
  nodeId
  name
  roomType
  comment
  reservedFor
  bathroomType
  gamingRoom
  enabled
  formattedRoomType
  internalRoomType
  reserved
}
    `
export const LookupFieldsFragmentDoc = `
    fragment lookupFields on Lookup {
  nodeId
  id
  realm
}
    `
export const LookupValuesFieldsFragmentDoc = `
    fragment lookupValuesFields on LookupValue {
  nodeId
  id
  code
  sequencer
  value
}
    `
export const UserFieldsFragmentDoc = `
    fragment userFields on User {
  nodeId
  id
  email
  fullName
  firstName
  lastName
}
    `
export const MembershipFieldsFragmentDoc = `
    fragment membershipFields on Membership {
  nodeId
  id
  arrivalDate
  attendance
  attending
  hotelRoomId
  departureDate
  interestLevel
  message
  offerSubsidy
  requestOldPrice
  roomPreferenceAndNotes
  roomingPreferences
  roomingWith
  userId
  volunteer
  year
  slotsAttending
  amountOwed
  amountPaid
  user {
    ...userFields
  }
  hotelRoom {
    type
  }
}
    ${UserFieldsFragmentDoc}`
export const SettingFieldsFragmentDoc = `
    fragment settingFields on Setting {
  nodeId
  id
  code
  type
  value
}
    `
export const SlotFieldsFragmentDoc = `
    fragment slotFields on Slot {
  nodeId
  id
  slot
  day
  length
  time
}
    `
export const ProfileFieldsFragmentDoc = `
    fragment profileFields on Profile {
  nodeId
  userId
  phoneNumber
  snailMailAddress
}
    `
export const UserAndProfileFieldsFragmentDoc = `
    fragment userAndProfileFields on User {
  ...userFields
  profiles {
    nodes {
      ...profileFields
    }
  }
}
    ${UserFieldsFragmentDoc}
${ProfileFieldsFragmentDoc}`
export const GetGamesBySlotForSignupDocument = `
    query getGamesBySlotForSignup($year: Int!, $slotId: Int!) {
  games(
    filter: {or: [{and: [{or: [{year: {equalTo: $year}}, {year: {equalTo: 0}}]}, {slotId: {equalTo: $slotId}}]}, {and: [{year: {equalTo: 0}}, {slotId: {isNull: true}}]}]}
    orderBy: [YEAR_DESC, SLOT_ID_ASC, NAME_ASC]
  ) {
    edges {
      node {
        ...gameFields
        ...gameGms
      }
    }
  }
}
    ${GameFieldsFragmentDoc}
${GameGmsFragmentDoc}`
export const useGetGamesBySlotForSignupQuery = <TData = GetGamesBySlotForSignupQuery, TError = QueryError>(
  variables: GetGamesBySlotForSignupQueryVariables,
  options?: UseQueryOptions<GetGamesBySlotForSignupQuery, TError, TData>
) =>
  useQuery<GetGamesBySlotForSignupQuery, TError, TData>(
    ['getGamesBySlotForSignup', variables],
    useFetchData<GetGamesBySlotForSignupQuery, GetGamesBySlotForSignupQueryVariables>(
      GetGamesBySlotForSignupDocument
    ).bind(null, variables),
    options
  )
export const GetGamesBySlotDocument = `
    query getGamesBySlot($year: Int!, $slotId: Int!) {
  games(
    condition: {year: $year, slotId: $slotId}
    orderBy: [SLOT_ID_ASC, NAME_ASC]
  ) {
    edges {
      node {
        ...gameFields
        ...gameGms
      }
    }
  }
}
    ${GameFieldsFragmentDoc}
${GameGmsFragmentDoc}`
export const useGetGamesBySlotQuery = <TData = GetGamesBySlotQuery, TError = QueryError>(
  variables: GetGamesBySlotQueryVariables,
  options?: UseQueryOptions<GetGamesBySlotQuery, TError, TData>
) =>
  useQuery<GetGamesBySlotQuery, TError, TData>(
    ['getGamesBySlot', variables],
    useFetchData<GetGamesBySlotQuery, GetGamesBySlotQueryVariables>(GetGamesBySlotDocument).bind(null, variables),
    options
  )
export const GetGamesByYearDocument = `
    query getGamesByYear($year: Int!) {
  games(
    filter: {or: [{and: [{or: [{year: {equalTo: $year}}, {year: {equalTo: 0}}]}]}, {and: [{year: {equalTo: 0}}]}]}
    orderBy: [YEAR_DESC, SLOT_ID_ASC, NAME_ASC]
  ) {
    edges {
      node {
        ...gameFields
        ...gameGms
        room {
          ...gameRoomFields
        }
      }
    }
  }
}
    ${GameFieldsFragmentDoc}
${GameGmsFragmentDoc}
${GameRoomFieldsFragmentDoc}`
export const useGetGamesByYearQuery = <TData = GetGamesByYearQuery, TError = QueryError>(
  variables: GetGamesByYearQueryVariables,
  options?: UseQueryOptions<GetGamesByYearQuery, TError, TData>
) =>
  useQuery<GetGamesByYearQuery, TError, TData>(
    ['getGamesByYear', variables],
    useFetchData<GetGamesByYearQuery, GetGamesByYearQueryVariables>(GetGamesByYearDocument).bind(null, variables),
    options
  )
export const GetSmallGamesByYearDocument = `
    query getSmallGamesByYear($year: Int!) {
  games(condition: {year: $year}, orderBy: [SLOT_ID_ASC, NAME_ASC], first: 1) {
    edges {
      node {
        ...gameFields
        ...gameGms
      }
    }
  }
}
    ${GameFieldsFragmentDoc}
${GameGmsFragmentDoc}`
export const useGetSmallGamesByYearQuery = <TData = GetSmallGamesByYearQuery, TError = QueryError>(
  variables: GetSmallGamesByYearQueryVariables,
  options?: UseQueryOptions<GetSmallGamesByYearQuery, TError, TData>
) =>
  useQuery<GetSmallGamesByYearQuery, TError, TData>(
    ['getSmallGamesByYear', variables],
    useFetchData<GetSmallGamesByYearQuery, GetSmallGamesByYearQueryVariables>(GetSmallGamesByYearDocument).bind(
      null,
      variables
    ),
    options
  )
export const UpdateGameByNodeIdDocument = `
    mutation updateGameByNodeId($input: UpdateGameByNodeIdInput!) {
  updateGameByNodeId(input: $input) {
    game {
      ...gameFields
      ...gameGms
    }
  }
}
    ${GameFieldsFragmentDoc}
${GameGmsFragmentDoc}`
export const useUpdateGameByNodeIdMutation = <TError = QueryError, TContext = unknown>(
  options?: UseMutationOptions<UpdateGameByNodeIdMutation, TError, UpdateGameByNodeIdMutationVariables, TContext>
) =>
  useMutation<UpdateGameByNodeIdMutation, TError, UpdateGameByNodeIdMutationVariables, TContext>(
    ['updateGameByNodeId'],
    useFetchData<UpdateGameByNodeIdMutation, UpdateGameByNodeIdMutationVariables>(UpdateGameByNodeIdDocument),
    options
  )
export const UpdateGameDocument = `
    mutation updateGame($input: UpdateGameInput!) {
  updateGame(input: $input) {
    game {
      ...gameFields
      ...gameGms
    }
  }
}
    ${GameFieldsFragmentDoc}
${GameGmsFragmentDoc}`
export const useUpdateGameMutation = <TError = QueryError, TContext = unknown>(
  options?: UseMutationOptions<UpdateGameMutation, TError, UpdateGameMutationVariables, TContext>
) =>
  useMutation<UpdateGameMutation, TError, UpdateGameMutationVariables, TContext>(
    ['updateGame'],
    useFetchData<UpdateGameMutation, UpdateGameMutationVariables>(UpdateGameDocument),
    options
  )
export const CreateGameDocument = `
    mutation createGame($input: CreateGameInput!) {
  createGame(input: $input) {
    game {
      ...gameFields
      ...gameGms
    }
  }
}
    ${GameFieldsFragmentDoc}
${GameGmsFragmentDoc}`
export const useCreateGameMutation = <TError = QueryError, TContext = unknown>(
  options?: UseMutationOptions<CreateGameMutation, TError, CreateGameMutationVariables, TContext>
) =>
  useMutation<CreateGameMutation, TError, CreateGameMutationVariables, TContext>(
    ['createGame'],
    useFetchData<CreateGameMutation, CreateGameMutationVariables>(CreateGameDocument),
    options
  )
export const DeleteGameDocument = `
    mutation deleteGame($input: DeleteGameInput!) {
  deleteGame(input: $input) {
    clientMutationId
    deletedGameNodeId
  }
}
    `
export const useDeleteGameMutation = <TError = QueryError, TContext = unknown>(
  options?: UseMutationOptions<DeleteGameMutation, TError, DeleteGameMutationVariables, TContext>
) =>
  useMutation<DeleteGameMutation, TError, DeleteGameMutationVariables, TContext>(
    ['deleteGame'],
    useFetchData<DeleteGameMutation, DeleteGameMutationVariables>(DeleteGameDocument),
    options
  )
export const GetFirstGameOfSlotDocument = `
    query getFirstGameOfSlot($year: Int!) {
  games(orderBy: NAME_ASC, condition: {slotId: 1, year: $year}, first: 1) {
    nodes {
      ...gameFields
      gameAssignments(filter: {gm: {lessThan: 0}}) {
        nodes {
          nodeId
          gm
          member {
            user {
              email
              fullName
            }
          }
        }
      }
    }
  }
}
    ${GameFieldsFragmentDoc}`
export const useGetFirstGameOfSlotQuery = <TData = GetFirstGameOfSlotQuery, TError = QueryError>(
  variables: GetFirstGameOfSlotQueryVariables,
  options?: UseQueryOptions<GetFirstGameOfSlotQuery, TError, TData>
) =>
  useQuery<GetFirstGameOfSlotQuery, TError, TData>(
    ['getFirstGameOfSlot', variables],
    useFetchData<GetFirstGameOfSlotQuery, GetFirstGameOfSlotQueryVariables>(GetFirstGameOfSlotDocument).bind(
      null,
      variables
    ),
    options
  )
export const GetGamesByAuthorDocument = `
    query getGamesByAuthor($id: Int!) {
  user(id: $id) {
    authoredGames {
      nodes {
        ...gameFields
        ...gameGms
      }
    }
  }
}
    ${GameFieldsFragmentDoc}
${GameGmsFragmentDoc}`
export const useGetGamesByAuthorQuery = <TData = GetGamesByAuthorQuery, TError = QueryError>(
  variables: GetGamesByAuthorQueryVariables,
  options?: UseQueryOptions<GetGamesByAuthorQuery, TError, TData>
) =>
  useQuery<GetGamesByAuthorQuery, TError, TData>(
    ['getGamesByAuthor', variables],
    useFetchData<GetGamesByAuthorQuery, GetGamesByAuthorQueryVariables>(GetGamesByAuthorDocument).bind(null, variables),
    options
  )
export const GetGamesByYearAndAuthorDocument = `
    query getGamesByYearAndAuthor($year: Int!, $id: Int!) {
  games(condition: {authorId: $id, year: $year}) {
    nodes {
      ...gameFields
      ...gameGms
    }
  }
}
    ${GameFieldsFragmentDoc}
${GameGmsFragmentDoc}`
export const useGetGamesByYearAndAuthorQuery = <TData = GetGamesByYearAndAuthorQuery, TError = QueryError>(
  variables: GetGamesByYearAndAuthorQueryVariables,
  options?: UseQueryOptions<GetGamesByYearAndAuthorQuery, TError, TData>
) =>
  useQuery<GetGamesByYearAndAuthorQuery, TError, TData>(
    ['getGamesByYearAndAuthor', variables],
    useFetchData<GetGamesByYearAndAuthorQuery, GetGamesByYearAndAuthorQueryVariables>(
      GetGamesByYearAndAuthorDocument
    ).bind(null, variables),
    options
  )
export const GetGameByIdDocument = `
    query getGameById($id: Int!) {
  game(id: $id) {
    ...gameFields
    ...gameGms
  }
}
    ${GameFieldsFragmentDoc}
${GameGmsFragmentDoc}`
export const useGetGameByIdQuery = <TData = GetGameByIdQuery, TError = QueryError>(
  variables: GetGameByIdQueryVariables,
  options?: UseQueryOptions<GetGameByIdQuery, TError, TData>
) =>
  useQuery<GetGameByIdQuery, TError, TData>(
    ['getGameById', variables],
    useFetchData<GetGameByIdQuery, GetGameByIdQueryVariables>(GetGameByIdDocument).bind(null, variables),
    options
  )
export const GetGameAssignmentsByYearDocument = `
    query getGameAssignmentsByYear($year: Int!) {
  gameAssignments(condition: {year: $year}) {
    nodes {
      ...gameAssignmentFields
    }
  }
}
    ${GameAssignmentFieldsFragmentDoc}`
export const useGetGameAssignmentsByYearQuery = <TData = GetGameAssignmentsByYearQuery, TError = QueryError>(
  variables: GetGameAssignmentsByYearQueryVariables,
  options?: UseQueryOptions<GetGameAssignmentsByYearQuery, TError, TData>
) =>
  useQuery<GetGameAssignmentsByYearQuery, TError, TData>(
    ['getGameAssignmentsByYear', variables],
    useFetchData<GetGameAssignmentsByYearQuery, GetGameAssignmentsByYearQueryVariables>(
      GetGameAssignmentsByYearDocument
    ).bind(null, variables),
    options
  )
export const GetGameAssignmentsByGameIdDocument = `
    query getGameAssignmentsByGameId($gameId: Int!) {
  gameAssignments(condition: {gameId: $gameId}) {
    nodes {
      ...gameAssignmentFields
    }
  }
}
    ${GameAssignmentFieldsFragmentDoc}`
export const useGetGameAssignmentsByGameIdQuery = <TData = GetGameAssignmentsByGameIdQuery, TError = QueryError>(
  variables: GetGameAssignmentsByGameIdQueryVariables,
  options?: UseQueryOptions<GetGameAssignmentsByGameIdQuery, TError, TData>
) =>
  useQuery<GetGameAssignmentsByGameIdQuery, TError, TData>(
    ['getGameAssignmentsByGameId', variables],
    useFetchData<GetGameAssignmentsByGameIdQuery, GetGameAssignmentsByGameIdQueryVariables>(
      GetGameAssignmentsByGameIdDocument
    ).bind(null, variables),
    options
  )
export const GetGameAssignmentsByMemberIdDocument = `
    query getGameAssignmentsByMemberId($memberId: Int!) {
  gameAssignments(condition: {memberId: $memberId}) {
    nodes {
      ...gameAssignmentFields
    }
  }
}
    ${GameAssignmentFieldsFragmentDoc}`
export const useGetGameAssignmentsByMemberIdQuery = <TData = GetGameAssignmentsByMemberIdQuery, TError = QueryError>(
  variables: GetGameAssignmentsByMemberIdQueryVariables,
  options?: UseQueryOptions<GetGameAssignmentsByMemberIdQuery, TError, TData>
) =>
  useQuery<GetGameAssignmentsByMemberIdQuery, TError, TData>(
    ['getGameAssignmentsByMemberId', variables],
    useFetchData<GetGameAssignmentsByMemberIdQuery, GetGameAssignmentsByMemberIdQueryVariables>(
      GetGameAssignmentsByMemberIdDocument
    ).bind(null, variables),
    options
  )
export const UpdateGameAssignmentByNodeIdDocument = `
    mutation updateGameAssignmentByNodeId($input: UpdateGameAssignmentByNodeIdInput!) {
  updateGameAssignmentByNodeId(input: $input) {
    gameAssignment {
      ...gameAssignmentFields
    }
  }
}
    ${GameAssignmentFieldsFragmentDoc}`
export const useUpdateGameAssignmentByNodeIdMutation = <TError = QueryError, TContext = unknown>(
  options?: UseMutationOptions<
    UpdateGameAssignmentByNodeIdMutation,
    TError,
    UpdateGameAssignmentByNodeIdMutationVariables,
    TContext
  >
) =>
  useMutation<UpdateGameAssignmentByNodeIdMutation, TError, UpdateGameAssignmentByNodeIdMutationVariables, TContext>(
    ['updateGameAssignmentByNodeId'],
    useFetchData<UpdateGameAssignmentByNodeIdMutation, UpdateGameAssignmentByNodeIdMutationVariables>(
      UpdateGameAssignmentByNodeIdDocument
    ),
    options
  )
export const CreateGameAssignmentDocument = `
    mutation createGameAssignment($input: CreateGameAssignmentInput!) {
  createGameAssignment(input: $input) {
    gameAssignment {
      ...gameAssignmentFields
    }
  }
}
    ${GameAssignmentFieldsFragmentDoc}`
export const useCreateGameAssignmentMutation = <TError = QueryError, TContext = unknown>(
  options?: UseMutationOptions<CreateGameAssignmentMutation, TError, CreateGameAssignmentMutationVariables, TContext>
) =>
  useMutation<CreateGameAssignmentMutation, TError, CreateGameAssignmentMutationVariables, TContext>(
    ['createGameAssignment'],
    useFetchData<CreateGameAssignmentMutation, CreateGameAssignmentMutationVariables>(CreateGameAssignmentDocument),
    options
  )
export const DeleteGameAssignmentDocument = `
    mutation deleteGameAssignment($input: DeleteGameAssignmentByNodeIdInput!) {
  deleteGameAssignmentByNodeId(input: $input) {
    clientMutationId
    deletedGameAssignmentNodeId
  }
}
    `
export const useDeleteGameAssignmentMutation = <TError = QueryError, TContext = unknown>(
  options?: UseMutationOptions<DeleteGameAssignmentMutation, TError, DeleteGameAssignmentMutationVariables, TContext>
) =>
  useMutation<DeleteGameAssignmentMutation, TError, DeleteGameAssignmentMutationVariables, TContext>(
    ['deleteGameAssignment'],
    useFetchData<DeleteGameAssignmentMutation, DeleteGameAssignmentMutationVariables>(DeleteGameAssignmentDocument),
    options
  )
export const GetScheduleDocument = `
    query getSchedule($memberId: Int!) {
  gameAssignments(
    condition: {memberId: $memberId}
    filter: {gm: {greaterThanOrEqualTo: 0}}
  ) {
    nodes {
      game {
        ...gameFields
        gameAssignments(filter: {gm: {greaterThanOrEqualTo: 0}}) {
          nodes {
            ...assignmentFields
          }
        }
      }
      ...gameAssignmentFields
    }
  }
}
    ${GameFieldsFragmentDoc}
${AssignmentFieldsFragmentDoc}
${GameAssignmentFieldsFragmentDoc}`
export const useGetScheduleQuery = <TData = GetScheduleQuery, TError = QueryError>(
  variables: GetScheduleQueryVariables,
  options?: UseQueryOptions<GetScheduleQuery, TError, TData>
) =>
  useQuery<GetScheduleQuery, TError, TData>(
    ['getSchedule', variables],
    useFetchData<GetScheduleQuery, GetScheduleQueryVariables>(GetScheduleDocument).bind(null, variables),
    options
  )
export const CreateGameChoicesDocument = `
    mutation createGameChoices($year: Int!, $memberId: Int!) {
  createBareSlotChoices(input: {memberId: $memberId, yearno: $year}) {
    clientMutationId
  }
}
    `
export const useCreateGameChoicesMutation = <TError = QueryError, TContext = unknown>(
  options?: UseMutationOptions<CreateGameChoicesMutation, TError, CreateGameChoicesMutationVariables, TContext>
) =>
  useMutation<CreateGameChoicesMutation, TError, CreateGameChoicesMutationVariables, TContext>(
    ['createGameChoices'],
    useFetchData<CreateGameChoicesMutation, CreateGameChoicesMutationVariables>(CreateGameChoicesDocument),
    options
  )
export const GetGameChoicesDocument = `
    query getGameChoices($year: Int!, $memberId: Int!) {
  gameSubmissions(condition: {memberId: $memberId, year: $year}) {
    nodes {
      ...gameSubmissionFields
    }
  }
  gameChoices(condition: {memberId: $memberId, year: $year}) {
    nodes {
      ...gameChoiceFields
    }
  }
}
    ${GameSubmissionFieldsFragmentDoc}
${GameChoiceFieldsFragmentDoc}`
export const useGetGameChoicesQuery = <TData = GetGameChoicesQuery, TError = QueryError>(
  variables: GetGameChoicesQueryVariables,
  options?: UseQueryOptions<GetGameChoicesQuery, TError, TData>
) =>
  useQuery<GetGameChoicesQuery, TError, TData>(
    ['getGameChoices', variables],
    useFetchData<GetGameChoicesQuery, GetGameChoicesQueryVariables>(GetGameChoicesDocument).bind(null, variables),
    options
  )
export const ReadGameChoiceDocument = `
    query readGameChoice($id: Int!) {
  gameChoice(id: $id) {
    ...gameChoiceFields
  }
}
    ${GameChoiceFieldsFragmentDoc}`
export const useReadGameChoiceQuery = <TData = ReadGameChoiceQuery, TError = QueryError>(
  variables: ReadGameChoiceQueryVariables,
  options?: UseQueryOptions<ReadGameChoiceQuery, TError, TData>
) =>
  useQuery<ReadGameChoiceQuery, TError, TData>(
    ['readGameChoice', variables],
    useFetchData<ReadGameChoiceQuery, ReadGameChoiceQueryVariables>(ReadGameChoiceDocument).bind(null, variables),
    options
  )
export const CreateGameSubmissionDocument = `
    mutation createGameSubmission($input: CreateGameSubmissionInput!) {
  createGameSubmission(input: $input) {
    clientMutationId
    gameSubmission {
      ...gameSubmissionFields
    }
  }
}
    ${GameSubmissionFieldsFragmentDoc}`
export const useCreateGameSubmissionMutation = <TError = QueryError, TContext = unknown>(
  options?: UseMutationOptions<CreateGameSubmissionMutation, TError, CreateGameSubmissionMutationVariables, TContext>
) =>
  useMutation<CreateGameSubmissionMutation, TError, CreateGameSubmissionMutationVariables, TContext>(
    ['createGameSubmission'],
    useFetchData<CreateGameSubmissionMutation, CreateGameSubmissionMutationVariables>(CreateGameSubmissionDocument),
    options
  )
export const UpdateGameSubmissionByNodeIdDocument = `
    mutation updateGameSubmissionByNodeId($input: UpdateGameSubmissionByNodeIdInput!) {
  updateGameSubmissionByNodeId(input: $input) {
    clientMutationId
    gameSubmission {
      ...gameSubmissionFields
    }
  }
}
    ${GameSubmissionFieldsFragmentDoc}`
export const useUpdateGameSubmissionByNodeIdMutation = <TError = QueryError, TContext = unknown>(
  options?: UseMutationOptions<
    UpdateGameSubmissionByNodeIdMutation,
    TError,
    UpdateGameSubmissionByNodeIdMutationVariables,
    TContext
  >
) =>
  useMutation<UpdateGameSubmissionByNodeIdMutation, TError, UpdateGameSubmissionByNodeIdMutationVariables, TContext>(
    ['updateGameSubmissionByNodeId'],
    useFetchData<UpdateGameSubmissionByNodeIdMutation, UpdateGameSubmissionByNodeIdMutationVariables>(
      UpdateGameSubmissionByNodeIdDocument
    ),
    options
  )
export const CreateGameChoiceDocument = `
    mutation createGameChoice($input: CreateGameChoiceInput!) {
  createGameChoice(input: $input) {
    clientMutationId
    gameChoice {
      ...gameChoiceFields
    }
  }
}
    ${GameChoiceFieldsFragmentDoc}`
export const useCreateGameChoiceMutation = <TError = QueryError, TContext = unknown>(
  options?: UseMutationOptions<CreateGameChoiceMutation, TError, CreateGameChoiceMutationVariables, TContext>
) =>
  useMutation<CreateGameChoiceMutation, TError, CreateGameChoiceMutationVariables, TContext>(
    ['createGameChoice'],
    useFetchData<CreateGameChoiceMutation, CreateGameChoiceMutationVariables>(CreateGameChoiceDocument),
    options
  )
export const UpdateGameChoiceByNodeIdDocument = `
    mutation updateGameChoiceByNodeId($input: UpdateGameChoiceByNodeIdInput!) {
  updateGameChoiceByNodeId(input: $input) {
    clientMutationId
    gameChoice {
      ...gameChoiceFields
    }
  }
}
    ${GameChoiceFieldsFragmentDoc}`
export const useUpdateGameChoiceByNodeIdMutation = <TError = QueryError, TContext = unknown>(
  options?: UseMutationOptions<
    UpdateGameChoiceByNodeIdMutation,
    TError,
    UpdateGameChoiceByNodeIdMutationVariables,
    TContext
  >
) =>
  useMutation<UpdateGameChoiceByNodeIdMutation, TError, UpdateGameChoiceByNodeIdMutationVariables, TContext>(
    ['updateGameChoiceByNodeId'],
    useFetchData<UpdateGameChoiceByNodeIdMutation, UpdateGameChoiceByNodeIdMutationVariables>(
      UpdateGameChoiceByNodeIdDocument
    ),
    options
  )
export const GetGameRoomsDocument = `
    query getGameRooms {
  rooms {
    nodes {
      ...gameRoomFields
    }
  }
}
    ${GameRoomFieldsFragmentDoc}`
export const useGetGameRoomsQuery = <TData = GetGameRoomsQuery, TError = QueryError>(
  variables?: GetGameRoomsQueryVariables,
  options?: UseQueryOptions<GetGameRoomsQuery, TError, TData>
) =>
  useQuery<GetGameRoomsQuery, TError, TData>(
    variables === undefined ? ['getGameRooms'] : ['getGameRooms', variables],
    useFetchData<GetGameRoomsQuery, GetGameRoomsQueryVariables>(GetGameRoomsDocument).bind(null, variables),
    options
  )
export const UpdateGameRoomDocument = `
    mutation updateGameRoom($input: UpdateRoomInput!) {
  updateRoom(input: $input) {
    room {
      ...gameRoomFields
    }
  }
}
    ${GameRoomFieldsFragmentDoc}`
export const useUpdateGameRoomMutation = <TError = QueryError, TContext = unknown>(
  options?: UseMutationOptions<UpdateGameRoomMutation, TError, UpdateGameRoomMutationVariables, TContext>
) =>
  useMutation<UpdateGameRoomMutation, TError, UpdateGameRoomMutationVariables, TContext>(
    ['updateGameRoom'],
    useFetchData<UpdateGameRoomMutation, UpdateGameRoomMutationVariables>(UpdateGameRoomDocument),
    options
  )
export const CreateGameRoomDocument = `
    mutation createGameRoom($input: CreateRoomInput!) {
  createRoom(input: $input) {
    room {
      ...gameRoomFields
    }
  }
}
    ${GameRoomFieldsFragmentDoc}`
export const useCreateGameRoomMutation = <TError = QueryError, TContext = unknown>(
  options?: UseMutationOptions<CreateGameRoomMutation, TError, CreateGameRoomMutationVariables, TContext>
) =>
  useMutation<CreateGameRoomMutation, TError, CreateGameRoomMutationVariables, TContext>(
    ['createGameRoom'],
    useFetchData<CreateGameRoomMutation, CreateGameRoomMutationVariables>(CreateGameRoomDocument),
    options
  )
export const DeleteGameRoomDocument = `
    mutation deleteGameRoom($input: DeleteRoomInput!) {
  deleteRoom(input: $input) {
    clientMutationId
    deletedRoomNodeId
  }
}
    `
export const useDeleteGameRoomMutation = <TError = QueryError, TContext = unknown>(
  options?: UseMutationOptions<DeleteGameRoomMutation, TError, DeleteGameRoomMutationVariables, TContext>
) =>
  useMutation<DeleteGameRoomMutation, TError, DeleteGameRoomMutationVariables, TContext>(
    ['deleteGameRoom'],
    useFetchData<DeleteGameRoomMutation, DeleteGameRoomMutationVariables>(DeleteGameRoomDocument),
    options
  )
export const GetGameRoomAndGamesDocument = `
    query getGameRoomAndGames($year: Int) {
  rooms {
    nodes {
      id
      description
      games(condition: {year: $year}, orderBy: SLOT_ID_ASC) {
        nodes {
          id
          name
          slotId
          gmNames
        }
      }
    }
  }
}
    `
export const useGetGameRoomAndGamesQuery = <TData = GetGameRoomAndGamesQuery, TError = QueryError>(
  variables?: GetGameRoomAndGamesQueryVariables,
  options?: UseQueryOptions<GetGameRoomAndGamesQuery, TError, TData>
) =>
  useQuery<GetGameRoomAndGamesQuery, TError, TData>(
    variables === undefined ? ['getGameRoomAndGames'] : ['getGameRoomAndGames', variables],
    useFetchData<GetGameRoomAndGamesQuery, GetGameRoomAndGamesQueryVariables>(GetGameRoomAndGamesDocument).bind(
      null,
      variables
    ),
    options
  )
export const GetHotelRoomsDocument = `
    query getHotelRooms {
  hotelRooms {
    edges {
      node {
        ...hotelRoomFields
      }
    }
  }
}
    ${HotelRoomFieldsFragmentDoc}`
export const useGetHotelRoomsQuery = <TData = GetHotelRoomsQuery, TError = QueryError>(
  variables?: GetHotelRoomsQueryVariables,
  options?: UseQueryOptions<GetHotelRoomsQuery, TError, TData>
) =>
  useQuery<GetHotelRoomsQuery, TError, TData>(
    variables === undefined ? ['getHotelRooms'] : ['getHotelRooms', variables],
    useFetchData<GetHotelRoomsQuery, GetHotelRoomsQueryVariables>(GetHotelRoomsDocument).bind(null, variables),
    options
  )
export const UpdateHotelRoomByNodeIdDocument = `
    mutation updateHotelRoomByNodeId($input: UpdateHotelRoomByNodeIdInput!) {
  updateHotelRoomByNodeId(input: $input) {
    hotelRoom {
      ...hotelRoomFields
    }
  }
}
    ${HotelRoomFieldsFragmentDoc}`
export const useUpdateHotelRoomByNodeIdMutation = <TError = QueryError, TContext = unknown>(
  options?: UseMutationOptions<
    UpdateHotelRoomByNodeIdMutation,
    TError,
    UpdateHotelRoomByNodeIdMutationVariables,
    TContext
  >
) =>
  useMutation<UpdateHotelRoomByNodeIdMutation, TError, UpdateHotelRoomByNodeIdMutationVariables, TContext>(
    ['updateHotelRoomByNodeId'],
    useFetchData<UpdateHotelRoomByNodeIdMutation, UpdateHotelRoomByNodeIdMutationVariables>(
      UpdateHotelRoomByNodeIdDocument
    ),
    options
  )
export const CreateHotelRoomDocument = `
    mutation createHotelRoom($input: CreateHotelRoomInput!) {
  createHotelRoom(input: $input) {
    hotelRoom {
      ...hotelRoomFields
    }
  }
}
    ${HotelRoomFieldsFragmentDoc}`
export const useCreateHotelRoomMutation = <TError = QueryError, TContext = unknown>(
  options?: UseMutationOptions<CreateHotelRoomMutation, TError, CreateHotelRoomMutationVariables, TContext>
) =>
  useMutation<CreateHotelRoomMutation, TError, CreateHotelRoomMutationVariables, TContext>(
    ['createHotelRoom'],
    useFetchData<CreateHotelRoomMutation, CreateHotelRoomMutationVariables>(CreateHotelRoomDocument),
    options
  )
export const DeleteHotelRoomDocument = `
    mutation deleteHotelRoom($input: DeleteHotelRoomInput!) {
  deleteHotelRoom(input: $input) {
    clientMutationId
    deletedHotelRoomNodeId
  }
}
    `
export const useDeleteHotelRoomMutation = <TError = QueryError, TContext = unknown>(
  options?: UseMutationOptions<DeleteHotelRoomMutation, TError, DeleteHotelRoomMutationVariables, TContext>
) =>
  useMutation<DeleteHotelRoomMutation, TError, DeleteHotelRoomMutationVariables, TContext>(
    ['deleteHotelRoom'],
    useFetchData<DeleteHotelRoomMutation, DeleteHotelRoomMutationVariables>(DeleteHotelRoomDocument),
    options
  )
export const GetHotelRoomDetailsDocument = `
    query getHotelRoomDetails {
  hotelRoomDetails {
    edges {
      node {
        ...hotelRoomDetailsFields
      }
    }
  }
}
    ${HotelRoomDetailsFieldsFragmentDoc}`
export const useGetHotelRoomDetailsQuery = <TData = GetHotelRoomDetailsQuery, TError = QueryError>(
  variables?: GetHotelRoomDetailsQueryVariables,
  options?: UseQueryOptions<GetHotelRoomDetailsQuery, TError, TData>
) =>
  useQuery<GetHotelRoomDetailsQuery, TError, TData>(
    variables === undefined ? ['getHotelRoomDetails'] : ['getHotelRoomDetails', variables],
    useFetchData<GetHotelRoomDetailsQuery, GetHotelRoomDetailsQueryVariables>(GetHotelRoomDetailsDocument).bind(
      null,
      variables
    ),
    options
  )
export const UpdateHotelRoomDetailByNodeIdDocument = `
    mutation updateHotelRoomDetailByNodeId($input: UpdateHotelRoomDetailByNodeIdInput!) {
  updateHotelRoomDetailByNodeId(input: $input) {
    hotelRoomDetail {
      ...hotelRoomDetailsFields
    }
  }
}
    ${HotelRoomDetailsFieldsFragmentDoc}`
export const useUpdateHotelRoomDetailByNodeIdMutation = <TError = QueryError, TContext = unknown>(
  options?: UseMutationOptions<
    UpdateHotelRoomDetailByNodeIdMutation,
    TError,
    UpdateHotelRoomDetailByNodeIdMutationVariables,
    TContext
  >
) =>
  useMutation<UpdateHotelRoomDetailByNodeIdMutation, TError, UpdateHotelRoomDetailByNodeIdMutationVariables, TContext>(
    ['updateHotelRoomDetailByNodeId'],
    useFetchData<UpdateHotelRoomDetailByNodeIdMutation, UpdateHotelRoomDetailByNodeIdMutationVariables>(
      UpdateHotelRoomDetailByNodeIdDocument
    ),
    options
  )
export const CreateHotelRoomDetailDocument = `
    mutation createHotelRoomDetail($input: CreateHotelRoomDetailInput!) {
  createHotelRoomDetail(input: $input) {
    hotelRoomDetail {
      ...hotelRoomDetailsFields
    }
  }
}
    ${HotelRoomDetailsFieldsFragmentDoc}`
export const useCreateHotelRoomDetailMutation = <TError = QueryError, TContext = unknown>(
  options?: UseMutationOptions<CreateHotelRoomDetailMutation, TError, CreateHotelRoomDetailMutationVariables, TContext>
) =>
  useMutation<CreateHotelRoomDetailMutation, TError, CreateHotelRoomDetailMutationVariables, TContext>(
    ['createHotelRoomDetail'],
    useFetchData<CreateHotelRoomDetailMutation, CreateHotelRoomDetailMutationVariables>(CreateHotelRoomDetailDocument),
    options
  )
export const DeleteHotelRoomDetailDocument = `
    mutation deleteHotelRoomDetail($input: DeleteHotelRoomDetailInput!) {
  deleteHotelRoomDetail(input: $input) {
    clientMutationId
    deletedHotelRoomDetailNodeId
  }
}
    `
export const useDeleteHotelRoomDetailMutation = <TError = QueryError, TContext = unknown>(
  options?: UseMutationOptions<DeleteHotelRoomDetailMutation, TError, DeleteHotelRoomDetailMutationVariables, TContext>
) =>
  useMutation<DeleteHotelRoomDetailMutation, TError, DeleteHotelRoomDetailMutationVariables, TContext>(
    ['deleteHotelRoomDetail'],
    useFetchData<DeleteHotelRoomDetailMutation, DeleteHotelRoomDetailMutationVariables>(DeleteHotelRoomDetailDocument),
    options
  )
export const GetLookupsDocument = `
    query getLookups {
  lookups(orderBy: REALM_ASC) {
    edges {
      node {
        ...lookupFields
        lookupValues(orderBy: SEQUENCER_ASC) {
          nodes {
            ...lookupValuesFields
          }
        }
      }
    }
  }
}
    ${LookupFieldsFragmentDoc}
${LookupValuesFieldsFragmentDoc}`
export const useGetLookupsQuery = <TData = GetLookupsQuery, TError = QueryError>(
  variables?: GetLookupsQueryVariables,
  options?: UseQueryOptions<GetLookupsQuery, TError, TData>
) =>
  useQuery<GetLookupsQuery, TError, TData>(
    variables === undefined ? ['getLookups'] : ['getLookups', variables],
    useFetchData<GetLookupsQuery, GetLookupsQueryVariables>(GetLookupsDocument).bind(null, variables),
    options
  )
export const GetLookupValuesDocument = `
    query getLookupValues($realm: String!) {
  lookups(condition: {realm: $realm}) {
    edges {
      node {
        ...lookupFields
        lookupValues(orderBy: VALUE_ASC) {
          nodes {
            ...lookupValuesFields
          }
        }
      }
    }
  }
}
    ${LookupFieldsFragmentDoc}
${LookupValuesFieldsFragmentDoc}`
export const useGetLookupValuesQuery = <TData = GetLookupValuesQuery, TError = QueryError>(
  variables: GetLookupValuesQueryVariables,
  options?: UseQueryOptions<GetLookupValuesQuery, TError, TData>
) =>
  useQuery<GetLookupValuesQuery, TError, TData>(
    ['getLookupValues', variables],
    useFetchData<GetLookupValuesQuery, GetLookupValuesQueryVariables>(GetLookupValuesDocument).bind(null, variables),
    options
  )
export const GetSingleLookupValueDocument = `
    query getSingleLookupValue($realm: String!, $code: String!) {
  lookups(condition: {realm: $realm}) {
    edges {
      node {
        ...lookupFields
        lookupValues(condition: {code: $code}) {
          nodes {
            ...lookupValuesFields
          }
        }
      }
    }
  }
}
    ${LookupFieldsFragmentDoc}
${LookupValuesFieldsFragmentDoc}`
export const useGetSingleLookupValueQuery = <TData = GetSingleLookupValueQuery, TError = QueryError>(
  variables: GetSingleLookupValueQueryVariables,
  options?: UseQueryOptions<GetSingleLookupValueQuery, TError, TData>
) =>
  useQuery<GetSingleLookupValueQuery, TError, TData>(
    ['getSingleLookupValue', variables],
    useFetchData<GetSingleLookupValueQuery, GetSingleLookupValueQueryVariables>(GetSingleLookupValueDocument).bind(
      null,
      variables
    ),
    options
  )
export const UpdateLookupByNodeIdDocument = `
    mutation updateLookupByNodeId($input: UpdateLookupByNodeIdInput!) {
  updateLookupByNodeId(input: $input) {
    lookup {
      ...lookupFields
    }
  }
}
    ${LookupFieldsFragmentDoc}`
export const useUpdateLookupByNodeIdMutation = <TError = QueryError, TContext = unknown>(
  options?: UseMutationOptions<UpdateLookupByNodeIdMutation, TError, UpdateLookupByNodeIdMutationVariables, TContext>
) =>
  useMutation<UpdateLookupByNodeIdMutation, TError, UpdateLookupByNodeIdMutationVariables, TContext>(
    ['updateLookupByNodeId'],
    useFetchData<UpdateLookupByNodeIdMutation, UpdateLookupByNodeIdMutationVariables>(UpdateLookupByNodeIdDocument),
    options
  )
export const CreateLookupDocument = `
    mutation createLookup($input: CreateLookupInput!) {
  createLookup(input: $input) {
    lookup {
      ...lookupFields
    }
  }
}
    ${LookupFieldsFragmentDoc}`
export const useCreateLookupMutation = <TError = QueryError, TContext = unknown>(
  options?: UseMutationOptions<CreateLookupMutation, TError, CreateLookupMutationVariables, TContext>
) =>
  useMutation<CreateLookupMutation, TError, CreateLookupMutationVariables, TContext>(
    ['createLookup'],
    useFetchData<CreateLookupMutation, CreateLookupMutationVariables>(CreateLookupDocument),
    options
  )
export const DeleteLookupDocument = `
    mutation deleteLookup($input: DeleteLookupInput!) {
  deleteLookup(input: $input) {
    clientMutationId
    deletedLookupNodeId
  }
}
    `
export const useDeleteLookupMutation = <TError = QueryError, TContext = unknown>(
  options?: UseMutationOptions<DeleteLookupMutation, TError, DeleteLookupMutationVariables, TContext>
) =>
  useMutation<DeleteLookupMutation, TError, DeleteLookupMutationVariables, TContext>(
    ['deleteLookup'],
    useFetchData<DeleteLookupMutation, DeleteLookupMutationVariables>(DeleteLookupDocument),
    options
  )
export const UpdateLookupValueByNodeIdDocument = `
    mutation updateLookupValueByNodeId($input: UpdateLookupValueByNodeIdInput!) {
  updateLookupValueByNodeId(input: $input) {
    lookupValue {
      ...lookupValuesFields
    }
  }
}
    ${LookupValuesFieldsFragmentDoc}`
export const useUpdateLookupValueByNodeIdMutation = <TError = QueryError, TContext = unknown>(
  options?: UseMutationOptions<
    UpdateLookupValueByNodeIdMutation,
    TError,
    UpdateLookupValueByNodeIdMutationVariables,
    TContext
  >
) =>
  useMutation<UpdateLookupValueByNodeIdMutation, TError, UpdateLookupValueByNodeIdMutationVariables, TContext>(
    ['updateLookupValueByNodeId'],
    useFetchData<UpdateLookupValueByNodeIdMutation, UpdateLookupValueByNodeIdMutationVariables>(
      UpdateLookupValueByNodeIdDocument
    ),
    options
  )
export const CreateLookupValueDocument = `
    mutation createLookupValue($input: CreateLookupValueInput!) {
  createLookupValue(input: $input) {
    lookupValue {
      ...lookupValuesFields
    }
  }
}
    ${LookupValuesFieldsFragmentDoc}`
export const useCreateLookupValueMutation = <TError = QueryError, TContext = unknown>(
  options?: UseMutationOptions<CreateLookupValueMutation, TError, CreateLookupValueMutationVariables, TContext>
) =>
  useMutation<CreateLookupValueMutation, TError, CreateLookupValueMutationVariables, TContext>(
    ['createLookupValue'],
    useFetchData<CreateLookupValueMutation, CreateLookupValueMutationVariables>(CreateLookupValueDocument),
    options
  )
export const DeleteLookupValueDocument = `
    mutation deleteLookupValue($input: DeleteLookupValueInput!) {
  deleteLookupValue(input: $input) {
    clientMutationId
    deletedLookupValueNodeId
  }
}
    `
export const useDeleteLookupValueMutation = <TError = QueryError, TContext = unknown>(
  options?: UseMutationOptions<DeleteLookupValueMutation, TError, DeleteLookupValueMutationVariables, TContext>
) =>
  useMutation<DeleteLookupValueMutation, TError, DeleteLookupValueMutationVariables, TContext>(
    ['deleteLookupValue'],
    useFetchData<DeleteLookupValueMutation, DeleteLookupValueMutationVariables>(DeleteLookupValueDocument),
    options
  )
export const GetMembershipByYearAndIdDocument = `
    query getMembershipByYearAndId($year: Int!, $userId: Int!) {
  memberships(condition: {userId: $userId, year: $year}) {
    nodes {
      ...membershipFields
    }
  }
}
    ${MembershipFieldsFragmentDoc}`
export const useGetMembershipByYearAndIdQuery = <TData = GetMembershipByYearAndIdQuery, TError = QueryError>(
  variables: GetMembershipByYearAndIdQueryVariables,
  options?: UseQueryOptions<GetMembershipByYearAndIdQuery, TError, TData>
) =>
  useQuery<GetMembershipByYearAndIdQuery, TError, TData>(
    ['getMembershipByYearAndId', variables],
    useFetchData<GetMembershipByYearAndIdQuery, GetMembershipByYearAndIdQueryVariables>(
      GetMembershipByYearAndIdDocument
    ).bind(null, variables),
    options
  )
export const GetMembershipsByYearDocument = `
    query getMembershipsByYear($year: Int!) {
  memberships(condition: {year: $year}) {
    nodes {
      ...membershipFields
    }
  }
}
    ${MembershipFieldsFragmentDoc}`
export const useGetMembershipsByYearQuery = <TData = GetMembershipsByYearQuery, TError = QueryError>(
  variables: GetMembershipsByYearQueryVariables,
  options?: UseQueryOptions<GetMembershipsByYearQuery, TError, TData>
) =>
  useQuery<GetMembershipsByYearQuery, TError, TData>(
    ['getMembershipsByYear', variables],
    useFetchData<GetMembershipsByYearQuery, GetMembershipsByYearQueryVariables>(GetMembershipsByYearDocument).bind(
      null,
      variables
    ),
    options
  )
export const GetMembershipRoomsByYearDocument = `
    query getMembershipRoomsByYear($year: Int!) {
  memberships(condition: {year: $year}) {
    nodes {
      hotelRoom {
        id
        type
        gamingRoom
        bathroomType
      }
    }
  }
}
    `
export const useGetMembershipRoomsByYearQuery = <TData = GetMembershipRoomsByYearQuery, TError = QueryError>(
  variables: GetMembershipRoomsByYearQueryVariables,
  options?: UseQueryOptions<GetMembershipRoomsByYearQuery, TError, TData>
) =>
  useQuery<GetMembershipRoomsByYearQuery, TError, TData>(
    ['getMembershipRoomsByYear', variables],
    useFetchData<GetMembershipRoomsByYearQuery, GetMembershipRoomsByYearQueryVariables>(
      GetMembershipRoomsByYearDocument
    ).bind(null, variables),
    options
  )
export const GetMembershipsByIdDocument = `
    query getMembershipsById($id: Int!) {
  memberships(condition: {id: $id}) {
    nodes {
      ...membershipFields
    }
  }
}
    ${MembershipFieldsFragmentDoc}`
export const useGetMembershipsByIdQuery = <TData = GetMembershipsByIdQuery, TError = QueryError>(
  variables: GetMembershipsByIdQueryVariables,
  options?: UseQueryOptions<GetMembershipsByIdQuery, TError, TData>
) =>
  useQuery<GetMembershipsByIdQuery, TError, TData>(
    ['getMembershipsById', variables],
    useFetchData<GetMembershipsByIdQuery, GetMembershipsByIdQueryVariables>(GetMembershipsByIdDocument).bind(
      null,
      variables
    ),
    options
  )
export const GetMembershipByYearAndRoomDocument = `
    query getMembershipByYearAndRoom($year: Int!, $hotelRoomId: Int!) {
  memberships(condition: {year: $year, hotelRoomId: $hotelRoomId}) {
    nodes {
      ...membershipFields
    }
  }
}
    ${MembershipFieldsFragmentDoc}`
export const useGetMembershipByYearAndRoomQuery = <TData = GetMembershipByYearAndRoomQuery, TError = QueryError>(
  variables: GetMembershipByYearAndRoomQueryVariables,
  options?: UseQueryOptions<GetMembershipByYearAndRoomQuery, TError, TData>
) =>
  useQuery<GetMembershipByYearAndRoomQuery, TError, TData>(
    ['getMembershipByYearAndRoom', variables],
    useFetchData<GetMembershipByYearAndRoomQuery, GetMembershipByYearAndRoomQueryVariables>(
      GetMembershipByYearAndRoomDocument
    ).bind(null, variables),
    options
  )
export const UpdateMembershipByNodeIdDocument = `
    mutation updateMembershipByNodeId($input: UpdateMembershipByNodeIdInput!) {
  updateMembershipByNodeId(input: $input) {
    membership {
      ...membershipFields
    }
  }
}
    ${MembershipFieldsFragmentDoc}`
export const useUpdateMembershipByNodeIdMutation = <TError = QueryError, TContext = unknown>(
  options?: UseMutationOptions<
    UpdateMembershipByNodeIdMutation,
    TError,
    UpdateMembershipByNodeIdMutationVariables,
    TContext
  >
) =>
  useMutation<UpdateMembershipByNodeIdMutation, TError, UpdateMembershipByNodeIdMutationVariables, TContext>(
    ['updateMembershipByNodeId'],
    useFetchData<UpdateMembershipByNodeIdMutation, UpdateMembershipByNodeIdMutationVariables>(
      UpdateMembershipByNodeIdDocument
    ),
    options
  )
export const CreateMembershipDocument = `
    mutation createMembership($input: CreateMembershipInput!) {
  createMembership(input: $input) {
    membership {
      ...membershipFields
    }
  }
}
    ${MembershipFieldsFragmentDoc}`
export const useCreateMembershipMutation = <TError = QueryError, TContext = unknown>(
  options?: UseMutationOptions<CreateMembershipMutation, TError, CreateMembershipMutationVariables, TContext>
) =>
  useMutation<CreateMembershipMutation, TError, CreateMembershipMutationVariables, TContext>(
    ['createMembership'],
    useFetchData<CreateMembershipMutation, CreateMembershipMutationVariables>(CreateMembershipDocument),
    options
  )
export const DeleteMembershipDocument = `
    mutation deleteMembership($input: DeleteMembershipInput!) {
  deleteMembership(input: $input) {
    clientMutationId
    deletedMembershipNodeId
  }
}
    `
export const useDeleteMembershipMutation = <TError = QueryError, TContext = unknown>(
  options?: UseMutationOptions<DeleteMembershipMutation, TError, DeleteMembershipMutationVariables, TContext>
) =>
  useMutation<DeleteMembershipMutation, TError, DeleteMembershipMutationVariables, TContext>(
    ['deleteMembership'],
    useFetchData<DeleteMembershipMutation, DeleteMembershipMutationVariables>(DeleteMembershipDocument),
    options
  )
export const GetSettingsDocument = `
    query getSettings {
  settings {
    nodes {
      ...settingFields
    }
  }
}
    ${SettingFieldsFragmentDoc}`
export const useGetSettingsQuery = <TData = GetSettingsQuery, TError = QueryError>(
  variables?: GetSettingsQueryVariables,
  options?: UseQueryOptions<GetSettingsQuery, TError, TData>
) =>
  useQuery<GetSettingsQuery, TError, TData>(
    variables === undefined ? ['getSettings'] : ['getSettings', variables],
    useFetchData<GetSettingsQuery, GetSettingsQueryVariables>(GetSettingsDocument).bind(null, variables),
    options
  )
export const CreateSettingDocument = `
    mutation createSetting($input: CreateSettingInput!) {
  createSetting(input: $input) {
    setting {
      ...settingFields
    }
  }
}
    ${SettingFieldsFragmentDoc}`
export const useCreateSettingMutation = <TError = QueryError, TContext = unknown>(
  options?: UseMutationOptions<CreateSettingMutation, TError, CreateSettingMutationVariables, TContext>
) =>
  useMutation<CreateSettingMutation, TError, CreateSettingMutationVariables, TContext>(
    ['createSetting'],
    useFetchData<CreateSettingMutation, CreateSettingMutationVariables>(CreateSettingDocument),
    options
  )
export const DeleteSettingDocument = `
    mutation deleteSetting($input: DeleteSettingInput!) {
  deleteSetting(input: $input) {
    clientMutationId
    deletedSettingNodeId
  }
}
    `
export const useDeleteSettingMutation = <TError = QueryError, TContext = unknown>(
  options?: UseMutationOptions<DeleteSettingMutation, TError, DeleteSettingMutationVariables, TContext>
) =>
  useMutation<DeleteSettingMutation, TError, DeleteSettingMutationVariables, TContext>(
    ['deleteSetting'],
    useFetchData<DeleteSettingMutation, DeleteSettingMutationVariables>(DeleteSettingDocument),
    options
  )
export const UpdateSettingByNodeIdDocument = `
    mutation updateSettingByNodeId($input: UpdateSettingByNodeIdInput!) {
  updateSettingByNodeId(input: $input) {
    setting {
      ...settingFields
    }
  }
}
    ${SettingFieldsFragmentDoc}`
export const useUpdateSettingByNodeIdMutation = <TError = QueryError, TContext = unknown>(
  options?: UseMutationOptions<UpdateSettingByNodeIdMutation, TError, UpdateSettingByNodeIdMutationVariables, TContext>
) =>
  useMutation<UpdateSettingByNodeIdMutation, TError, UpdateSettingByNodeIdMutationVariables, TContext>(
    ['updateSettingByNodeId'],
    useFetchData<UpdateSettingByNodeIdMutation, UpdateSettingByNodeIdMutationVariables>(UpdateSettingByNodeIdDocument),
    options
  )
export const GetSlotsDocument = `
    query getSlots {
  slots {
    nodes {
      ...slotFields
    }
  }
}
    ${SlotFieldsFragmentDoc}`
export const useGetSlotsQuery = <TData = GetSlotsQuery, TError = QueryError>(
  variables?: GetSlotsQueryVariables,
  options?: UseQueryOptions<GetSlotsQuery, TError, TData>
) =>
  useQuery<GetSlotsQuery, TError, TData>(
    variables === undefined ? ['getSlots'] : ['getSlots', variables],
    useFetchData<GetSlotsQuery, GetSlotsQueryVariables>(GetSlotsDocument).bind(null, variables),
    options
  )
export const GetUserByEmailDocument = `
    query getUserByEmail($email: String!) {
  userByEmail(email: $email) {
    ...userAndProfileFields
  }
}
    ${UserAndProfileFieldsFragmentDoc}`
export const useGetUserByEmailQuery = <TData = GetUserByEmailQuery, TError = QueryError>(
  variables: GetUserByEmailQueryVariables,
  options?: UseQueryOptions<GetUserByEmailQuery, TError, TData>
) =>
  useQuery<GetUserByEmailQuery, TError, TData>(
    ['getUserByEmail', variables],
    useFetchData<GetUserByEmailQuery, GetUserByEmailQueryVariables>(GetUserByEmailDocument).bind(null, variables),
    options
  )
export const GetUserByIdDocument = `
    query getUserById($id: Int!) {
  user(id: $id) {
    ...userFields
  }
}
    ${UserFieldsFragmentDoc}`
export const useGetUserByIdQuery = <TData = GetUserByIdQuery, TError = QueryError>(
  variables: GetUserByIdQueryVariables,
  options?: UseQueryOptions<GetUserByIdQuery, TError, TData>
) =>
  useQuery<GetUserByIdQuery, TError, TData>(
    ['getUserById', variables],
    useFetchData<GetUserByIdQuery, GetUserByIdQueryVariables>(GetUserByIdDocument).bind(null, variables),
    options
  )
export const UpdateUserDocument = `
    mutation updateUser($input: UpdateUserInput!) {
  updateUser(input: $input) {
    user {
      ...userFields
    }
  }
}
    ${UserFieldsFragmentDoc}`
export const useUpdateUserMutation = <TError = QueryError, TContext = unknown>(
  options?: UseMutationOptions<UpdateUserMutation, TError, UpdateUserMutationVariables, TContext>
) =>
  useMutation<UpdateUserMutation, TError, UpdateUserMutationVariables, TContext>(
    ['updateUser'],
    useFetchData<UpdateUserMutation, UpdateUserMutationVariables>(UpdateUserDocument),
    options
  )
export const GetAllUsersDocument = `
    query getAllUsers {
  users(orderBy: LAST_NAME_ASC) {
    nodes {
      ...userFields
    }
  }
}
    ${UserFieldsFragmentDoc}`
export const useGetAllUsersQuery = <TData = GetAllUsersQuery, TError = QueryError>(
  variables?: GetAllUsersQueryVariables,
  options?: UseQueryOptions<GetAllUsersQuery, TError, TData>
) =>
  useQuery<GetAllUsersQuery, TError, TData>(
    variables === undefined ? ['getAllUsers'] : ['getAllUsers', variables],
    useFetchData<GetAllUsersQuery, GetAllUsersQueryVariables>(GetAllUsersDocument).bind(null, variables),
    options
  )
export const GetAllUsersAndProfilesDocument = `
    query getAllUsersAndProfiles {
  users(orderBy: LAST_NAME_ASC) {
    nodes {
      ...userAndProfileFields
    }
  }
}
    ${UserAndProfileFieldsFragmentDoc}`
export const useGetAllUsersAndProfilesQuery = <TData = GetAllUsersAndProfilesQuery, TError = QueryError>(
  variables?: GetAllUsersAndProfilesQueryVariables,
  options?: UseQueryOptions<GetAllUsersAndProfilesQuery, TError, TData>
) =>
  useQuery<GetAllUsersAndProfilesQuery, TError, TData>(
    variables === undefined ? ['getAllUsersAndProfiles'] : ['getAllUsersAndProfiles', variables],
    useFetchData<GetAllUsersAndProfilesQuery, GetAllUsersAndProfilesQueryVariables>(
      GetAllUsersAndProfilesDocument
    ).bind(null, variables),
    options
  )
export const GetAllUsersByDocument = `
    query getAllUsersBy($query: String!) {
  users(orderBy: LAST_NAME_ASC, filter: {fullName: {includesInsensitive: $query}}) {
    nodes {
      ...userFields
      memberships(condition: {attending: true}) {
        nodes {
          id
          year
        }
      }
    }
  }
}
    ${UserFieldsFragmentDoc}`
export const useGetAllUsersByQuery = <TData = GetAllUsersByQuery, TError = QueryError>(
  variables: GetAllUsersByQueryVariables,
  options?: UseQueryOptions<GetAllUsersByQuery, TError, TData>
) =>
  useQuery<GetAllUsersByQuery, TError, TData>(
    ['getAllUsersBy', variables],
    useFetchData<GetAllUsersByQuery, GetAllUsersByQueryVariables>(GetAllUsersByDocument).bind(null, variables),
    options
  )
export const CreateProfileDocument = `
    mutation createProfile($input: CreateProfileInput!) {
  createProfile(input: $input) {
    clientMutationId
  }
}
    `
export const useCreateProfileMutation = <TError = QueryError, TContext = unknown>(
  options?: UseMutationOptions<CreateProfileMutation, TError, CreateProfileMutationVariables, TContext>
) =>
  useMutation<CreateProfileMutation, TError, CreateProfileMutationVariables, TContext>(
    ['createProfile'],
    useFetchData<CreateProfileMutation, CreateProfileMutationVariables>(CreateProfileDocument),
    options
  )
export const UpdateProfileByNodeIdDocument = `
    mutation updateProfileByNodeId($input: UpdateProfileByNodeIdInput!) {
  updateProfileByNodeId(input: $input) {
    clientMutationId
  }
}
    `
export const useUpdateProfileByNodeIdMutation = <TError = QueryError, TContext = unknown>(
  options?: UseMutationOptions<UpdateProfileByNodeIdMutation, TError, UpdateProfileByNodeIdMutationVariables, TContext>
) =>
  useMutation<UpdateProfileByNodeIdMutation, TError, UpdateProfileByNodeIdMutationVariables, TContext>(
    ['updateProfileByNodeId'],
    useFetchData<UpdateProfileByNodeIdMutation, UpdateProfileByNodeIdMutationVariables>(UpdateProfileByNodeIdDocument),
    options
  )
